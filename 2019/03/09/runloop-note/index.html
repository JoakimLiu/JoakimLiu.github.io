<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="本文是对 Threading Programming Guide - Run Loops 文档的一个学习(其中参考了 CFRunLoop 源码)，其他例子在后期系统了解某个技术有涉及时再说。 其他高质量文章可见  深入理解RunLoop 解密 Runloop">
<meta property="og:type" content="article">
<meta property="og:title" content="Runloop 基础">
<meta property="og:url" content="http://example.com/2019/03/09/runloop-note/index.html">
<meta property="og:site_name" content="牛易疯先森的开发记录">
<meta property="og:description" content="本文是对 Threading Programming Guide - Run Loops 文档的一个学习(其中参考了 CFRunLoop 源码)，其他例子在后期系统了解某个技术有涉及时再说。 其他高质量文章可见  深入理解RunLoop 解密 Runloop">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/Art/runloop.jpg">
<meta property="og:image" content="https://github.com/JoakimLiu/BlogPhoto/blob/master/runloop/runloop-sequence-mrpeak.png?raw=true">
<meta property="og:image" content="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/Art/custominputsource.jpg">
<meta property="article:published_time" content="2019-03-09T05:02:34.000Z">
<meta property="article:modified_time" content="2021-01-22T14:55:23.852Z">
<meta property="article:author" content="joakim.liu">
<meta property="article:tag" content="runloop">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/Art/runloop.jpg">

<link rel="canonical" href="http://example.com/2019/03/09/runloop-note/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Runloop 基础 | 牛易疯先森的开发记录</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">牛易疯先森的开发记录</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/03/09/runloop-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="joakim.liu">
      <meta itemprop="description" content="你不解决问题，就会成为问题。iOS菜逗一枚。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="牛易疯先森的开发记录">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Runloop 基础
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-09 13:02:34" itemprop="dateCreated datePublished" datetime="2019-03-09T13:02:34+08:00">2019-03-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文是对 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1">Threading Programming Guide - Run Loops</a> 文档的一个学习(其中参考了 <a href="https://opensource.apple.com/source/CF/CF-1153.18/CFRunLoop.c.auto.html">CFRunLoop</a> 源码)，其他例子在后期系统了解某个技术有涉及时再说。 其他高质量文章可见</p>
<ul>
<li><a href="https://blog.ibireme.com/2015/05/18/runloop/">深入理解RunLoop</a></li>
<li><a href="http://mrpeak.cn/blog/ios-runloop/">解密 Runloop</a></li>
</ul>
<a id="more"></a>

<h1 id="啥是-Run-Loop"><a href="#啥是-Run-Loop" class="headerlink" title="啥是 Run Loop"></a>啥是 Run Loop</h1><p>run loop 是与线程相关的基础架构的一部分。 它是<strong>一个事件处理循环，用于计划工作并协调传入事件的接收</strong>。 它的<strong>目的是</strong>在有工作时保持线程忙，并在没有工作时让线程进入休眠状态。 我们开发者的代码提供了用于实现 run loop 的实际循环部分的控制语句 - 换句话说，代码提供了驱动 run loop 的 while 或 for 循环。 在循环中，使用 run loop 对象<strong>运行接收</strong>事件处理代码，并调用已安装的处理程序。</p>
<p>run loop 从<strong>两种不同类型的源接收事件</strong>。 输入源(input sources)提供异步事件，通常是来自另一个线程或来自不同应用程序的消息。 定时器源(timer sources)提供同步事件，发生在预定时间或重复间隔。 两种类型的源都使用特定于应用程序的处理程序程序来<strong>处理</strong>到达事件。</p>
<p>下图显示了 run loop 和各种源的概念结构。 输入源将异步事件传递给相应的处理程序，并调用 <code>runUntilDate:</code> 方法（在线程的关联 NSRunLoop 对象上调用）退出。 计时器源将事件传递给其处理程序，但不会导致 run loop 退出。</p>
<p><img src="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/Art/runloop.jpg" alt="Structure of a run loop and its sources"></p>
<p>除了处理输入源之外， run loop 还会生成有关 run loop 行为的通知。 可以使用 Core Foundation 在线程上安装 run loop 观察器。</p>
<h2 id="Input-Sources"><a href="#Input-Sources" class="headerlink" title="Input Sources"></a>Input Sources</h2><p>通常分两类，它们都是以异步方式向线程传递事件，唯一区别是<strong>它们如何发出信号</strong>。</p>
<ul>
<li>Port-based input sources: 基于的端口的输入源，监听应用程序的 Mach 端口（由内核自动发出信号，源码中被称为 source1 ）。</li>
<li>Custom input sources: 自定义输入源，监听自定义事件源（必须从另一个线程手动发信号通知自定义源，源码中被称为 source0 ）。</li>
</ul>
<p>如果输入源未处于当前监听模式，则它生成的任何事件会被 hold 住，直到 run loop 以正确模式运行。</p>
<h3 id="Port-Based-Sources"><a href="#Port-Based-Sources" class="headerlink" title="Port-Based Sources"></a>Port-Based Sources</h3><p>Cocoa 和 Core Foundation 提供 使用与端口相关的对象和函数<strong>创建基于端口的输入源 的内置支持</strong>。 例如，在 Cocoa 中，根本不必直接创建输入源，只需创建一个端口对象，并使用 NSPort 的方法将该端口添加到 run loop 中。 port 对象处理所需输入源的创建和配置。</p>
<p>在 Core Foundation 中，必须手动创建端口及其 run loop 源。 在这两种情况下，都使用与端口 opaque 类型(CFMachPortRef CFMessagePortRef 或 CFSocketRef)相关联的函数来创建适当的对象。</p>
<h3 id="Custom-Input-Sources"><a href="#Custom-Input-Sources" class="headerlink" title="Custom Input Sources"></a>Custom Input Sources</h3><p>要创建自定义输入源，必须在 Core Foundation 中使用与 CFRunLoopSourceRef opaque 类型关联的函数。 可以使用多个回调函数配置<strong>自定义输入源</strong>。 Core Foundation 在不同的点调用这些函数来配置源，处理传入事件，并在从 run loop 中删除源时拆除源。</p>
<p>除了在事件到达时，定义自定义源的行为，还必须定义事件<strong>传递机制</strong>。 源的这一部分在一个单独的线程上运行，负责为输入源提供数据，并在数据准备好进行处理时发出信号。 事件传递机制取决于我们开发者，但不必过于复杂。</p>
<h3 id="Cocoa-Perform-Selector-Sources"><a href="#Cocoa-Perform-Selector-Sources" class="headerlink" title="Cocoa Perform Selector Sources"></a>Cocoa Perform Selector Sources</h3><p>除了基于端口的源之外， Cocoa 还定义了一个自定义输入源，允许在任何线程上执行选择器(selector)。与基于端口的源类似，在目标线程上<strong>依次执行</strong>选择器请求，从而减轻了在一个线程上运行多个方法时可能发生的许多<strong>同步问题</strong>。与基于端口的源不同，选择器源在执行后<strong>将其自身从 run loop 中移除</strong>。</p>
<p>在另一个线程上执行选择器时，目标线程<strong>必须具有</strong> active run loop 。对于自定义创建的线程，这意味着要等到代码显式启动 run loop 。但是，因为主线程启动了自己的 run loop ，所以只要应用程序调用应用程序委托的 <code>applicationDidFinishLaunching:</code> 方法，就可以开始在该线程上发出调用。 run loop 每次通过循环处理<strong>所有排队</strong>的执行选择器调用，而不是在每次循环迭代期间<strong>处理一个</strong>。</p>
<p>下表列出了在 NSObject 上定义的可用于在其他线程上执行选择器的方法。因为这些方法是在 NSObject 上声明的，所以可以在<strong>任何</strong>可以访问 Objective-C 对象的线程中使用它们，包括 POSIX 线程。这些方法实际上<strong>并不创建新线程来执行选择器</strong>。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>performSelectorOnMainThread:withObject:waitUntilDone:</code>, <code>performSelectorOnMainThread:withObject:waitUntilDone:modes:</code></td>
<td>在主线程的<strong>下一个 run loop 周期</strong>中，执行指定的选择器。 提供了阻止当前线程直到执行选择器的选项。</td>
</tr>
<tr>
<td><code>performSelector:onThread:withObject:waitUntilDone:</code>, <code>performSelector:onThread:withObject:waitUntilDone:modes:</code></td>
<td>在<strong>具有 NSThread 对象</strong>的线程上执行指定的选择器 。 也提供了阻止当前线程直到执行选择器的选项。</td>
</tr>
<tr>
<td><code>performSelector:withObject:afterDelay:</code>, <code>performSelector:withObject:afterDelay:inModes:</code></td>
<td>在当前线程上的下一个 run loop 周期和可选的延迟后，执行指定的选择器。</td>
</tr>
<tr>
<td><code>cancelPreviousPerformRequestsWithTarget:</code>, <code>cancelPreviousPerformRequestsWithTarget:selector:object:</code></td>
<td>给使用 <code>performSelector:withObject:afterDelay:</code> 或<code>performSelector:withObject:afterDelay:inModes:</code> 方法的当前线程发送取消消息。</td>
</tr>
</tbody></table>
<h2 id="Timer-Sources"><a href="#Timer-Sources" class="headerlink" title="Timer Sources"></a>Timer Sources</h2><p>计时器源在将来的预设时间将事件同步传递给线程。定时器是<strong>线程通知自己做某事的一种方式</strong>。</p>
<p>虽然它生成基于时间的通知，但计时器<strong>不是实时的</strong> （它有一个属性 tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差，目的就是为了节省资源）。 与输入源类似，定时器与 run loop 的<strong>特定模式相关联</strong>。 如果计时器未处于 run loop 当前正在监听的模式，则在使用其中一个计时器支持的模式运行 run loop 之前，它不会触发。 类似地，如果计时器在 run loop <strong>处于执行处理程序的过程中触发，则计时器将等待直到下一次</strong>通过 run loop 来调用其处理程序。 如果 run loop 根本没有运行，则计时器永远不会触发。</p>
<p>可以将计时器配置为仅生成一次或重复生成事件。 重复计时器根据<strong>计划的触发(fire)时间自动重新安排自己，而不是实际触发时间</strong>。 如果触发时间延迟太多以至于错过了一个或多个预定发射时间，则计时器仅在错过的时间段内<strong>触发一次</strong>。 在为错过的时段触发之后，计时器被重新安排用于下一个预定的触发时间。</p>
<h2 id="Run-Loop-Observers"><a href="#Run-Loop-Observers" class="headerlink" title="Run Loop Observers"></a>Run Loop Observers</h2><p>与在发生<strong>适当的</strong>异步或同步事件时触发的源相反， observer 在执行 run loop 期间在特殊位置触发。 特殊的位置如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1UL</span> &lt;&lt; <span class="number">0</span>), <span class="comment">// 进入 run loop</span></span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1UL</span> &lt;&lt; <span class="number">1</span>), <span class="comment">// run loop 即将处理 timer</span></span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1UL</span> &lt;&lt; <span class="number">2</span>), <span class="comment">// run loop 即将处理 input source</span></span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1UL</span> &lt;&lt; <span class="number">5</span>), <span class="comment">// run loop 即将进入休眠状态时</span></span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1UL</span> &lt;&lt; <span class="number">6</span>), <span class="comment">// run loop 已经被唤醒，在处理唤醒它的事件之前</span></span><br><span class="line">    kCFRunLoopExit = (<span class="number">1UL</span> &lt;&lt; <span class="number">7</span>),  <span class="comment">// 从 run loop 退出</span></span><br><span class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以使用 Core Foundation 将 observer 添加到应用程序。要创建 observer ，请创建 CFRunLoopObserverRef opaque 类型的新实例。 此类型会跟踪自定义回调函数及其感兴趣的活动。</p>
<p>与定时器类似， <strong>observer 可以使用一次或重复使用</strong>。一次性 observer 在触发后将其自身从 run loop 中移除，而重复的 observer 仍然存在。</p>
<h2 id="The-Run-Loop-Sequence-of-Events"><a href="#The-Run-Loop-Sequence-of-Events" class="headerlink" title="The Run Loop Sequence of Events"></a>The Run Loop Sequence of Events</h2><p>线程的 run loop 每次运行时，都会处理挂起(pending)的事件，并为所有附加的 observer 生成通知。它的执行顺序如下：</p>
<ol>
<li>通知 observer 进入 run loop</li>
<li>通知 observer 准备好的 timer 即将触发</li>
<li>通知 observer source0 即将触发 </li>
<li>触发准备好的 source0</li>
<li>如果 source1 已经准备好并且等待触发，立即处理事件，并跳到第 9 步</li>
<li>通知 observer 线程即将进入休眠状态</li>
<li>让线程置于休眠状态，直到被以下条件唤醒：<ul>
<li>source1 事件到达</li>
<li>timer 触发</li>
<li>为 run loop 设置的超时值到了</li>
<li>run loop 被手动唤醒</li>
</ul>
</li>
<li>通知 observer 线程刚被唤醒</li>
<li>处理挂起的事件<ul>
<li>如果用户定义 timer 被触发了，处理 timer 事件并重启 run loop 。并跳到第 2 步</li>
<li>如果 input source 被触发了，分发事件</li>
<li>如果 run loop 被手动唤醒但是还没超时，重启 run loop 。并跳到第 2 步</li>
</ul>
</li>
<li>通知 observer 已经退出 run loop </li>
</ol>
<p>核心代码主要在下面两个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SInt32 <span class="title">CFRunLoopRunSpecific</span><span class="params">(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int32_t</span> __<span class="title">CFRunLoopRun</span><span class="params">(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode)</span> </span></span><br></pre></td></tr></table></figure>
<p>相关核心代码(摘取了包含前缀<code>__CFRunLoop</code> 的代码)如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 通知 observer 进入 run loop</span></span><br><span class="line"><span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry); <span class="comment">// 最终走 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 2. 通知 observer 准备好的 timer 即将触发</span></span><br><span class="line">    <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">    <span class="comment">// 3. 通知 observer source0 即将触发 </span></span><br><span class="line">    <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行 Block</span></span><br><span class="line">    __CFRunLoopDoBlocks(rl, rlm);  <span class="comment">// 最终走 __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 触发准备好的 source0</span></span><br><span class="line">    Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle); <span class="comment">// 最终走 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__</span></span><br><span class="line">    <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 如果 source1 已经准备好并且等待触发，立即处理事件，并跳到第 9 步 （读取和 mainQueue 相关的消息，这里不会导致睡眠(入参 timeout = 0)，保证 dispatch 到 mainQueue 代码有较高的机会运行）</span></span><br><span class="line">    Boolean poll = sourceHandledThisLoop || (<span class="number">0ULL</span> == timeout_context-&gt;termTSR);</span><br><span class="line">    <span class="keyword">if</span> (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123;</span><br><span class="line">        msg = (<span class="keyword">mach_msg_header_t</span> *)msg_buffer;</span><br><span class="line">        <span class="keyword">if</span> (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, <span class="number">0</span>, &amp;voucherState, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            <span class="keyword">goto</span> handle_msg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 通知 observer 线程即将进入休眠状态</span></span><br><span class="line">    <span class="keyword">if</span> (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	__CFRunLoopSetSleeping(rl);</span><br><span class="line">    __CFPortSetInsert(dispatchPort, waitSet);</span><br><span class="line">	__CFRunLoopModeUnlock(rlm);</span><br><span class="line">	__CFRunLoopUnlock(rl);</span><br><span class="line">    <span class="keyword">if</span> (kCFUseCollectableAllocator) &#123;</span><br><span class="line">        <span class="comment">// objc_clear_stack(0);</span></span><br><span class="line">       <span class="comment">// &lt;rdar://problem/16393959&gt;</span></span><br><span class="line">       <span class="built_in">memset</span>(msg_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg_buffer));</span><br><span class="line">    &#125;</span><br><span class="line">    msg = (<span class="keyword">mach_msg_header_t</span> *)msg_buffer;</span><br><span class="line">    <span class="comment">// 7. 让线程置于休眠状态，直到被以下条件唤醒 (注意入参poll 的值，是否睡眠)</span></span><br><span class="line">    __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, poll ? <span class="number">0</span> : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line"></span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    __CFRunLoopModeLock(rlm);</span><br><span class="line">    __CFPortSetRemove(dispatchPort, waitSet);</span><br><span class="line">    __CFRunLoopSetIgnoreWakeUps(rl);</span><br><span class="line">	__CFRunLoopUnsetSleeping(rl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8. 通知 observer 线程刚被唤醒</span></span><br><span class="line">	<span class="keyword">if</span> (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 9. 处理挂起的事件</span></span><br><span class="line">    handle_msg:;</span><br><span class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (MACH_PORT_NULL == livePort) &#123; <span class="comment">// 没事情</span></span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_NOTHING();</span><br><span class="line">            <span class="comment">// handle nothing</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (livePort == rl-&gt;_wakeUpPort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_WAKEUP();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123; <span class="comment">// (或者 livePort == rlm-&gt;_timerPort) 处理 timer</span></span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</span><br><span class="line">            <span class="keyword">if</span> (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123; <span class="comment">// 最终走 __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__</span></span><br><span class="line">                <span class="comment">// Re-arm the next timer, because we apparently fired early</span></span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (livePort == dispatchPort) &#123; <span class="comment">// dispatch mainQueue 事件</span></span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_DISPATCH();</span><br><span class="line">            __CFRunLoopModeUnlock(rlm);</span><br><span class="line">            __CFRunLoopUnlock(rl);</span><br><span class="line"></span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg); </span><br><span class="line"></span><br><span class="line">            __CFRunLoopLock(rl);</span><br><span class="line">            __CFRunLoopModeLock(rlm);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// source1</span></span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_SOURCE();</span><br><span class="line"></span><br><span class="line">            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</span><br><span class="line">            <span class="keyword">if</span> (rls) &#123;</span><br><span class="line">		    <span class="keyword">mach_msg_header_t</span> *reply = <span class="literal">NULL</span>;</span><br><span class="line">		    sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop; <span class="comment">// 最终走 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__</span></span><br><span class="line">		    <span class="keyword">if</span> (<span class="literal">NULL</span> != reply) &#123;</span><br><span class="line">		        (<span class="keyword">void</span>)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, <span class="number">0</span>, MACH_PORT_NULL, <span class="number">0</span>, MACH_PORT_NULL);</span><br><span class="line">		     CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);</span><br><span class="line">		    &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行 Block</span></span><br><span class="line">    __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 判断循环条件</span></span><br><span class="line">	<span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">	    retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">            __CFRunLoopUnsetStopped(rl);</span><br><span class="line">	    retVal = kCFRunLoopRunStopped;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped) &#123;</span><br><span class="line">	    rlm-&gt;_stopped = <span class="literal">false</span>;</span><br><span class="line">	    retVal = kCFRunLoopRunStopped;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class="line">	    retVal = kCFRunLoopRunFinished;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span> == retVal);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 10. 通知 observer 已经退出 run loop </span></span><br><span class="line"><span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br></pre></td></tr></table></figure>
<p>可以参考高峰大佬的<a href="http://mrpeak.cn/blog/ios-runloop/">解密 Runloop</a> 里面的流程图</p>
<p><img src="https://github.com/JoakimLiu/BlogPhoto/blob/master/runloop/runloop-sequence-mrpeak.png?raw=true" alt="run loop sequence"></p>
<p>由于 timer 和 input sources 的 observer 通知是在这些事件<strong>实际发生之前传递的</strong>，因此通知时间与实际事件的时间之间可能存在差距。 如果这些事件之间的时间关系很重要，可以使用<strong>休眠和唤醒休眠通知来帮助关联</strong>实际事件之间的时间。</p>
<p>可以使用 run loop 对象手动唤醒它，其他事件也可能导致 run loop 被唤醒。例如，添加另一个非基于端口的输入源会唤醒 run loop ，以便可以立即处理输入源，而不是等到其他事件发生。</p>
<h2 id="Run-Loop-Modes"><a href="#Run-Loop-Modes" class="headerlink" title="Run Loop Modes"></a>Run Loop Modes</h2><p>这个概念很重要， run loop mode(模式) 是要监听的输入源(input sources)和计时器(timers)<strong>的集合</strong>，以及要通知的 run loop observers <strong>的集合</strong>。每次运行 run loop 时，都指定（显式或隐式）运行的特定模式。在 run loop 的传递过程中，<strong>仅监听与该模式关联的源并允许其传递事件</strong>。 类似地，只有与该模式相关联的 observers 被通知 run loop 的进度。 与其他模式相关联的源保持新事件，直到后续以适当模式通过循环。</p>
<p>在代码中，可以按名称识别模式。 Cocoa 和 Core Foundation 都定义了默认模式和几种常用模式(见下表)，以及用于在代码中指定这些模式的字符串。 只需为模式名称指定自定义字符串<strong>即可定义自定义模式</strong>。 虽然为自定义模式指定的名称是任意的，但<strong>这些模式的内容不是</strong>。 必须确保将一个或多个输入源，计时器或 run loop 观察器<strong>添加到为其创建的任何模式中</strong>才有用。 (ps: 模式中要有相关源和观察器才有用)</p>
<table>
<thead>
<tr>
<th>Mode</th>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>Default</td>
<td>NSDefaultRunLoopMode (Cocoa), kCFRunLoopDefaultMode (Core Foundation)</td>
<td>用于大多数操作的模式，大多数情况，应该使用它启动 run loop 并配置输入源。</td>
</tr>
<tr>
<td>Connection</td>
<td>NSConnectionReplyMode (Cocoa)</td>
<td>与 NSConnection 对象结合使用去监听回复，很少用到。</td>
</tr>
<tr>
<td>Modal</td>
<td>NSModalPanelRunLoopMode (Cocoa)</td>
<td>识别用于模态面板(modal panels)的事件。</td>
</tr>
<tr>
<td>Event tracking</td>
<td>NSEventTrackingRunLoopMode (Cocoa)</td>
<td>限制 在鼠标拖动循环和其他用户界面跟踪循环期间 的传入事件。</td>
</tr>
<tr>
<td>Common modes</td>
<td>NSRunLoopCommonModes (Cocoa), kCFRunLoopCommonModes (Core Foundation)</td>
<td>可配置的常用模式。 将输入源与此模式相关联，也会将其与组中的<strong>每个模式相关联</strong>。 对于 Cocoa 应用程序，此集合默认包括 Default ，Modal 和 Event tracking 模式。 Core Foundation 最初只包含 Default 模式，可以使用 CFRunLoopAddCommonMode 函数将自定义模式添加到集合中。</td>
</tr>
</tbody></table>
<p>可以使用模式在特定的运行循环期间过<strong>滤掉不需要的</strong>来源中的事件。 大多数情况下，需要在系统定义的“默认”模式下运行运行循环。 但是，模态面板可能以“模态”模式运行，在此模式下，只有与模态面板相关的源才会将事件传递给线程。对于次级线程，可以使用自定义模式来<strong>防止低优先级源在时间关键操作期间传递事件</strong>。</p>
<p>注意：<strong>模式根据事件的来源而不是事件的类型进行区分</strong>。 </p>
<p>run loop mode 结构体定义如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopMode</span> &#123;</span></span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> _lock;	<span class="comment">/* must have the run loop locked before locking this */</span></span><br><span class="line">    CFStringRef _name;</span><br><span class="line">    Boolean _stopped;</span><br><span class="line">    <span class="keyword">char</span> _padding[<span class="number">3</span>];</span><br><span class="line">    CFMutableSetRef _sources0; </span><br><span class="line">    CFMutableSetRef _sources1;</span><br><span class="line">    CFMutableArrayRef _observers;</span><br><span class="line">    CFMutableArrayRef _timers;</span><br><span class="line">    CFMutableDictionaryRef _portToV1SourceMap;</span><br><span class="line">    __CFPortSet _portSet;</span><br><span class="line">    CFIndex _observerMask;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span></span><br><span class="line">    <span class="keyword">dispatch_source_t</span> _timerSource;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> _queue;</span><br><span class="line">    Boolean _timerFired; <span class="comment">// set to true by the source when a timer has fired</span></span><br><span class="line">    Boolean _dispatchTimerArmed;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_MK_TIMER_TOO</span></span><br><span class="line">    <span class="keyword">mach_port_t</span> _timerPort;</span><br><span class="line">    Boolean _mkTimerArmed;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEPLOYMENT_TARGET_WINDOWS</span></span><br><span class="line">    DWORD _msgQMask;</span><br><span class="line">    <span class="keyword">void</span> (*_msgPump)(<span class="keyword">void</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">uint64_t</span> _timerSoftDeadline; <span class="comment">/* TSR */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> _timerHardDeadline; <span class="comment">/* TSR */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以看到结构体里面有定义 _sources0 _sources1 _observers _timers ，唯独没有定义 mainQueue ，因为 mainQueue 的执行与 mode 没关系。 前面 run loop 执行的流程代码，在调用 <code>__CFRunLoopDoObservers XXXXXX</code> 方法通知 observers 回调之前，都会用 <code>(currentMode-&gt;_observerMask &amp; CFRunLoopActivity)</code> 做判断，只有 _observerMask 里面有相关类型值，才会回调 observers 。 用下面方法添加 observers 的时候， _observerMask 都会更新</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CFRunLoopAddObserver</span><span class="params">(CFRunLoopRef rl, CFRunLoopObserverRef rlo, CFStringRef modeName)</span> </span></span><br></pre></td></tr></table></figure>

<h1 id="什么时候需要-Run-Loop"><a href="#什么时候需要-Run-Loop" class="headerlink" title="什么时候需要 Run Loop?"></a>什么时候需要 Run Loop?</h1><p>手动运行 run loop 的<strong>唯一时间是为应用程序创建次级线程</strong>。 应用程序主线程的 run loop 是一个至关重要的基础架构，在启动程序的时候，主循环就已经创建好了。</p>
<p>对于次级线程，需要确定是否需要 run loop ，如果是，<strong>请自行配置并启动它</strong>。 如果使用线程执行某些长时间运行且预定义的任务，则可以<strong>不需要启动</strong> run loop 。<strong>run loop 适用于希望与线程进行更多交互的情况</strong>。 例如：</p>
<ul>
<li>使用端口或自定义 input source 与其他线程通信</li>
<li>在线程上使用 timer</li>
<li>在 Cocoa 应用程序中使用任何 <code>performSelector...</code> 方法</li>
<li>保持线程以执行定期任务</li>
</ul>
<p>如果确实选择使用 run loop ，则配置和设置非常简单。与所有线程编程一样，应该在适当情况下退出次级线程，而不是强行退出。</p>
<h1 id="使用-Run-Loop-对象"><a href="#使用-Run-Loop-对象" class="headerlink" title="使用 Run Loop 对象"></a>使用 Run Loop 对象</h1><p>run loop 对象提供了主要接口，用于将 input sources ，timers 和 observers <strong>添加到</strong> run loop  ，然后运行它。 <strong>每个线程都有一个与之关联的 run loop 对象</strong>。 在 Cocoa 中，是 <a href="https://developer.apple.com/library/archive/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSRunLoop/Description.html#//apple_ref/occ/cl/NSRunLoop">NSRunLoop</a> 类的实例。 在低级应用程序中，它是指向 <a href="https://developer.apple.com/documentation/corefoundation/cfrunloopref">CFRunLoopRef</a> opaque 类型的指针。</p>
<h2 id="Getting-a-Run-Loop-Object"><a href="#Getting-a-Run-Loop-Object" class="headerlink" title="Getting a Run Loop Object"></a>Getting a Run Loop Object</h2><p>获取当前线程的 run loop ，可以使用下面的其中一个方法</p>
<ul>
<li>在 Cocoa App 中，调用 NSRunLoop 的 <code>currentRunLoop</code> 类方法，获取 NSRunLoop 对象</li>
<li>使用 <code>CFRunLoopGetCurrent</code> 函数</li>
</ul>
<p>虽然它们<strong>不是</strong> toll-free bridged 类型，但可以在需要时从 NSRunLoop 对象获取 CFRunLoopRef opaque 类型。<br>因为两者<strong>都引用相同的</strong> run loop 对象，所以可以混合使用。</p>
<h2 id="Configuring-the-Run-Loop"><a href="#Configuring-the-Run-Loop" class="headerlink" title="Configuring the Run Loop"></a>Configuring the Run Loop</h2><p>在次级线程上运行 run loop 之前，<strong>必须至少添加一个输入源或计时器</strong>。如果 run loop 没有要监听的任何源，则在尝试运行它时<strong>会立即退出</strong>。</p>
<p>除了安装源之外，还可以安装运行 observer 并使用它们来检测 run loop 的不同执行阶段。下面的代码展示了一个将 observer 附加到其 run loop 的线程的主程序。如何创建 observer ，以及用它来监听 run loop 的所有活动，没有显示监听回调函数 <code>myRunLoopObserver</code> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-1 Creating a run loop observer</span><br><span class="line">- (void)threadMain</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; The application uses garbage collection, so no autorelease pool is needed.</span><br><span class="line">    NSRunLoop* myRunLoop &#x3D; [NSRunLoop currentRunLoop];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Create a run loop observer and attach it to the run loop.</span><br><span class="line">    CFRunLoopObserverContext  context &#x3D; &#123;0, self, NULL, NULL, NULL&#125;;</span><br><span class="line">    CFRunLoopObserverRef    observer &#x3D; CFRunLoopObserverCreate(kCFAllocatorDefault,</span><br><span class="line">            kCFRunLoopAllActivities, YES, 0, &amp;myRunLoopObserver, &amp;context);</span><br><span class="line"> </span><br><span class="line">    if (observer)</span><br><span class="line">    &#123;</span><br><span class="line">        CFRunLoopRef    cfLoop &#x3D; [myRunLoop getCFRunLoop];</span><br><span class="line">        CFRunLoopAddObserver(cfLoop, observer, kCFRunLoopDefaultMode);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Create and schedule the timer.</span><br><span class="line">    [NSTimer scheduledTimerWithTimeInterval:0.1 target:self</span><br><span class="line">                selector:@selector(doFireTimer:) userInfo:nil repeats:YES];</span><br><span class="line"> </span><br><span class="line">    NSInteger    loopCount &#x3D; 10;</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; Run the run loop 10 times to let the timer fire.</span><br><span class="line">        [myRunLoop runUntilDate:[NSDate dateWithTimeIntervalSinceNow:1]];</span><br><span class="line">        loopCount--;</span><br><span class="line">    &#125;</span><br><span class="line">    while (loopCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为长期存在的线程配置 run loop 时，最好添加<strong>至少一个输入源来接收消息</strong>。 <strong>虽然可以连接一个定时器</strong>进入 run loop ，但一旦定时器触发，它通常会失效，这会导致运行循环退出。 重复计时器可以使 run loop 运行更长的时间，但是会涉及<strong>定期触发计时器以唤醒线程，这实际上是另一种形式的轮询</strong>。 相比之下，<strong>输入源会等待事件发生，让线程保持睡眠状态</strong>。</p>
<h2 id="Starting-the-Run-Loop"><a href="#Starting-the-Run-Loop" class="headerlink" title="Starting the Run Loop"></a>Starting the Run Loop</h2><p>只用次级线程才需要启动 run loop 。 run loop 必须至少有一个输入源或者计时器才能进行监听，如果没有，则<strong>会立即退出</strong>。有以下几种方法可以启动 run loop</p>
<ul>
<li>无条件 (<code>run</code>)</li>
<li>设置时限 (<code>runUntilDate:</code>)</li>
<li>在特定模式下 (<code>runMode:beforeDate:</code>)</li>
</ul>
<p>无条件是最简单的，但也是最不可取的。它让 run loop 置于永久循环中，使得我们开发者<strong>无法控制它</strong>。我们可以添加和删除输入源或者计时器，但是<strong>停止它的唯一方法是杀掉他</strong>。并且它<strong>也没法在自定义模式下运行</strong>。</p>
<p>最好设置时限运行 run loop ，它<strong>将一直运行，直到事件到达或分配的时间到期</strong>。如果事件到达，则将该事件分派给处理程序进行处理，然后退出 run loop 。可以重新启动它以处理下一个事件。如果指定的时间到期了，只需重新启动它或使用时间进行任何所需的内务(housekeeping)处理。</p>
<p>可以使用特定模式运行 run loop 。它与设置时限不是互斥的，模式<strong>限制将事件传递到 run loop 的源类型</strong>。</p>
<p>下面的代码展示了线程主入口程序的框架，显示了 run loop 的基本结构。 实质上，将输入源和计时器添加到 run loop 中，然后重复调用其中一个程序以启动 run loop 。 每次 run loop 程序返回时，都会检查是否出现了可能需要退出该线程的任何条件。 该示例使用 Core Foundation 运行 run loop ，以便它可以检查返回结果并确定运行循环退出的原因。 如果使用 Cocoa 并且<strong>不需要检查返回值</strong>，也可以使用 NSRunLoop 类的方法以类似的方式运行 run loop (后面 Listing 3-14 有代码)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-2 Running a run loop</span><br><span class="line">- (void)skeletonThreadMain</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Set up an autorelease pool here if not using garbage collection.</span><br><span class="line">    BOOL done &#x3D; NO;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Add your sources or timers to the run loop and do any other setup.</span><br><span class="line"> </span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; Start the run loop but return after each source is handled.</span><br><span class="line">        SInt32    result &#x3D; CFRunLoopRunInMode(kCFRunLoopDefaultMode, 10, YES);</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; If a source explicitly stopped the run loop, or if there are no</span><br><span class="line">        &#x2F;&#x2F; sources or timers, go ahead and exit.</span><br><span class="line">        if ((result &#x3D;&#x3D; kCFRunLoopRunStopped) || (result &#x3D;&#x3D; kCFRunLoopRunFinished))</span><br><span class="line">            done &#x3D; YES;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; Check for any other exit conditions here and set the</span><br><span class="line">        &#x2F;&#x2F; done variable as needed.</span><br><span class="line">    &#125;</span><br><span class="line">    while (!done);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Clean up code here. Be sure to release any allocated autorelease pools.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以<strong>递归地运行</strong> run loop 。 换句话说，可以调用 CFRunLoopRun ， CFRunLoopRunInMode 或任何 NSRunLoop 方法，以便从输入源或计时器的<strong>处理程序程序中启动 run loop</strong> 。 执行此操作时，可以使用任何要运行嵌套 run loop 的模式，包括外部 run loop 使用的模式。</p>
<h2 id="Exiting-the-Run-Loop"><a href="#Exiting-the-Run-Loop" class="headerlink" title="Exiting the Run Loop"></a>Exiting the Run Loop</h2><p>在处理事件之前，有两种方法可以使 run loop 退出：</p>
<ul>
<li>使用超时值</li>
<li>告诉 run loop 停止</li>
</ul>
<p>推荐使用超时值，因为我们可以管理 run loop 。它能让 run loop <strong>完成所有的正常处理</strong>，包括给 observer 发送通知。</p>
<p>使用 <code>CFRunLoopStop</code> 函数可以手动停止 run loop。 run loop 发出剩下的通知后退出。用这个方法可以停止无条件启动的 run loop 。</p>
<p>虽然删除 run loop 的输入源和定时器也可能导致运行循环退出，但这不是停止 run loop 的可靠方法。一些系统程序将输入源添加到 run loop 以处理所需的事件。我们<strong>可能不知道它们</strong>，所以删除的时候就会漏掉它们。</p>
<h2 id="Thread-Safety-and-Run-Loop-Objects"><a href="#Thread-Safety-and-Run-Loop-Objects" class="headerlink" title="Thread Safety and Run Loop Objects"></a>Thread Safety and Run Loop Objects</h2><p>Core Foundation 中的函数通常是线程安全的，可以从任何线程调用。但是，如果要执行更改 run loop 配置的操作，<strong>尽可能从拥有 run loop 的线程执行此操作</strong>。</p>
<p>Cocoa NSRunLoop 类不像 Core Foundation 对应的那样具有内在的线程安全性。 如果使用 NSRunLoop 类来修改 run loop ，<strong>必须在拥有该 run loop 的同一线程执行此操作</strong>。 将输入源或计时器添加到属于不同线程的 run loop 可能会导致代码崩溃或以意外方式运行。<br>(ps: 在拥有 run loop 的线程中做相关更改 run loop 的操作。)</p>
<h1 id="Configuring-Run-Loop-Sources"><a href="#Configuring-Run-Loop-Sources" class="headerlink" title="Configuring Run Loop Sources"></a>Configuring Run Loop Sources</h1><h2 id="Defining-a-Custom-Input-Source"><a href="#Defining-a-Custom-Input-Source" class="headerlink" title="Defining a Custom Input Source"></a>Defining a Custom Input Source</h2><p>创建自定义输入源涉及到以下定义：</p>
<ul>
<li>The information you want your input source to process. (希望输入源处理的信息)</li>
<li>A scheduler routine to let interested clients know how to contact your input source. (让感兴趣的客户端知道如何联系输入源的 scheduler 程序)</li>
<li>A handler routine to perform requests sent by any clients. (执行 客户端发送的请求的 处理程序)</li>
<li>A cancellation routine to invalidate your input source. (使输入源无效的取消程序)</li>
</ul>
<p>由于是自定义创建输入源，所以实际配置的设计非常灵活。 scheduler handler cancellation 这些程序的实现<strong>是关键</strong>。 但是，大多数输入源行为的其余部分都发生在这些处理程序之外，可以定义 将数据传递到输入源以及将输入源传递给其他线程的 机制。</p>
<p>下图显示了自定义输入源的示例配置。主线程维护对输入源的引用，以及该输入源的自定义命令缓冲区(custom command buffer)以及安装输入源的 run loop 。当主线程有一个任务，想要传递给工作线程时，它会向命令缓冲区发布一个命令以及工作线程启动任务所需的任何信息。 （因为主线程和工作线程的输入源都可以访问命令缓冲区，所以必须同步该访问。） 一旦命令发布，主线程就会发出信号输入源并唤醒工作线程的 run loop 。收到唤醒命令后， run loop 调用输入源的处理程序，该处理程序处理命令缓冲区中的命令。</p>
<p><img src="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/Art/custominputsource.jpg" alt="Operating a custom input source"></p>
<p>以下部分介绍了上图中自定义输入源的实现，并显示了需要实现的关键代码。(ps: 具体 demo 见 <a href="https://github.com/JoakimLiu/RunLoopDemo">RunLoopDemo</a>)</p>
<h3 id="Defining-the-Input-Source"><a href="#Defining-the-Input-Source" class="headerlink" title="Defining the Input Source"></a>Defining the Input Source</h3><p>定义自定义输入源需要使用 Core Foundation 程序来配置 run loop 源并将其附加到 run loop 。 虽然基本处理程序是基于 C 的函数，但这并不妨碍为这些函数编写包装器并使用 Objective-C 或 C++ 来实现。 </p>
<p>下面的代码中， RunLoopSource 对象管理命令缓冲区并使用该缓冲区从其他线程接收消息。 RunLoopContext 是一个容器对象，用于传递 RunLoopSource 对象和对应用程序主线程的 run loop 引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-3  The custom input source object definition</span><br><span class="line">@interface RunLoopSource : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    CFRunLoopSourceRef runLoopSource;</span><br><span class="line">    NSMutableArray* commands;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (id)init;</span><br><span class="line">- (void)addToCurrentRunLoop;</span><br><span class="line">- (void)invalidate;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Handler method</span><br><span class="line">- (void)sourceFired;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Client interface for registering commands to process</span><br><span class="line">- (void)addCommand:(NSInteger)command withData:(id)data;</span><br><span class="line">- (void)fireAllCommandsOnRunLoop:(CFRunLoopRef)runloop;</span><br><span class="line"> </span><br><span class="line">@end</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; These are the CFRunLoopSourceRef callback functions.</span><br><span class="line">void RunLoopSourceScheduleRoutine (void *info, CFRunLoopRef rl, CFStringRef mode);</span><br><span class="line">void RunLoopSourcePerformRoutine (void *info);</span><br><span class="line">void RunLoopSourceCancelRoutine (void *info, CFRunLoopRef rl, CFStringRef mode);</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; RunLoopContext is a container object used during registration of the input source.</span><br><span class="line">@interface RunLoopContext : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    CFRunLoopRef        runLoop;</span><br><span class="line">    RunLoopSource*        source;</span><br><span class="line">&#125;</span><br><span class="line">@property (readonly) CFRunLoopRef runLoop;</span><br><span class="line">@property (readonly) RunLoopSource* source;</span><br><span class="line"> </span><br><span class="line">- (id)initWithSource:(RunLoopSource*)src andLoop:(CFRunLoopRef)loop;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>当将 run loop 源添加到 run loop 时，就调用 <code>RunLoopSourceScheduleRoutine</code> 函数。之前有说过，输入源只有一个客户端，那就是主线程，所以将 RunLoopContext 传递过去，方便 delegate 和输入源通信。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-4 Scheduling a run loop source</span><br><span class="line">void RunLoopSourceScheduleRoutine (void *info, CFRunLoopRef rl, CFStringRef mode)</span><br><span class="line">&#123;</span><br><span class="line">    RunLoopSource* obj &#x3D; (RunLoopSource*)info;</span><br><span class="line">    AppDelegate*   del &#x3D; [AppDelegate sharedAppDelegate];</span><br><span class="line">    RunLoopContext* theContext &#x3D; [[RunLoopContext alloc] initWithSource:obj andLoop:rl];</span><br><span class="line"> </span><br><span class="line">    [del performSelectorOnMainThread:@selector(registerSource:)</span><br><span class="line">                                withObject:theContext waitUntilDone:NO];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当输入源被发出信号时，调用 <code>RunLoopSourcePerformRoutine</code> 处理数据，它是最重要的回调函数。 这里只是简单的调用 RunLoopSource 的 <code>sourceFired</code> 方法，后面会讲到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-5  Performing work in the input source</span><br><span class="line">void RunLoopSourcePerformRoutine (void *info)</span><br><span class="line">&#123;</span><br><span class="line">    RunLoopSource*  obj &#x3D; (RunLoopSource*)info;</span><br><span class="line">    [obj sourceFired];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用 <code>CFRunLoopSourceInvalidate</code> 函数从 run loop 中删除输入源，系统将调用输入源的取消程序 <code>RunLoopSourceCancelRoutine</code> 。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-6  Invalidating an input source</span><br><span class="line">void RunLoopSourceCancelRoutine (void *info, CFRunLoopRef rl, CFStringRef mode)</span><br><span class="line">&#123;</span><br><span class="line">    RunLoopSource* obj &#x3D; (RunLoopSource*)info;</span><br><span class="line">    AppDelegate* del &#x3D; [AppDelegate sharedAppDelegate];</span><br><span class="line">    RunLoopContext* theContext &#x3D; [[RunLoopContext alloc] initWithSource:obj andLoop:rl];</span><br><span class="line"> </span><br><span class="line">    [del performSelectorOnMainThread:@selector(removeSource:)</span><br><span class="line">                                withObject:theContext waitUntilDone:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Installing-the-Input-Source-on-the-Run-Loop"><a href="#Installing-the-Input-Source-on-the-Run-Loop" class="headerlink" title="Installing the Input Source on the Run Loop"></a>Installing the Input Source on the Run Loop</h3><p>下面显示了 RunLoopSource 类的 <code>init</code> 和 <code>addToCurrentRunLoop</code> 方法。 <code>init</code> 方法创建 CFRunLoopSourceRef opaque 类型，<strong>该类型必须附加到 run loop</strong> 。 它将 RunLoopSource 对象本身作为上下文信息传递，以便回调程序具有指向该对象的指针。 在工作线程调用 <code>addToCurrentRunLoop</code> 方法时才会安装输入源，此时将调用 <code>RunLoopSourceScheduleRoutine</code> 回调函数。 一旦输入源被添加到 run loop 中，线程就可以运行其 run loop 来等待它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-7  Installing the run loop source</span><br><span class="line">- (id)init</span><br><span class="line">&#123;</span><br><span class="line">    CFRunLoopSourceContext    context &#x3D; &#123;0, self, NULL, NULL, NULL, NULL, NULL,</span><br><span class="line">                                        &amp;RunLoopSourceScheduleRoutine,</span><br><span class="line">                                        RunLoopSourceCancelRoutine,</span><br><span class="line">                                        RunLoopSourcePerformRoutine&#125;;</span><br><span class="line"> </span><br><span class="line">    runLoopSource &#x3D; CFRunLoopSourceCreate(NULL, 0, &amp;context);</span><br><span class="line">    commands &#x3D; [[NSMutableArray alloc] init];</span><br><span class="line"> </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)addToCurrentRunLoop</span><br><span class="line">&#123;</span><br><span class="line">    CFRunLoopRef runLoop &#x3D; CFRunLoopGetCurrent();</span><br><span class="line">    CFRunLoopAddSource(runLoop, runLoopSource, kCFRunLoopDefaultMode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Coordinating-with-Clients-of-the-Input-Source"><a href="#Coordinating-with-Clients-of-the-Input-Source" class="headerlink" title="Coordinating with Clients of the Input Source"></a>Coordinating with Clients of the Input Source</h3><p>要使输入源有用，需要对其进行操作，并从另一个线程发出信号。输入源的<strong>重点是</strong>将其关联的线程置于休眠状态，直到有事情要做才唤醒。所以，需要让应用程序中的<strong>其他线程知道输入源</strong>，并有办法与之通信。</p>
<p>通知客户端输入源的一种方法是，在输入源首次安装在其 run loop 上时<strong>发出注册请求</strong>。 可以使用任意数量的客户端注册输入源，或者只需将其注册到某个中央代理商，然后将输入源发送给感兴趣的客户。下面代码显示了应用程序委托定义的注册方法，并在调用 RunLoopSource 对象的调度程序函数时调用。 此方法接收 RunLoopSource 对象提供的 RunLoopContext 对象，并将其添加到其源列表中。 还显示了从 run loop 中删除输入源时用于取消注册的程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-8  Registering and removing an input source with the application delegate</span><br><span class="line">- (void)registerSource:(RunLoopContext*)sourceInfo;</span><br><span class="line">&#123;</span><br><span class="line">    [sourcesToPing addObject:sourceInfo];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)removeSource:(RunLoopContext*)sourceInfo</span><br><span class="line">&#123;</span><br><span class="line">    id    objToRemove &#x3D; nil;</span><br><span class="line"> </span><br><span class="line">    for (RunLoopContext* context in sourcesToPing)</span><br><span class="line">    &#123;</span><br><span class="line">        if ([context isEqual:sourceInfo])</span><br><span class="line">        &#123;</span><br><span class="line">            objToRemove &#x3D; context;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (objToRemove)</span><br><span class="line">        [sourcesToPing removeObject:objToRemove];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Signaling-the-Input-Source"><a href="#Signaling-the-Input-Source" class="headerlink" title="Signaling the Input Source"></a>Signaling the Input Source</h3><p>在将数据移交给输入源之后，<strong>客户端必须向源发信号并唤醒其 run loop</strong> 。 信号源使 run loop 知道源已准备好进行处理。 并且因为线程可能在信号发生时处于睡眠状态，所以手动唤醒 run loop 。 如果不这样做可能会导致处理输入源的延迟。</p>
<p>下面代码显示了 RunLoopSource 对象的 <code>fireCommandsOnRunLoop</code> 方法。 当客户端准备好处理他们添加到缓冲区的命令时，客户端会调用此方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-9  Waking up the run loop</span><br><span class="line">- (void)fireCommandsOnRunLoop:(CFRunLoopRef)runloop</span><br><span class="line">&#123;</span><br><span class="line">    CFRunLoopSourceSignal(runLoopSource);</span><br><span class="line">    CFRunLoopWakeUp(runloop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Configuring-Timer-Sources"><a href="#Configuring-Timer-Sources" class="headerlink" title="Configuring Timer Sources"></a>Configuring Timer Sources</h2><p>要创建计时器源，所要做的就是创建一个计时器对象并在 run loop 上安排(schedule)它。在 Cocoa 中，使用 NSTimer 创建计时器对象，在 Core Foundation 中使用 CFRunLoopTimerRef opaque 类型。在内部， NSTimer 类只是 Core Foundation 的扩展，它提供了一些便利功能。用以下方法可以创建</p>
<ul>
<li><code>cheduledTimerWithTimeInterval:target:selector:userInfo:repeats:</code></li>
<li><code>scheduledTimerWithTimeInterval:invocation:repeats:</code></li>
</ul>
<p>这些方法创建计时器并将其以默认模式（NSDefaultRunLoopMode）<strong>添加到当前线程</strong>的 run loop 中。如果需要，还可以手动调度计时器，方法是创建 NSTimer 对象，然后使用 NSRunLoop 的 <code>addTimer:forMode:</code> 方法将其添加到 run loop 中。这两种技术基本上都是一样的，但是可以对计时器的配置进行不同程度的控制。例如，如果创建计时器并手动将其添加到 run loop ，则可以使用默认模式以外的模式执行此操作。下面的代码显示了如何使用这两种技术创建计时器。第一个计时器的初始延迟为 1 秒，但之后每 0.1 秒定时触发一次。第二个计时器在最初的 0.2秒延迟后开始触发，然后每 0.2 秒触发一次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-10  Creating and scheduling timers using NSTimer</span><br><span class="line">NSRunLoop* myRunLoop &#x3D; [NSRunLoop currentRunLoop];</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Create and schedule the first timer.</span><br><span class="line">NSDate* futureDate &#x3D; [NSDate dateWithTimeIntervalSinceNow:1.0];</span><br><span class="line">NSTimer* myTimer &#x3D; [[NSTimer alloc] initWithFireDate:futureDate</span><br><span class="line">                        interval:0.1</span><br><span class="line">                        target:self</span><br><span class="line">                        selector:@selector(myDoFireTimer1:)</span><br><span class="line">                        userInfo:nil</span><br><span class="line">                        repeats:YES];</span><br><span class="line">[myRunLoop addTimer:myTimer forMode:NSDefaultRunLoopMode];</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Create and schedule the second timer.</span><br><span class="line">[NSTimer scheduledTimerWithTimeInterval:0.2</span><br><span class="line">                        target:self</span><br><span class="line">                        selector:@selector(myDoFireTimer2:)</span><br><span class="line">                        userInfo:nil</span><br><span class="line">                        repeats:YES];</span><br></pre></td></tr></table></figure>
<p>下面的代码展示了使用 Core Foundation 函数配置计时器所需的代码。 虽然此示例未在上下文结构中传递任何用户定义的信息，但可以使用此结构传递计时器所需的任何自定义数据。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-11  Creating and scheduling a timer using Core Foundation</span><br><span class="line">CFRunLoopRef runLoop &#x3D; CFRunLoopGetCurrent();</span><br><span class="line">CFRunLoopTimerContext context &#x3D; &#123;0, NULL, NULL, NULL, NULL&#125;;</span><br><span class="line">CFRunLoopTimerRef timer &#x3D; CFRunLoopTimerCreate(kCFAllocatorDefault, 0.1, 0.3, 0, 0,</span><br><span class="line">                                        &amp;myCFTimerCallback, &amp;context);</span><br><span class="line"> </span><br><span class="line">CFRunLoopAddTimer(runLoop, timer, kCFRunLoopCommonModes);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Configuring-a-Port-Based-Input-Source"><a href="#Configuring-a-Port-Based-Input-Source" class="headerlink" title="Configuring a Port-Based Input Source"></a>Configuring a Port-Based Input Source</h2><p>Cocoa 和 Core Foundation 都提供了基于端口的对象，<strong>用于线程之间或进程之间的通信</strong>。 以下部分介绍如何使用多种不同类型的端口设置端口通信。</p>
<h3 id="Configuring-an-NSMachPort-Object"><a href="#Configuring-an-NSMachPort-Object" class="headerlink" title="Configuring an NSMachPort Object"></a>Configuring an NSMachPort Object</h3><p>要与 NSMachPort 对象建立本地连接，请创建端口对象并将其添加到主线程的 run loop 中。 启动次级线程时，将同一对象传递给线程的入口函数。 次级线程可以使用相同的对象将消息发送回主线程。</p>
<h4 id="Implementing-the-Main-Thread-Code"><a href="#Implementing-the-Main-Thread-Code" class="headerlink" title="Implementing the Main Thread Code"></a>Implementing the Main Thread Code</h4><p>下面的代码展示了启动次级工作线程的主要代码。因为 Cocoa 框架执行许多配置端口和 run loop 的干预步骤，所以 <code>launchThread</code> 方法明显比其 Core Foundation 等效方法要短（见后面 Listing 3-17）; 然而，两者的行为几乎完全相同。 一个区别是，该方法不是直接向工作线程发送本地端口的名称，而是直接发送 NSPort 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-12  Main thread launch method</span><br><span class="line">- (void)launchThread</span><br><span class="line">&#123;</span><br><span class="line">    NSPort* myPort &#x3D; [NSMachPort port];</span><br><span class="line">    if (myPort)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; This class handles incoming port messages.</span><br><span class="line">        [myPort setDelegate:self];</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; Install the port as an input source on the current run loop.</span><br><span class="line">        [[NSRunLoop currentRunLoop] addPort:myPort forMode:NSDefaultRunLoopMode];</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; Detach the thread. Let the worker release the port.</span><br><span class="line">        [NSThread detachNewThreadSelector:@selector(LaunchThreadWithPort:)</span><br><span class="line">               toTarget:[MyWorkerClass class] withObject:myPort];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了在线程之间建立双向通信通道，可能希望让工作线程在 check-in 消息中将其自己的本地端口发送到主线程。 通过接收 check-in 消息，主线程可以知道在启动工作线程时一切顺利，并且还提供了向该线程发送更多消息的方法。</p>
<p>下面的代码显示了主线程的 <code>handlePortMessage:</code> 方法。 当数据到达线程自己的本地端口时，将调用此方法。 当 check-in 消息到达时，该方法直接从端口消息中检索次级线程的端口并保存以供以后使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-13  Handling Mach port messages</span><br><span class="line"></span><br><span class="line">#define kCheckinMessage 100</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Handle responses from the worker thread.</span><br><span class="line">- (void)handlePortMessage:(NSPortMessage *)portMessage</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int message &#x3D; [portMessage msgid];</span><br><span class="line">    NSPort* distantPort &#x3D; nil;</span><br><span class="line"> </span><br><span class="line">    if (message &#x3D;&#x3D; kCheckinMessage)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; Get the worker thread’s communications port.</span><br><span class="line">        distantPort &#x3D; [portMessage sendPort];</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; Retain and save the worker port for later use.</span><br><span class="line">        [self storeDistantPort:distantPort];</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; Handle other messages.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Implementing-the-Secondary-Thread-Code"><a href="#Implementing-the-Secondary-Thread-Code" class="headerlink" title="Implementing the Secondary Thread Code"></a>Implementing the Secondary Thread Code</h4><p>对于次级工作线程，必须配置线程并使用指定的端口将信息传递回主线程。</p>
<p>下面代码显示了设置工作线程的代码。 在为线程创建自动释放池之后，该方法创建一个工作对象来驱动线程执行。 worker 对象的 <code>sendCheckinMessage:</code> 方法（如后面 Listing 3-15 所示）为工作线程创建一个本地端口，并将一个 check-in 发送回主线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-14  Launching the worker thread using Mach ports</span><br><span class="line"></span><br><span class="line">+(void)LaunchThreadWithPort:(id)inData</span><br><span class="line">&#123;</span><br><span class="line">    NSAutoreleasePool*  pool &#x3D; [[NSAutoreleasePool alloc] init];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Set up the connection between this thread and the main thread.</span><br><span class="line">    NSPort* distantPort &#x3D; (NSPort*)inData;</span><br><span class="line"> </span><br><span class="line">    MyWorkerClass*  workerObj &#x3D; [[self alloc] init];</span><br><span class="line">    [workerObj sendCheckinMessage:distantPort];</span><br><span class="line">    [distantPort release];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Let the run loop process things.</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">        [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode</span><br><span class="line">                            beforeDate:[NSDate distantFuture]];</span><br><span class="line">    &#125;</span><br><span class="line">    while (![workerObj shouldExit]);</span><br><span class="line"> </span><br><span class="line">    [workerObj release];</span><br><span class="line">    [pool release];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 NSMachPort 时，本地和远程线程可以使用相同的端口对象进行线程之间的单向通信。 换句话说，由一个线程创建的本地端口对象成为另一个线程的远程端口对象。</p>
<p>下面代码显示了次级线程的 check-in 程序。 此方法为将来的通信设置自己的本地端口，然后将 check-in 消息发送回主线程。 该方法使用 <code>LaunchThreadWithPort:</code> 方法中接收的端口对象作为消息的目标。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-15  Sending the check-in message using Mach ports</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Worker thread check-in method</span><br><span class="line">- (void)sendCheckinMessage:(NSPort*)outPort</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Retain and save the remote port for future use.</span><br><span class="line">    [self setRemotePort:outPort];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Create and configure the worker thread port.</span><br><span class="line">    NSPort* myPort &#x3D; [NSMachPort port];</span><br><span class="line">    [myPort setDelegate:self];</span><br><span class="line">    [[NSRunLoop currentRunLoop] addPort:myPort forMode:NSDefaultRunLoopMode];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Create the check-in message.</span><br><span class="line">    NSPortMessage* messageObj &#x3D; [[NSPortMessage alloc] initWithSendPort:outPort</span><br><span class="line">                                         receivePort:myPort components:nil];</span><br><span class="line"> </span><br><span class="line">    if (messageObj)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; Finish configuring the message and send it immediately.</span><br><span class="line">        [messageObj setMsgId:setMsgid:kCheckinMessage];</span><br><span class="line">        [messageObj sendBeforeDate:[NSDate date]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Configuring-an-NSMessagePort-Object"><a href="#Configuring-an-NSMessagePort-Object" class="headerlink" title="Configuring an NSMessagePort Object"></a>Configuring an NSMessagePort Object</h3><p>要与 NSMessagePort 对象建立本地连接，不能简单地在线程之间传递端口对象。 必须按名称获取远程消息端口。 在 Cocoa 中实现这一点需要使用特定名称注册本地端口，然后将该名称传递给远程线程，以便它可以获取适当的端口对象进行通信。 下面代码显示了在要使用消息端口的情况下的端口创建和注册过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-16  Registering a message port</span><br><span class="line"></span><br><span class="line">NSPort* localPort &#x3D; [[NSMessagePort alloc] init];</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Configure the object and add it to the current run loop.</span><br><span class="line">[localPort setDelegate:self];</span><br><span class="line">[[NSRunLoop currentRunLoop] addPort:localPort forMode:NSDefaultRunLoopMode];</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Register the port using a specific name. The name must be unique.</span><br><span class="line">NSString* localPortName &#x3D; [NSString stringWithFormat:@&quot;MyPortName&quot;];</span><br><span class="line">[[NSMessagePortNameServer sharedInstance] registerPort:localPort</span><br><span class="line">                     name:localPortName];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Configuring-a-Port-Based-Input-Source-in-Core-Foundation"><a href="#Configuring-a-Port-Based-Input-Source-in-Core-Foundation" class="headerlink" title="Configuring a Port-Based Input Source in Core Foundation"></a>Configuring a Port-Based Input Source in Core Foundation</h3><p>本节介绍如何使用 Core Foundation 在应用程序的主线程和工作线程之间建立双向通信通道。</p>
<p>下面代码显示了应用程序主线程调用以启动工作线程的代码。 代码所做的第一件事就是设置一个 CFMessagePortRef opaque 类型来监听来自工作线程的消息。 工作线程需要端口的名称来建立连接，以便将字符串值传递给工作线程的入口函数。 端口名称在当前用户上下文中通常应该是唯一的； 否则，可能会遇到冲突。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-17  Attaching a Core Foundation message port to a new thread</span><br><span class="line"></span><br><span class="line">#define kThreadStackSize        (8 *4096)</span><br><span class="line"> </span><br><span class="line">OSStatus MySpawnThread()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Create a local port for receiving responses.</span><br><span class="line">    CFStringRef myPortName;</span><br><span class="line">    CFMessagePortRef myPort;</span><br><span class="line">    CFRunLoopSourceRef rlSource;</span><br><span class="line">    CFMessagePortContext context &#x3D; &#123;0, NULL, NULL, NULL, NULL&#125;;</span><br><span class="line">    Boolean shouldFreeInfo;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Create a string with the port name.</span><br><span class="line">    myPortName &#x3D; CFStringCreateWithFormat(NULL, NULL, CFSTR(&quot;com.myapp.MainThread&quot;));</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Create the port.</span><br><span class="line">    myPort &#x3D; CFMessagePortCreateLocal(NULL,</span><br><span class="line">                myPortName,</span><br><span class="line">                &amp;MainThreadResponseHandler,</span><br><span class="line">                &amp;context,</span><br><span class="line">                &amp;shouldFreeInfo);</span><br><span class="line"> </span><br><span class="line">    if (myPort !&#x3D; NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; The port was successfully created.</span><br><span class="line">        &#x2F;&#x2F; Now create a run loop source for it.</span><br><span class="line">        rlSource &#x3D; CFMessagePortCreateRunLoopSource(NULL, myPort, 0);</span><br><span class="line"> </span><br><span class="line">        if (rlSource)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; Add the source to the current run loop.</span><br><span class="line">            CFRunLoopAddSource(CFRunLoopGetCurrent(), rlSource, kCFRunLoopDefaultMode);</span><br><span class="line"> </span><br><span class="line">            &#x2F;&#x2F; Once installed, these can be freed.</span><br><span class="line">            CFRelease(myPort);</span><br><span class="line">            CFRelease(rlSource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Create the thread and continue processing.</span><br><span class="line">    MPTaskID        taskID;</span><br><span class="line">    return(MPCreateTask(&amp;ServerThreadEntryPoint,</span><br><span class="line">                    (void*)myPortName,</span><br><span class="line">                    kThreadStackSize,</span><br><span class="line">                    NULL,</span><br><span class="line">                    NULL,</span><br><span class="line">                    NULL,</span><br><span class="line">                    0,</span><br><span class="line">                    &amp;taskID));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>安装端口并启动线程后，主线程可以在等待线程 check in 时继续其常规执行。当 check-in 消息到达时，它将被分派到主线程的 <code>MainThreadResponseHandler </code>函数，如下面代码所示，此函数提取工作线程的端口名称，并为将来的通信创建管道。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-18  Receiving the checkin message</span><br><span class="line"></span><br><span class="line">#define kCheckinMessage 100</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Main thread port message handler</span><br><span class="line">CFDataRef MainThreadResponseHandler(CFMessagePortRef local,</span><br><span class="line">                    SInt32 msgid,</span><br><span class="line">                    CFDataRef data,</span><br><span class="line">                    void* info)</span><br><span class="line">&#123;</span><br><span class="line">    if (msgid &#x3D;&#x3D; kCheckinMessage)</span><br><span class="line">    &#123;</span><br><span class="line">        CFMessagePortRef messagePort;</span><br><span class="line">        CFStringRef threadPortName;</span><br><span class="line">        CFIndex bufferLength &#x3D; CFDataGetLength(data);</span><br><span class="line">        UInt8* buffer &#x3D; CFAllocatorAllocate(NULL, bufferLength, 0);</span><br><span class="line"> </span><br><span class="line">        CFDataGetBytes(data, CFRangeMake(0, bufferLength), buffer);</span><br><span class="line">        threadPortName &#x3D; CFStringCreateWithBytes (NULL, buffer, bufferLength, kCFStringEncodingASCII, FALSE);</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; You must obtain a remote message port by name.</span><br><span class="line">        messagePort &#x3D; CFMessagePortCreateRemote(NULL, (CFStringRef)threadPortName);</span><br><span class="line"> </span><br><span class="line">        if (messagePort)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; Retain and save the thread’s comm port for future reference.</span><br><span class="line">            AddPortToListOfActiveThreads(messagePort);</span><br><span class="line"> </span><br><span class="line">            &#x2F;&#x2F; Since the port is retained by the previous function, release</span><br><span class="line">            &#x2F;&#x2F; it here.</span><br><span class="line">            CFRelease(messagePort);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; Clean up.</span><br><span class="line">        CFRelease(threadPortName);</span><br><span class="line">        CFAllocatorDeallocate(NULL, buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; Process other messages.</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置主线程后，剩下的唯一事情就是新创建的工作线程创建自己的端口并 check in 。下面代码展示了工作线程的入口函数。 该函数提取主线程的端口名称，并使用它创建一个返回主线程的远程连接。 然后，该函数为自己创建一个本地端口，在该线程的 run loop 上安装该端口，并向包含本地端口名称的主线程发送一个 check-in 消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-19  Setting up the thread structures</span><br><span class="line"></span><br><span class="line">OSStatus ServerThreadEntryPoint(void* param)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Create the remote port to the main thread.</span><br><span class="line">    CFMessagePortRef mainThreadPort;</span><br><span class="line">    CFStringRef portName &#x3D; (CFStringRef)param;</span><br><span class="line"> </span><br><span class="line">    mainThreadPort &#x3D; CFMessagePortCreateRemote(NULL, portName);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Free the string that was passed in param.</span><br><span class="line">    CFRelease(portName);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Create a port for the worker thread.</span><br><span class="line">    CFStringRef myPortName &#x3D; CFStringCreateWithFormat(NULL, NULL, CFSTR(&quot;com.MyApp.Thread-%d&quot;), MPCurrentTaskID());</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Store the port in this thread’s context info for later reference.</span><br><span class="line">    CFMessagePortContext context &#x3D; &#123;0, mainThreadPort, NULL, NULL, NULL&#125;;</span><br><span class="line">    Boolean shouldFreeInfo;</span><br><span class="line">    Boolean shouldAbort &#x3D; TRUE;</span><br><span class="line"> </span><br><span class="line">    CFMessagePortRef myPort &#x3D; CFMessagePortCreateLocal(NULL,</span><br><span class="line">                myPortName,</span><br><span class="line">                &amp;ProcessClientRequest,</span><br><span class="line">                &amp;context,</span><br><span class="line">                &amp;shouldFreeInfo);</span><br><span class="line"> </span><br><span class="line">    if (shouldFreeInfo)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; Couldn&#39;t create a local port, so kill the thread.</span><br><span class="line">        MPExit(0);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    CFRunLoopSourceRef rlSource &#x3D; CFMessagePortCreateRunLoopSource(NULL, myPort, 0);</span><br><span class="line">    if (!rlSource)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; Couldn&#39;t create a local port, so kill the thread.</span><br><span class="line">        MPExit(0);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Add the source to the current run loop.</span><br><span class="line">    CFRunLoopAddSource(CFRunLoopGetCurrent(), rlSource, kCFRunLoopDefaultMode);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Once installed, these can be freed.</span><br><span class="line">    CFRelease(myPort);</span><br><span class="line">    CFRelease(rlSource);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Package up the port name and send the check-in message.</span><br><span class="line">    CFDataRef returnData &#x3D; nil;</span><br><span class="line">    CFDataRef outData;</span><br><span class="line">    CFIndex stringLength &#x3D; CFStringGetLength(myPortName);</span><br><span class="line">    UInt8* buffer &#x3D; CFAllocatorAllocate(NULL, stringLength, 0);</span><br><span class="line"> </span><br><span class="line">    CFStringGetBytes(myPortName,</span><br><span class="line">                CFRangeMake(0,stringLength),</span><br><span class="line">                kCFStringEncodingASCII,</span><br><span class="line">                0,</span><br><span class="line">                FALSE,</span><br><span class="line">                buffer,</span><br><span class="line">                stringLength,</span><br><span class="line">                NULL);</span><br><span class="line"> </span><br><span class="line">    outData &#x3D; CFDataCreate(NULL, buffer, stringLength);</span><br><span class="line"> </span><br><span class="line">    CFMessagePortSendRequest(mainThreadPort, kCheckinMessage, outData, 0.1, 0.0, NULL, NULL);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Clean up thread data structures.</span><br><span class="line">    CFRelease(outData);</span><br><span class="line">    CFAllocatorDeallocate(NULL, buffer);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Enter the run loop.</span><br><span class="line">    CFRunLoopRun();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦进入其 run loop，发送到该线程端口的所有未来事件都由 <code>ProcessClientRequest</code> 函数处理。 该函数的实现取决于线程的工作类型，这里没有显示。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/runloop/" rel="tag"># runloop</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/03/02/wwdc-2018-219/" rel="prev" title="Image and Graphics Best Practices">
      <i class="fa fa-chevron-left"></i> Image and Graphics Best Practices
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/01/21/compile-flutter-engine-using-Xcode/" rel="next" title="用 Xcode 编译 Flutter Engine 源码">
      用 Xcode 编译 Flutter Engine 源码 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%95%A5%E6%98%AF-Run-Loop"><span class="nav-number">1.</span> <span class="nav-text">啥是 Run Loop</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Input-Sources"><span class="nav-number">1.1.</span> <span class="nav-text">Input Sources</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Port-Based-Sources"><span class="nav-number">1.1.1.</span> <span class="nav-text">Port-Based Sources</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Custom-Input-Sources"><span class="nav-number">1.1.2.</span> <span class="nav-text">Custom Input Sources</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cocoa-Perform-Selector-Sources"><span class="nav-number">1.1.3.</span> <span class="nav-text">Cocoa Perform Selector Sources</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Timer-Sources"><span class="nav-number">1.2.</span> <span class="nav-text">Timer Sources</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Run-Loop-Observers"><span class="nav-number">1.3.</span> <span class="nav-text">Run Loop Observers</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Run-Loop-Sequence-of-Events"><span class="nav-number">1.4.</span> <span class="nav-text">The Run Loop Sequence of Events</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Run-Loop-Modes"><span class="nav-number">1.5.</span> <span class="nav-text">Run Loop Modes</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81-Run-Loop"><span class="nav-number">2.</span> <span class="nav-text">什么时候需要 Run Loop?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Run-Loop-%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.</span> <span class="nav-text">使用 Run Loop 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Getting-a-Run-Loop-Object"><span class="nav-number">3.1.</span> <span class="nav-text">Getting a Run Loop Object</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Configuring-the-Run-Loop"><span class="nav-number">3.2.</span> <span class="nav-text">Configuring the Run Loop</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Starting-the-Run-Loop"><span class="nav-number">3.3.</span> <span class="nav-text">Starting the Run Loop</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exiting-the-Run-Loop"><span class="nav-number">3.4.</span> <span class="nav-text">Exiting the Run Loop</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Thread-Safety-and-Run-Loop-Objects"><span class="nav-number">3.5.</span> <span class="nav-text">Thread Safety and Run Loop Objects</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Configuring-Run-Loop-Sources"><span class="nav-number">4.</span> <span class="nav-text">Configuring Run Loop Sources</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Defining-a-Custom-Input-Source"><span class="nav-number">4.1.</span> <span class="nav-text">Defining a Custom Input Source</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Defining-the-Input-Source"><span class="nav-number">4.1.1.</span> <span class="nav-text">Defining the Input Source</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Installing-the-Input-Source-on-the-Run-Loop"><span class="nav-number">4.1.2.</span> <span class="nav-text">Installing the Input Source on the Run Loop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Coordinating-with-Clients-of-the-Input-Source"><span class="nav-number">4.1.3.</span> <span class="nav-text">Coordinating with Clients of the Input Source</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Signaling-the-Input-Source"><span class="nav-number">4.1.4.</span> <span class="nav-text">Signaling the Input Source</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Configuring-Timer-Sources"><span class="nav-number">4.2.</span> <span class="nav-text">Configuring Timer Sources</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Configuring-a-Port-Based-Input-Source"><span class="nav-number">4.3.</span> <span class="nav-text">Configuring a Port-Based Input Source</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Configuring-an-NSMachPort-Object"><span class="nav-number">4.3.1.</span> <span class="nav-text">Configuring an NSMachPort Object</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Implementing-the-Main-Thread-Code"><span class="nav-number">4.3.1.1.</span> <span class="nav-text">Implementing the Main Thread Code</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Implementing-the-Secondary-Thread-Code"><span class="nav-number">4.3.1.2.</span> <span class="nav-text">Implementing the Secondary Thread Code</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Configuring-an-NSMessagePort-Object"><span class="nav-number">4.3.2.</span> <span class="nav-text">Configuring an NSMessagePort Object</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Configuring-a-Port-Based-Input-Source-in-Core-Foundation"><span class="nav-number">4.3.3.</span> <span class="nav-text">Configuring a Port-Based Input Source in Core Foundation</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">joakim.liu</p>
  <div class="site-description" itemprop="description">你不解决问题，就会成为问题。iOS菜逗一枚。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/JoakimLiu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;JoakimLiu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/JoakimLiu" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;JoakimLiu" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">joakim.liu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script>
  var disqus_config = function() {
    this.page.url = "http://example.com/2019/03/09/runloop-note/";
    this.page.identifier = "2019/03/09/runloop-note/";
    this.page.title = "Runloop 基础";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://http-joakimliu-github-io.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
