<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>牛易疯先森的开发记录</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-09-30T10:16:35.473Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>joakim.liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS 函数调用栈帧那些事</title>
    <link href="http://example.com/2022/09/30/stack/"/>
    <id>http://example.com/2022/09/30/stack/</id>
    <published>2022-09-30T00:26:20.000Z</published>
    <updated>2022-09-30T10:16:35.473Z</updated>
    
    <content type="html"><![CDATA[<p>《<a href="https://book.douban.com/subject/3652388/">程序员的自我修养–链接、装载与库</a>》 <code>10.2 栈与调用惯例</code> 里面讲到了堆栈帧这块的内容，联想到同事面试时说到捕获奔溃调用栈的问题，感觉挺有意思，于是记录一下。<br>本文主要讲解以下内容</p><ol><li>栈帧是什么东西？</li><li>Arm64 汇编基础，Arm64 栈帧</li><li>栈帧回溯怎么玩？怎么符号化？常见的三方库又是怎么玩的？</li></ol><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>《<a href="https://book.douban.com/subject/3652388/">程序员的自我修养–链接、装载与库</a>》是这么描述栈的：</p><blockquote><p>栈（stack）是现代计算机程序里最为重要的概念之一，几乎每一个程序都使用了栈，没有栈就没有函数，没有局部变量，也就没有我们如今能够看见的所有的计算机语言。<br>在经典的计算机科学中，栈被定义为一个特殊的容器，用户可以将数据压入栈中（入栈，push），也可以将已经压入栈中的数据弹出（出栈，pop），但栈这个容器必须遵守一条规则：先入栈的数据后出栈（First In Last Out, FIFO），多多少少像叠成一叠的书：先叠上去的书在最下面，因此要最后才能取出。<br>在计算机系统中，栈则是一个具有以上属性的动态内存区域。程序可以将数据压入栈中，也可以将数据从栈顶弹出。压栈操作使得栈增大，而弹出操作使栈减小。</p></blockquote><h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><p>栈保存了函数调用所需的信息，而这些信息称为堆栈帧（Stack Frame）或活动记录（Activate Record），包括以下内容：</p><ul><li>函数的返回地址和参数</li><li>临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量</li><li>保存的上下文：包括在函数调用前后需要保持不变的寄存器</li></ul><p><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/stack/20220930091349.png" alt="栈帧"></p><p>上图是 i386 中一个函数的栈帧，根据 ebp(Frame Pointer, 帧寄存器) 和 esp(Stack Pointer, 栈寄存器) 这两寄存器可以划分一个函数的堆栈。</p><ol><li>ebp 是固定的，始终指向栈底（高地址）</li><li>esp 始终指向栈顶（低地址），它是动态变化的</li><li>可以通过 ebp esp 和获取栈帧中的数据，比如，ebp+4 获取函数的返回地址</li></ol><h2 id="调用惯例"><a href="#调用惯例" class="headerlink" title="调用惯例"></a>调用惯例</h2><p>调用惯例：函数的调用方和被调用方对于函数如何调用须要有一个明确的约定。就像两个人沟通一样的，只有使用相同的语言（普通话）才能进行友好的沟通。<br>而调用惯例包括以下几方面的内容：</p><ol><li>函数参数的传递顺序和方式<ol><li>函数参数的传递有很多种方式，最常见的一种是通过栈传递。函数的调用方将参数压入栈中，函数自己再从栈中将参数取出。对于有多个参数的函数，调用惯例要规定函数调用方将参数压栈的顺序：是从左至右，还是从右至左。有些调用惯例还允许使用寄存器传递参数，以提高性能。</li></ol></li><li>栈的维护方式<ol><li>在函数将参数压栈之后，函数体会被调用，此后需要将被压入栈中的参数全部弹出，以使得栈在函数调用前后保持一致。这个弹出的工作可以由函数的调用方来完成，也可以由函数本身来完成。 // 如果不进行栈回退 pop 操作的话，函数调用会讲程序的栈空间用完，从而出现 stackoverflow 的错误</li></ol></li><li>名字修饰（Name-mangling）的策略<ol><li>为了链接的时候对调用惯例进行区分，调用管理要对函数本身的名字进行修饰。不同的调用惯例有不同的名字修饰策略。</li></ol></li></ol><h1 id="Arm64"><a href="#Arm64" class="headerlink" title="Arm64"></a>Arm64</h1><p>有了上面书本基础知识的加持，现在到 Arm64 架构下实践一波吧。</p><h2 id="汇编基础"><a href="#汇编基础" class="headerlink" title="汇编基础"></a>汇编基础</h2><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p><a href="https://zh.wikipedia.org/wiki/%E5%AF%84%E5%AD%98%E5%99%A8">寄存器</a>（Register）是中央处理器内用来暂存指令、数据和地址的电脑存储器。 它就是 CPU 内部用来存储数据的存储器件，容量小、访问速度快。<br><br/></p><p>而 Arm64 有 31 个通用寄存器，相关用途如下。 </p><blockquote><p>The 64-bit ARM (AArch64) calling convention allocates the 31 general-purpose registers as:<br>x31 (SP): Stack pointer or a zero register, depending on context.<br>x30 (LR): Procedure link register, used to return from subroutines.<br>x29 (FP): Frame pointer.<br>x19 to x29: Callee-saved.<br>x18 (PR): Platform register. Used for some operating-system-specific special purpose, or an additional caller-saved register.<br>x16 (IP0) and x17 (IP1): Intra-Procedure-call scratch registers.<br>x9 to x15: Local variables, caller saved.<br>x8 (XR): Indirect return value address.<br>x0 to x7: Argument values passed to and results returned from a subroutine.</p></blockquote><p>摘自 <a href="https://en.wikipedia.org/wiki/Calling_convention#ARM_(A64)">Calling_convention#ARM_(A64)</a>。</p><br/><p>总结下常用的:</p><ol><li>x0-x7: 用来存放函数调用的参数和函数返回值(x0)，更多参数可以使用堆栈来存放</li><li>x29 (FP): 上图 i386 中的 ebp, 它里面存储的是上一个函数（该函数的调用方 caller） ebp 的地址</li><li>x30 (LR): 存储函数的返回地址</li><li>SP: 上图 i386 中的 esp, 指向栈顶<ol><li>现在执行 lldb 命令<code>register read x31</code> 会报错：<code>error: Invalid register name &#39;x31&#39;.</code></li></ol></li><li>PC: 记录 CPU 当前执行的是哪条指令</li></ol><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>一些常见的指令，内容摘自 <a href="https://blackteachinese.github.io/2017/07/12/arm64/">10分钟入门arm64汇编</a>，具体的可以参加 ARM 操作手册。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">add x0,x0,#1            ;x0 &lt;&#x3D;&#x3D;x0+1 ,把x0的内容加1。</span><br><span class="line">add x0,x0,#0x30         ;x0 &lt;&#x3D;&#x3D;x0+0x30,把x0的内容加 0x30。</span><br><span class="line">add x0,x1,x3            ;x0 &lt;&#x3D;&#x3D;x1+x3, 把x1的内容加上x3的内容放入x0</span><br><span class="line">add x0,x1,x3,lsl #3     ;x0 &lt;&#x3D;&#x3D;x0+x3*8 ,x3的值左移3位就是乘以8，结果与x1的值相, 放入x0.</span><br><span class="line">add x0,x1,[x2]          ;x0 &lt;&#x3D;&#x3D;x1+[x2], 把x1的内容加上x2的内容作为地址取内存内容放入x0</span><br><span class="line">ldr x0,[x1]             ;x0 &lt;&#x3D;&#x3D;[x1], 把x1的内容作为地址取内存内容放入x0</span><br><span class="line">str x0,[x1]             ;[x1] &lt;&#x3D;&#x3D; x0, 把x0的内容放入x1的内容作为地址的内存中</span><br><span class="line">ldr x0,[x1,#4]          ;x0 &lt;&#x3D;&#x3D;[x1+4], 把x1的内容加上4, 作为内存地址, 取其内容放入x0</span><br><span class="line">ldr x0,[x1,#4]!         ;x0 &lt;&#x3D;&#x3D;[x1+4]、 x1&lt;&#x3D;&#x3D;x1+4, 把x1的内容加上4, 作为内存地址, 取其内容放入x0, 然后把x1的内容加上4放入x1</span><br><span class="line">ldr x0,[x1],#4          ;x0 &lt;&#x3D;&#x3D;[x1] 、x1 &lt;&#x3D;&#x3D;x1+4, 把x1的内容作为内存地址取内存内容放入x0, 并把x1的内容加上4放入x1</span><br><span class="line">ldr x0,[x1,x2]          ;x0 &lt;&#x3D;&#x3D;[x1+x2], 把x1和x2的内容相加, 作为内存地址取内存内容放入x0</span><br></pre></td></tr></table></figure><h2 id="栈帧-1"><a href="#栈帧-1" class="headerlink" title="栈帧"></a>栈帧</h2><p><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/stack/aapcs64-variadic-stack.png" alt="aapcs64-variadic-stack"><br>跟《<a href="https://book.douban.com/subject/3652388/">程序员的自我修养–链接、装载与库</a>》里面的栈帧差不多，图片来自 <a href="https://github.com/ARM-software/abi-aa/blob/60a8eb8c55e999d74dac5e368fc9d7e36e38dda4/aapcs64/aapcs64.rst#the-stack">Procedure Call Standard for the Arm® 64-bit Architecture (AArch64)</a>。</p><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>用一个 Demo 将上面的内容串联起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (int)test1:(int)a &#123;</span><br><span class="line">    int res &#x3D; [self test2:a b:2];</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (int)test2:(int)a b:(int)b &#123;</span><br><span class="line">    int res &#x3D; a + b;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    int res &#x3D; [self test1:1];</span><br><span class="line">    NSLog(@&quot;res: %d&quot;, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数调用方 <code>test1</code> 和被调方 <code>test2</code> 的第一行代码处下断点，并用汇编查看。</p><h3 id="caller-test1"><a href="#caller-test1" class="headerlink" title="caller - test1"></a>caller - test1</h3><p><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/stack/20220930104416.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Demo_fishhook&#96;-[ViewController test1:]:</span><br><span class="line">    0x102067294 &lt;+0&gt;:  sub    sp, sp, #0x30     ; sp &#x3D; sp - 0x30(48), 开辟栈空间</span><br><span class="line">    0x102067298 &lt;+4&gt;:  stp    x29, x30, [sp, #0x20] ; 将 x29(fp) 里面的内容存入 sp+0x20(32)的位置，占 8B(x29 共 64bit, 8B) 长度；将 x30(lr) 的内容存入 sp+0x20+8&#x3D;sp+40 的位置，占 8B</span><br><span class="line">    0x10206729c &lt;+8&gt;:  add    x29, sp, #0x20 ; x29 &#x3D; sp + 0x20</span><br><span class="line">    0x1020672a0 &lt;+12&gt;: stur   x0, [x29, #-0x8] ; 将 x0 的内容，x29-0x8 的位置</span><br><span class="line">    0x1020672a4 &lt;+16&gt;: str    x1, [sp, #0x10] ; 将 x1 的内容放入 sp+0x10 的位置</span><br><span class="line">    0x1020672a8 &lt;+20&gt;: str    w2, [sp, #0xc] ; w2 是 x2 的低32位，占 4B</span><br><span class="line">-&gt;  0x1020672ac &lt;+24&gt;: ldur   x0, [x29, #-0x8] ; 数据读取，就是将上面的数据再读出来</span><br><span class="line">    0x1020672b0 &lt;+28&gt;: ldr    w2, [sp, #0xc] ; 数据读取</span><br><span class="line">    0x1020672b4 &lt;+32&gt;: adrp   x8, 87</span><br><span class="line">    0x1020672b8 &lt;+36&gt;: ldr    x1, [x8, #0xb80] ; 数据读取放入 x1 寄存器中</span><br><span class="line">    0x1020672bc &lt;+40&gt;: mov    w3, #0x2 ; x3 的低32位存的值是 0x2</span><br><span class="line">    0x1020672c0 &lt;+44&gt;: bl     0x102d2f0e4               ; symbol stub for: objc_msgSend ; 函数跳转</span><br><span class="line">    0x1020672c4 &lt;+48&gt;: str    w0, [sp, #0x8] ; 存储 test2 的结果</span><br><span class="line">    0x1020672c8 &lt;+52&gt;: ldr    w0, [sp, #0x8] ; 读取 w0 </span><br><span class="line">    0x1020672cc &lt;+56&gt;: ldp    x29, x30, [sp, #0x20] ; 将 [sp, #0x20] 的内容放入 x29 x30 寄存器</span><br><span class="line">    0x1020672d0 &lt;+60&gt;: add    sp, sp, #0x30 ; sp &#x3D; sp + 0x30</span><br><span class="line">    0x1020672d4 &lt;+64&gt;: ret    </span><br></pre></td></tr></table></figure><br/><p>这里大概做了下面几件事</p><ol><li>开辟栈空间，存储 x29 x30 的值到栈，因为后面会修改 x29 x30 的值</li><li>给 x29 赋值，即固定当前函数 x29 的位置</li><li>存储和读取 x0 x1 w2<code>test2:b:</code> 函数入参的值</li><li>给 x3 赋值为 2, 相当于 <code>test2:b:</code> 函数入参 b 的值</li><li><code>bl</code> 调用 <code>test2:b:</code> 函数</li><li>从栈中取出 x29 x30 的值，回退栈空间</li><li>ret: 函数返回到 x30 所指向的地址</li></ol><br/><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">(lldb) register read</span><br><span class="line">General Purpose Registers:</span><br><span class="line">        x0 &#x3D; 0x0000000102709160</span><br><span class="line">        x1 &#x3D; 0x00000001020ab733  &quot;test1:&quot;</span><br><span class="line">        x2 &#x3D; 0x0000000000000001</span><br><span class="line">        x3 &#x3D; 0x000000016dd9dbf0</span><br><span class="line">        x4 &#x3D; 0x0000000000000010</span><br><span class="line">        x5 &#x3D; 0x0000000000000020</span><br><span class="line">        x6 &#x3D; 0x000000016dd9d8f0</span><br><span class="line">        x7 &#x3D; 0x0000000000000000</span><br><span class="line">        x8 &#x3D; 0x00000001020be000  (void *)0x00000001020ab182: initWithCodeType:baseAddress:size:name:uuid:.hex + 7651</span><br><span class="line">        x9 &#x3D; 0x0000000000000000</span><br><span class="line">       x10 &#x3D; 0x000000000000005d</span><br><span class="line">       x11 &#x3D; 0x00000001030221d8</span><br><span class="line">       x12 &#x3D; 0x000000000000005d</span><br><span class="line">       x13 &#x3D; 0x0000000000000000</span><br><span class="line">       x14 &#x3D; 0x0000000180964000</span><br><span class="line">       x15 &#x3D; 0x000000020b12c000</span><br><span class="line">       x16 &#x3D; 0x00000001020bf9b2  (void *)0xe12800000001020b</span><br><span class="line">       x17 &#x3D; 0x0000000102067294  Demo_fishhook&#96;-[ViewController test1:] at ViewController.m:144</span><br><span class="line">       x18 &#x3D; 0x0000000000000000</span><br><span class="line">       x19 &#x3D; 0x0000000102709160</span><br><span class="line">       x20 &#x3D; 0x0000000000000000</span><br><span class="line">       x21 &#x3D; 0x00000001f59e3000  UIKitCore&#96;_UIInternalPreference_IdleSchedulerTargetDeadlineFraction</span><br><span class="line">       x22 &#x3D; 0x000000019b10ec13  </span><br><span class="line">       x23 &#x3D; 0x000000019b7043f5  </span><br><span class="line">       x24 &#x3D; 0x0000000000000000</span><br><span class="line">       x25 &#x3D; 0x00000001f630c000  UIKitCore&#96;_UIPreviewPresentationAnimator._startMediaTime</span><br><span class="line">       x26 &#x3D; 0x00000001027083f0</span><br><span class="line">       x27 &#x3D; 0x000000019bb48a24  </span><br><span class="line">       x28 &#x3D; 0x00000001fab5f4e8  CoreFoundation&#96;__NSArray0__struct</span><br><span class="line">        fp &#x3D; 0x000000016dd9da20</span><br><span class="line">        lr &#x3D; 0x000000010206718c  Demo_fishhook&#96;-[ViewController viewDidLoad] + 76 at ViewController.m:84:9</span><br><span class="line">        sp &#x3D; 0x000000016dd9da00</span><br><span class="line">        pc &#x3D; 0x00000001020672ac  Demo_fishhook&#96;-[ViewController test1:] + 24 at ViewController.m:145:16</span><br><span class="line">      cpsr &#x3D; 0x40000000</span><br></pre></td></tr></table></figure><p>现在来 debug 看下相关寄存器里面的值，分别看.</p><ul><li>x0-x7, 存放参数和返回值<ul><li>x0 和 x1 存储的是 OC 方法的前两个隐藏入参: self 和 _cmd.  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po 0x0000000102709160</span><br><span class="line">&lt;ViewController: 0x102709160&gt;</span><br><span class="line"></span><br><span class="line">(lldb) po (char *)0x00000001020ab733</span><br><span class="line">&quot;test2:b:&quot; </span><br></pre></td></tr></table></figure></li><li> <code>x2 = 0x0000000000000001</code> 存储的值是 1, 主上面的汇编代码使用的 w2, 即 x2 低 32 位(即 000000001), 就是值 1 </li><li> 断点指向到 0x1020672c0 处后，<code>x3 = 0x0000000000000002</code>，同 x2, 值 2</li></ul></li><li>pc, 当前断点指向的地址</li></ul><br/><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p&#x2F;x 0x000000016f351a20 - 0x000000016f351a00</span><br><span class="line">(long) $13 &#x3D; 0x0000000000000020</span><br></pre></td></tr></table></figure><p>fp-sp=0x20, 因为上面开始开辟栈空间 0x30, 但存储 x29 和 x30 用了 0x10, 所以还剩 0x20 大小的空间可用。</p><h3 id="callee-test2"><a href="#callee-test2" class="headerlink" title="callee - test2"></a>callee - test2</h3><p><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/stack/20220930105031.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Demo_fishhook&#96;-[ViewController test2:b:]:</span><br><span class="line">    0x1020672d8 &lt;+0&gt;:  sub    sp, sp, #0x20</span><br><span class="line">    0x1020672dc &lt;+4&gt;:  str    x0, [sp, #0x18]</span><br><span class="line">    0x1020672e0 &lt;+8&gt;:  str    x1, [sp, #0x10]</span><br><span class="line">    0x1020672e4 &lt;+12&gt;: str    w2, [sp, #0xc]</span><br><span class="line">    0x1020672e8 &lt;+16&gt;: str    w3, [sp, #0x8]</span><br><span class="line">-&gt;  0x1020672ec &lt;+20&gt;: ldr    w8, [sp, #0xc]</span><br><span class="line">    0x1020672f0 &lt;+24&gt;: ldr    w9, [sp, #0x8]</span><br><span class="line">    0x1020672f4 &lt;+28&gt;: add    w8, w8, w9</span><br><span class="line">    0x1020672f8 &lt;+32&gt;: str    w8, [sp, #0x4]</span><br><span class="line">    0x1020672fc &lt;+36&gt;: ldr    w0, [sp, #0x4]</span><br><span class="line">    0x102067300 &lt;+40&gt;: add    sp, sp, #0x20</span><br><span class="line">    0x102067304 &lt;+44&gt;: ret    </span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">(lldb) register read</span><br><span class="line">General Purpose Registers:</span><br><span class="line">        x0 &#x3D; 0x0000000102709160</span><br><span class="line">        x1 &#x3D; 0x00000001020ab740  &quot;test2:b:&quot;</span><br><span class="line">        x2 &#x3D; 0x0000000000000001</span><br><span class="line">        x3 &#x3D; 0x0000000000000002</span><br><span class="line">        x4 &#x3D; 0x0000000000000010</span><br><span class="line">        x5 &#x3D; 0x0000000000000020</span><br><span class="line">        x6 &#x3D; 0x000000016dd9d8f0</span><br><span class="line">        x7 &#x3D; 0x0000000000000000</span><br><span class="line">        x8 &#x3D; 0x00000001020be000  (void *)0x00000001020ab182: initWithCodeType:baseAddress:size:name:uuid:.hex + 7651</span><br><span class="line">        x9 &#x3D; 0x0000000000000000</span><br><span class="line">       x10 &#x3D; 0x000000000000002e</span><br><span class="line">       x11 &#x3D; 0x0000000103021ee8</span><br><span class="line">       x12 &#x3D; 0x000000000000002e</span><br><span class="line">       x13 &#x3D; 0x0000000000000000</span><br><span class="line">       x14 &#x3D; 0x0000000180964000</span><br><span class="line">       x15 &#x3D; 0x000000020b12c000</span><br><span class="line">       x16 &#x3D; 0x00000001020bf9b2  (void *)0xe12800000001020b</span><br><span class="line">       x17 &#x3D; 0x00000001020672d8  Demo_fishhook&#96;-[ViewController test2:b:] at ViewController.m:149</span><br><span class="line">       x18 &#x3D; 0x0000000000000000</span><br><span class="line">       x19 &#x3D; 0x0000000102709160</span><br><span class="line">       x20 &#x3D; 0x0000000000000000</span><br><span class="line">       x21 &#x3D; 0x00000001f59e3000  UIKitCore&#96;_UIInternalPreference_IdleSchedulerTargetDeadlineFraction</span><br><span class="line">       x22 &#x3D; 0x000000019b10ec13  </span><br><span class="line">       x23 &#x3D; 0x000000019b7043f5  </span><br><span class="line">       x24 &#x3D; 0x0000000000000000</span><br><span class="line">       x25 &#x3D; 0x00000001f630c000  UIKitCore&#96;_UIPreviewPresentationAnimator._startMediaTime</span><br><span class="line">       x26 &#x3D; 0x00000001027083f0</span><br><span class="line">       x27 &#x3D; 0x000000019bb48a24  </span><br><span class="line">       x28 &#x3D; 0x00000001fab5f4e8  CoreFoundation&#96;__NSArray0__struct</span><br><span class="line">        fp &#x3D; 0x000000016dd9da20</span><br><span class="line">        lr &#x3D; 0x00000001020672c4  Demo_fishhook&#96;-[ViewController test1:] + 48 at ViewController.m:145:9</span><br><span class="line">        sp &#x3D; 0x000000016dd9d9e0</span><br><span class="line">        pc &#x3D; 0x00000001020672ec  Demo_fishhook&#96;-[ViewController test2:b:] + 20 at ViewController.m:151:15</span><br><span class="line">      cpsr &#x3D; 0x40000000</span><br><span class="line"></span><br><span class="line">(lldb)  </span><br></pre></td></tr></table></figure><br/><p>继续来看寄存器的值</p><ul><li>x0-x7, 存放参数和返回值<ul><li>x0 x1 跟 test1 一样，它们两个的 x0 值都是 0x0000000102709160</li><li>x2 = 0x0000000000000001, 入参 a 的值为 1</li><li>x3 = 0x0000000000000002, 入参 b 的值为 2</li><li>返回值，当断点在 <code>0x102067304</code> 的时候，变化的寄存器值如下，x0 就是返回值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x0 &#x3D; 0x0000000100f0ac70</span><br><span class="line">x8 &#x3D; 0x0000000100a26000  (void *)0x0000000100a13182: initWithCodeType:baseAddress:size:name:uuid:.hex + 7651</span><br><span class="line">x9 &#x3D; 0x0000000000000000</span><br><span class="line">sp &#x3D; 0x000000016f4359e0</span><br><span class="line">pc &#x3D; 0x00000001009cf2ec  Demo_fishhook&#96;-[ViewController test2:b:] + 20 at ViewController.m:151:15</span><br></pre></td></tr></table></figure>sp 和 pc 变化是可以理解的，因为回退栈空间了；但 x8 和 x9 也发生变化就不知道原因了</li></ul></li><li>fp = 0x000000016dd9da20, 跟 test1 的 fp 值相同</li><li>lr = 0x00000001020672c4, 就是 test1 处的 0x1020672c4(即函数跳转处的下一条指令)</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>lr 寄存器存储的是函数返回值，根据 lr 可以回溯到上个函数</li><li>test2 没有存储 x29 x30 到栈中, 而 test1 则有存储；因为 test2 是<code>叶子函数</code>，它里面没有调用其他函数。函数调用会用到 bl, 而 bl 则会把下一条指令的地址存入 x30 寄存器，会改变 x30 的值，所以出于保护现场的目的需要提前保存 x30 的值。而这里没有函数调用，意味着不会改变 x30, 所以就没有存储 x30 的意义了。</li><li>关于 fp 也是一个有趣的点，分别在 viewDidLoad 和 test1 处下断点，见下图<br><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/stack/20220930115939.png"></li></ol><ul><li>viewDidLoad.fp = 0x000000016f705a60</li><li>test1.fp = 0x000000016f705a20</li><li>由于 fp 是指针，那就看它所指向地址存储的数据（x 0x000000016f705a20）：<code>0x16f705a20: 60 5a 70 6f 01 00 00 00</code>, 因为是小端，所有读取出来就是 <code>0x016f705a60</code>(viewDidLoad.fp)，从而验证了该函数的 fp 指向上个函数的 fp</li><li><code>0x16f705a8: 8c f1 6f 00 01 00 00 00</code> 就是 <code>0x01006ff18c</code> (test1.lr)，因为在 x29 x30 在 test1 里面就是连续存储的，见 <code>stp    x29, x30, [sp, #0x20]</code></li></ul><h1 id="获取函数调用栈"><a href="#获取函数调用栈" class="headerlink" title="获取函数调用栈"></a>获取函数调用栈</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>根据前面的 <code>Arm64/Demo/总结</code> 可知，如果要获取函数调用栈的话，首先要找到当前函数的 pc 和 lr 指针。</p><ol><li>获取当前函数的 pc, 得到当前函数的地址</li><li>根据 lr 得到上个函数的地址</li><li>循环进行 2 步，直到 lr 为空</li><li>拿到相关地址后符号化</li></ol><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>从易后难，先看符号化的逻辑。</p><h3 id="符号化"><a href="#符号化" class="headerlink" title="符号化"></a>符号化</h3><p>看上面的 <code>Arm64/Demo</code>, 如果在 test2 获取的话，相关寄存器的值如下</p><ol><li>pc: 0x00000001020672ec</li><li>lr: 0x00000001020672c4</li></ol><p>而 test2 和 test1 的函数地址分别是</p><ol><li>0x1020672d8</li><li>0x102067294</li></ol><p>也就是说获取的地址值是大于实际地址值的，那这要怎么处理呢？带着这个问题，看下经典库 <a href="https://github.com/kstenerud/KSCrash/blob/498aa21d23541b0bb4990f8d3d20bea2c280a18b/Source/KSCrash/Recording/Tools/KSDynamicLinker.c#L232">KSCrash</a> 是怎么处理的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">bool ksdl_dladdr(const uintptr_t address, Dl_info* const info)</span><br><span class="line">&#123;</span><br><span class="line">    info-&gt;dli_fname &#x3D; NULL;</span><br><span class="line">    info-&gt;dli_fbase &#x3D; NULL;</span><br><span class="line">    info-&gt;dli_sname &#x3D; NULL;</span><br><span class="line">    info-&gt;dli_saddr &#x3D; NULL;</span><br><span class="line">&#x2F;&#x2F; 在哪个 image</span><br><span class="line">    const uint32_t idx &#x3D; imageIndexContainingAddress(address);</span><br><span class="line">    if(idx &#x3D;&#x3D; UINT_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    const struct mach_header* header &#x3D; _dyld_get_image_header(idx);</span><br><span class="line">    &#x2F;&#x2F; ALSR 值</span><br><span class="line">    const uintptr_t imageVMAddrSlide &#x3D; (uintptr_t)_dyld_get_image_vmaddr_slide(idx);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 就是没有 ALSR 的 VMaddress</span><br><span class="line">    const uintptr_t addressWithSlide &#x3D; address - imageVMAddrSlide;</span><br><span class="line">    &#x2F;&#x2F; 虚拟基地址+ALSR值, 就是包含 ALSR 的虚拟内存地址, 其实就是 header, 验证结果见下面 segmentBase fishhook</span><br><span class="line">    const uintptr_t segmentBase &#x3D; segmentBaseOfImageIndex(idx) + imageVMAddrSlide;</span><br><span class="line">    if(segmentBase &#x3D;&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    info-&gt;dli_fname &#x3D; _dyld_get_image_name(idx);</span><br><span class="line">    info-&gt;dli_fbase &#x3D; (void*)header;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Find symbol tables and get whichever symbol is closest to the address.</span><br><span class="line">    const nlist_t* bestMatch &#x3D; NULL;</span><br><span class="line">    uintptr_t bestDistance &#x3D; ULONG_MAX;</span><br><span class="line">    uintptr_t cmdPtr &#x3D; firstCmdAfterHeader(header);</span><br><span class="line">    if(cmdPtr &#x3D;&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    for(uint32_t iCmd &#x3D; 0; iCmd &lt; header-&gt;ncmds; iCmd++)</span><br><span class="line">    &#123;</span><br><span class="line">        const struct load_command* loadCmd &#x3D; (struct load_command*)cmdPtr;</span><br><span class="line">        &#x2F;&#x2F; 符号表查询</span><br><span class="line">        if(loadCmd-&gt;cmd &#x3D;&#x3D; LC_SYMTAB)</span><br><span class="line">        &#123;</span><br><span class="line">            const struct symtab_command* symtabCmd &#x3D; (struct symtab_command*)cmdPtr;</span><br><span class="line">            const nlist_t* symbolTable &#x3D; (nlist_t*)(segmentBase + symtabCmd-&gt;symoff);</span><br><span class="line">            const uintptr_t stringTable &#x3D; segmentBase + symtabCmd-&gt;stroff;</span><br><span class="line"></span><br><span class="line">            for(uint32_t iSym &#x3D; 0; iSym &lt; symtabCmd-&gt;nsyms; iSym++)</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F; If n_value is 0, the symbol refers to an external object.</span><br><span class="line">                if(symbolTable[iSym].n_value !&#x3D; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    &#x2F;&#x2F; 符号表的值，是不包含 ASLR 值的，所以上面 addressWithSlide 是要减去 ASLR</span><br><span class="line">                    uintptr_t symbolBase &#x3D; symbolTable[iSym].n_value;</span><br><span class="line">                    &#x2F;&#x2F; 两种相减，找距离最近的</span><br><span class="line">                    uintptr_t currentDistance &#x3D; addressWithSlide - symbolBase;</span><br><span class="line">                    &#x2F;*</span><br><span class="line">                &#96;(addressWithSlide &gt;&#x3D; symbolBase)&#96; : 因为 symbolBase 是具体符号值；而 addressWithSlide 则是需要查找的地址值, 二者可能想到，所以是 &gt;&#x3D; symbolBase</span><br><span class="line">                (currentDistance &lt;&#x3D; bestDistance) : 寻找最匹配的，距离越近越好</span><br><span class="line">                *&#x2F;</span><br><span class="line">                    if((addressWithSlide &gt;&#x3D; symbolBase) &amp;&amp;</span><br><span class="line">                       (currentDistance &lt;&#x3D; bestDistance))</span><br><span class="line">                    &#123;</span><br><span class="line">                        &#x2F;&#x2F; iSym 符号表的下标，跟 fishhook 里面的字符串计算是一样的道理</span><br><span class="line">                        bestMatch &#x3D; symbolTable + iSym;</span><br><span class="line">                        bestDistance &#x3D; currentDistance;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(bestMatch !&#x3D; NULL)</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F; + imageVMAddrSlide(ASLR值)，因为前面 addressWithSlide 有减去 imageVMAddrSlide ASLR 值</span><br><span class="line">                info-&gt;dli_saddr &#x3D; (void*)(bestMatch-&gt;n_value + imageVMAddrSlide);</span><br><span class="line">                if(bestMatch-&gt;n_desc &#x3D;&#x3D; 16)</span><br><span class="line">                &#123;</span><br><span class="line">                    &#x2F;&#x2F; This image has been stripped. The name is meaningless, and</span><br><span class="line">                    &#x2F;&#x2F; almost certainly resolves to &quot;_mh_execute_header&quot;</span><br><span class="line">                    info-&gt;dli_sname &#x3D; NULL;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    &#x2F;&#x2F; 过掉符号修饰的前面的 &#96;_&#96;。</span><br><span class="line">                    info-&gt;dli_sname &#x3D; (char*)((intptr_t)stringTable + (intptr_t)bestMatch-&gt;n_un.n_strx);</span><br><span class="line">                    if(*info-&gt;dli_sname &#x3D;&#x3D;addressWithSlide - &#39;_&#39;)</span><br><span class="line">                    &#123;</span><br><span class="line">                        info-&gt;dli_sname++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 继续匹配下一个符号</span><br><span class="line">        cmdPtr +&#x3D; loadCmd-&gt;cmdsize;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可知，跟 fishhook 查找符号表原理是类似的，就是用 lr 的地址值到符号表里一一匹配，找到比 lr 地址值小并离 lr 地址值最近的那个符号就是该函数的符号。</p><h3 id="获取线程信息"><a href="#获取线程信息" class="headerlink" title="获取线程信息"></a>获取线程信息</h3><p>因为 KSCrash 这块的代码比较多，现在还没捋顺，于是就找到了《<a href="https://time.geekbang.org/column/intro/100024501?tab=catalog">iOS 开发高手课</a>》作者的 <a href="https://github.com/ming1016/DecoupleDemo/blob/master/DecoupleDemo/SMCallStack.m#L103">SMCallStack.m</a></p><br/><p>大致逻辑(只针对 Arm64 架构)如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">typedef struct SMStackFrame &#123;</span><br><span class="line">    const struct SMStackFrame *const previous;</span><br><span class="line">    const uintptr_t return_address;</span><br><span class="line">&#125; SMStackFrame;</span><br><span class="line"></span><br><span class="line">NSString *smStackOfThread(thread_t thread) &#123;</span><br><span class="line">    uintptr_t buffer[100];</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    _STRUCT_MCONTEXT64 machineContext;</span><br><span class="line">    mach_msg_type_number_t state_count &#x3D; ARM_THREAD_STATE64_COUNT;</span><br><span class="line">    kern_return_t kr &#x3D; thread_get_state(thread, ARM_THREAD_STATE64, (thread_state_t)&amp;machineContext.__ss, &amp;state_count);</span><br><span class="line">    if (kr !&#x3D; KERN_SUCCESS) &#123;</span><br><span class="line">        return [NSString stringWithFormat:@&quot;Fail get thread: %u&quot;, thread];</span><br><span class="line">    &#125;</span><br><span class="line">    const uintptr_t instructionAddress &#x3D; machineContext.__ss.__pc;</span><br><span class="line">    buffer[i++] &#x3D; instructionAddress;</span><br><span class="line">    uintptr_t linkRegisterPointer &#x3D; machineContext.__ss.__lr;</span><br><span class="line">    if (linkRegisterPointer) &#123;</span><br><span class="line">        buffer[i++] &#x3D; linkRegisterPointer;</span><br><span class="line">    &#125;</span><br><span class="line">    SMStackFrame stackFrame &#x3D; &#123;0&#125;;</span><br><span class="line">    const uintptr_t framePointer &#x3D; machineContext.__ss.__fp;</span><br><span class="line">    </span><br><span class="line">    vm_size_t bytesCopied &#x3D; 0;</span><br><span class="line">    if (framePointer &#x3D;&#x3D; 0 || vm_read_overwrite(mach_task_self(), (vm_address_t)(void *)framePointer, (vm_size_t)sizeof(stackFrame), (vm_address_t)&amp;stackFrame, &amp;bytesCopied) !&#x3D; KERN_SUCCESS) &#123;</span><br><span class="line">        return @&quot;Fail frame pointer&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bytesCopied &#x3D; 0;</span><br><span class="line">    </span><br><span class="line">    for (; ; i++) &#123;</span><br><span class="line">        buffer[i] &#x3D; stackFrame.return_address;</span><br><span class="line">        if (buffer[i] &#x3D;&#x3D; 0 || stackFrame.previous &#x3D;&#x3D; 0 || vm_read_overwrite(mach_task_self(), (vm_address_t)(void *)stackFrame.previous, (vm_size_t)sizeof(stackFrame), (vm_address_t)&amp;stackFrame, &amp;bytesCopied) !&#x3D; KERN_SUCCESS) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; xxxxx</span><br><span class="line">    return @&quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码大致逻辑能看懂：根据系统函数获取 pc fp lr, 再循环获取 lr 加入数组。<br>但不知道为什么要这样写，只能找到根据大佬的代码去搜索相关资料，基本都是操作系统领域的相关知识。</p><h4 id="STRUCT-MCONTEXT64"><a href="#STRUCT-MCONTEXT64" class="headerlink" title="_STRUCT_MCONTEXT64"></a>_STRUCT_MCONTEXT64</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#define _STRUCT_MCONTEXT64      struct __darwin_mcontext64</span><br><span class="line">_STRUCT_MCONTEXT64</span><br><span class="line">&#123;</span><br><span class="line">_STRUCT_ARM_EXCEPTION_STATE64   __es;</span><br><span class="line">_STRUCT_ARM_THREAD_STATE64      __ss;</span><br><span class="line">_STRUCT_ARM_NEON_STATE64        __ns;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">_STRUCT_ARM_THREAD_STATE64</span><br><span class="line">&#123;</span><br><span class="line">__uint64_t __x[29]; &#x2F;* General purpose registers x0-x28 *&#x2F;</span><br><span class="line">__uint64_t __fp;    &#x2F;* Frame pointer x29 *&#x2F;</span><br><span class="line">__uint64_t __lr;    &#x2F;* Link register x30 *&#x2F;</span><br><span class="line">__uint64_t __sp;    &#x2F;* Stack pointer x31 *&#x2F;</span><br><span class="line">__uint64_t __pc;    &#x2F;* Program counter *&#x2F;</span><br><span class="line">__uint32_t __cpsr;  &#x2F;* Current program status register *&#x2F;</span><br><span class="line">__uint32_t __pad;   &#x2F;* Same size for 32-bit or 64-bit clients *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>获取线程寄存器相关信息。</p><h4 id="thread-get-state"><a href="#thread-get-state" class="headerlink" title="thread_get_state"></a>thread_get_state</h4><p>在 <a href="https://github.com/apple-oss-distributions/xnu/blob/main/libsyscall/wrappers/thread_register_state.c#L63">xnu</a> 源码中找到了搜索到了蛛丝马迹，获取到 state 内容后使用相关寄存器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#if defined(__i386__)</span><br><span class="line">i386_thread_state_t state &#x3D; &#123;&#125;;</span><br><span class="line">thread_state_flavor_t flavor &#x3D; x86_THREAD_STATE32;</span><br><span class="line">mach_msg_type_number_t count &#x3D; i386_THREAD_STATE_COUNT;</span><br><span class="line">#elif defined(__x86_64__)</span><br><span class="line">x86_thread_state64_t state &#x3D; &#123;&#125;;</span><br><span class="line">thread_state_flavor_t flavor &#x3D; x86_THREAD_STATE64;</span><br><span class="line">mach_msg_type_number_t count &#x3D; x86_THREAD_STATE64_COUNT;</span><br><span class="line">#elif defined(__arm__)</span><br><span class="line">arm_thread_state_t state &#x3D; &#123;&#125;;</span><br><span class="line">thread_state_flavor_t flavor &#x3D; ARM_THREAD_STATE;</span><br><span class="line">mach_msg_type_number_t count &#x3D; ARM_THREAD_STATE_COUNT;</span><br><span class="line">#elif defined(__arm64__)</span><br><span class="line">arm_thread_state64_t state &#x3D; &#123;&#125;;</span><br><span class="line">thread_state_flavor_t flavor &#x3D; ARM_THREAD_STATE64;</span><br><span class="line">mach_msg_type_number_t count &#x3D; ARM_THREAD_STATE64_COUNT;</span><br><span class="line">#else</span><br><span class="line">#error thread_get_register_pointer_values not defined for this architecture</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">kern_return_t ret &#x3D; thread_get_state(thread, flavor, (thread_state_t)&amp;state, &amp;count);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;xxxx</span><br><span class="line">if (sp) &#123;</span><br><span class="line">uintptr_t __sp &#x3D; arm_thread_state64_get_sp(state);</span><br><span class="line">if (__sp &gt; 128) &#123;</span><br><span class="line">*sp &#x3D; __sp - 128 &#x2F;* redzone *&#x2F;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">*sp &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">push_register_value(arm_thread_state64_get_lr(state));</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0; i &lt; 29; i++) &#123;</span><br><span class="line">push_register_value(state.__x[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="vm-read-overwrite"><a href="#vm-read-overwrite" class="headerlink" title="vm_read_overwrite"></a>vm_read_overwrite</h4><p><a href="http://web.mit.edu/darwin/src/modules/xnu/osfmk/man/vm_read.html">vm_read_overwrite</a></p><blockquote><p>The vm_read and vm_read_overwrite functions read a portion of a task’s virtual memory (they enable tasks to read other tasks’ memory). The vm_read function returns the data in a dynamically allocated array of bytes; the vm_read_overwrite function places the data into a caller-specified buffer (the data_in parameter).</p></blockquote><p>上面的代码就是调用系统函数 <code>vm_read_overwrite</code> 从 fp 的位置开始读取内存，给 <code>SMStackFrame</code> 结构体赋值，从而得到 lr, 再根据 lr 递归调用获取整个函数的调用链。 </p><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="ksdl-dladdr"><a href="#ksdl-dladdr" class="headerlink" title="ksdl_dladdr"></a>ksdl_dladdr</h2><p>从上面的调试可知，<code>dladdr</code> 就是 <code>lldb</code> 命令 <code>image lookup -a 0x00xxx</code> 的代码实现，二者功能是类似的。<br><br/></p><blockquote><p>NAME<br>     dladdr – find the image containing a given address</p></blockquote><p>上面是在终端使用 <code>man dladdr</code> 得到的内容。</p><p>有一个问题：为什么不使用系统的 <code>dladdr</code> 函数？而要自己实现 <code>ksdl_dladdr</code> 呢？<br>找到了相关问题 <a href="https://github.com/bestswifter/BSBacktraceLogger/issues/8">BSBacktraceLogger - 请问为什么不用系统提供的dladdr方法，而需要自己写一个fl_dladdr呢？ #8</a>，但作者没有给出有用的答案。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** async-safe version of dladdr.</span><br><span class="line"> *</span><br><span class="line"> * This method searches the dynamic loader for information about any image</span><br><span class="line"> * containing the specified address. It may not be entirely successful in</span><br><span class="line"> * finding information, in which case any fields it could not find will be set</span><br><span class="line"> * to NULL.</span><br><span class="line"> *</span><br><span class="line"> * Unlike dladdr(), this method does not make use of locks, and does not call</span><br><span class="line"> * async-unsafe functions.</span><br><span class="line"> *</span><br><span class="line"> * @param address The address to search for.</span><br><span class="line"> * @param info Gets filled out by this function.</span><br><span class="line"> * @return true if at least some information was found.</span><br><span class="line"> *&#x2F;</span><br><span class="line">bool ksdl_dladdr(const uintptr_t address, Dl_info* const info);</span><br></pre></td></tr></table></figure><p>看 <code>ksdl_dladdr</code> 的声明可知，从侧面反应系统的 <code>dladdr</code> 是同步的，会使用锁，可能会导致耗时。</p><p>有兴趣的可以查看 <a href="https://github.com/apple-oss-distributions/dyld/blob/f73171cf0a177f453fdb124952908fe83864acab/dyld/DyldAPIs.cpp#L1016">dyld</a> 里面关于 <code>dladdr</code> 的实现。</p><h2 id="lldb-backtrace-thread"><a href="#lldb-backtrace-thread" class="headerlink" title="lldb backtrace thread"></a>lldb backtrace thread</h2><p>不管是 <a href="https://github.com/ming1016/DecoupleDemo/blob/master/DecoupleDemo/SMCallStack.m#L103">SMCallStack</a> 还是 <a href="https://github.com/bestswifter/BSBacktraceLogger/issues/8">BSBacktraceLogger</a> 输出结果跟 <code>lldb bt</code> 的结果还是有些差异的，可能跟着两个库代码很久没更新有关系，<a href="https://github.com/microsoft/plcrashreporter">plcrashreporter</a> 的输出结果最接近（因为不知道怎么根据 KSCrash 直接获取调用堆栈），代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PLCrashReporterConfig *config &#x3D; [[PLCrashReporterConfig alloc] initWithSignalHandlerType:PLCrashReporterSignalHandlerTypeBSD symbolicationStrategy:PLCrashReporterSymbolicationStrategyAll];</span><br><span class="line">    PLCrashReporter *crashReporter &#x3D; [[PLCrashReporter alloc] initWithConfiguration:config];</span><br><span class="line">    NSData *data &#x3D; [crashReporter generateLiveReport];</span><br><span class="line">    PLCrashReport *reporter &#x3D; [[PLCrashReport alloc] initWithData:data error:NULL];</span><br><span class="line">    NSString *report &#x3D; [PLCrashReportTextFormatter stringValueForCrashReport:reporter</span><br><span class="line">withTextFormat:PLCrashReportTextFormatiOS];</span><br></pre></td></tr></table></figure><br><p>所以，就想找到 <code>lldb backtrace thread</code> 的源码实现。<br>下载 <a href="https://github.com/apple-oss-distributions/lldb">lldb</a> 工程，然后搜索 <code>Backtrace thread</code> 找到如下相关代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">lldb::ThreadSP</span><br><span class="line">    GetExtendedBacktraceThread (ConstString type);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ----</span><br><span class="line">uint32_t</span><br><span class="line">SBThread::GetExtendedBacktraceOriginatingIndexID ()</span><br><span class="line">&#123;</span><br><span class="line">    ThreadSP thread_sp(m_opaque_sp-&gt;GetThreadSP());</span><br><span class="line">    if (thread_sp)</span><br><span class="line">        return thread_sp-&gt;GetExtendedBacktraceOriginatingIndexID();</span><br><span class="line">    return LLDB_INVALID_INDEX32;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ----</span><br><span class="line">typedef std::shared_ptr&lt;lldb_private::Thread&gt; ThreadSP;</span><br></pre></td></tr></table></figure><p>坑爹，看到 <code>lldb_private</code> 就知道凉凉了，因为它是私有的，只在 llvm 官网找到了相关定义 <a href="https://lldb.llvm.org/cpp_reference/classlldb__private_1_1Thread.html">lldb_private::Thread Class Reference</a>。</p><p>后面又想过是否可以通过查看 GDB 的源码来查看 <code>backtrace thread</code> 的源码实现，嗯，是个好想法！！！</p><h2 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h2><p>我们知道，OC 的方法调用最终都会走 <code>objc_msgSend</code> 这个汇编实现的函数，那为什么它没有出现在调用堆栈里面呢？<br>可以猜测下答案：因为 <code>objc_msgSend</code> 不会使用栈空间。<br>下面来 debug 调试下，还是前面 <code>viewDidLoad</code> 调用 <code>test1</code> 的例子，分别对比在这两个函数汇编下寄存器的值。</p><hr><p>call test1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Demo_fishhook&#96;-[ViewController viewDidLoad]:</span><br><span class="line">    0x104e32f58 &lt;+0&gt;:   sub    sp, sp, #0x40</span><br><span class="line">    0x104e32f5c &lt;+4&gt;:   stp    x29, x30, [sp, #0x30]</span><br><span class="line">    0x104e32f60 &lt;+8&gt;:   add    x29, sp, #0x30</span><br><span class="line">    0x104e32f64 &lt;+12&gt;:  stur   x0, [x29, #-0x8]</span><br><span class="line">    0x104e32f68 &lt;+16&gt;:  stur   x1, [x29, #-0x10]</span><br><span class="line">    0x104e32f6c &lt;+20&gt;:  ldur   x8, [x29, #-0x8]</span><br><span class="line">    0x104e32f70 &lt;+24&gt;:  add    x0, sp, #0x10</span><br><span class="line">    0x104e32f74 &lt;+28&gt;:  str    x8, [sp, #0x10]</span><br><span class="line">    0x104e32f78 &lt;+32&gt;:  adrp   x8, 89</span><br><span class="line">    0x104e32f7c &lt;+36&gt;:  ldr    x8, [x8, #0x6c0]</span><br><span class="line">    0x104e32f80 &lt;+40&gt;:  str    x8, [sp, #0x18]</span><br><span class="line">    0x104e32f84 &lt;+44&gt;:  adrp   x8, 88</span><br><span class="line">    0x104e32f88 &lt;+48&gt;:  ldr    x1, [x8, #0xbe8]</span><br><span class="line">    0x104e32f8c &lt;+52&gt;:  bl     0x104e730a4               ; symbol stub for: objc_msgSendSuper2</span><br><span class="line">    0x104e32f90 &lt;+56&gt;:  ldur   x0, [x29, #-0x8]</span><br><span class="line">    0x104e32f94 &lt;+60&gt;:  adrp   x8, 88</span><br><span class="line">    0x104e32f98 &lt;+64&gt;:  ldr    x1, [x8, #0xbf0]</span><br><span class="line">    0x104e32f9c &lt;+68&gt;:  mov    w2, #0x1</span><br><span class="line">-&gt;  0x104e32fa0 &lt;+72&gt;:  bl     0x104e73098               ; symbol stub for: objc_msgSend</span><br><span class="line">    0x104e32fa4 &lt;+76&gt;:  str    w0, [sp, #0xc]</span><br><span class="line">    0x104e32fa8 &lt;+80&gt;:  ldr    w9, [sp, #0xc]</span><br><span class="line">    0x104e32fac &lt;+84&gt;:  mov    x8, x9</span><br><span class="line">    0x104e32fb0 &lt;+88&gt;:  adrp   x0, 81</span><br><span class="line">    0x104e32fb4 &lt;+92&gt;:  add    x0, x0, #0x440            ; @&quot;res: %d&quot;</span><br><span class="line">    0x104e32fb8 &lt;+96&gt;:  mov    x9, sp</span><br><span class="line">    0x104e32fbc &lt;+100&gt;: str    x8, [x9]</span><br><span class="line">    0x104e32fc0 &lt;+104&gt;: bl     0x104e72720               ; symbol stub for: NSLog</span><br><span class="line">    0x104e32fc4 &lt;+108&gt;: ldp    x29, x30, [sp, #0x30]</span><br><span class="line">    0x104e32fc8 &lt;+112&gt;: add    sp, sp, #0x40</span><br><span class="line">    0x104e32fcc &lt;+116&gt;: ret    </span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) register read</span><br><span class="line">General Purpose Registers:</span><br></pre></td></tr></table></figure><hr><p>objc_msgSend</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Demo_fishhook&#96;objc_msgSend:</span><br><span class="line">-&gt;  0x104e73098 &lt;+0&gt;: nop    </span><br><span class="line">    0x104e7309c &lt;+4&gt;: ldr    x16, #0xd6e4              ; (void *)0x0000000198569ce0: objc_msgSend</span><br><span class="line">    0x104e730a0 &lt;+8&gt;: br     x16</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(lldb) si</span><br><span class="line">(lldb) register read</span><br><span class="line">General Purpose Registers:</span><br></pre></td></tr></table></figure><p>对比发现两者变化的仅仅是 <code>lr</code> 和 <code>pc</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; test1</span><br><span class="line">lr &#x3D; 0x0000000104e32f90  Demo_fishhook&#96;-[ViewController viewDidLoad] + 56 at ViewController.m:84:16</span><br><span class="line">pc &#x3D; 0x0000000104e32fa0  Demo_fishhook&#96;-[ViewController viewDidLoad] + 72 at ViewController.m:84:15</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; objc_msgSend</span><br><span class="line">lr &#x3D; 0x0000000104e32fa4  Demo_fishhook&#96;-[ViewController viewDidLoad] + 76 at ViewController.m:84:9</span><br><span class="line">pc &#x3D; 0x0000000104e73098  Demo_fishhook&#96;symbol stub for: objc_msgSend</span><br></pre></td></tr></table></figure><p>经过上面的输出可知，<code>objc_msgSend</code> 共用当前函数的栈空间，没有产生新的栈空间，所以就不会出现在函数调用栈里面了，所以，这是 <code>objc_msgSend</code> 用汇编实现的原因之一吗？</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://book.douban.com/subject/3652388/">程序员的自我修养–链接、装载与库</a></li><li><a href="https://github.com/ARM-software/abi-aa/blob/60a8eb8c55e999d74dac5e368fc9d7e36e38dda4/aapcs64/aapcs64.rst#the-stack">Procedure Call Standard for the Arm® 64-bit Architecture (AArch64)</a></li><li><a href="https://en.wikipedia.org/wiki/Calling_convention#ARM_(A64)">Calling_convention#ARM_(A64)</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%AF%84%E5%AD%98%E5%99%A8">寄存器</a></li><li><a href="https://time.geekbang.org/column/intro/100024501?tab=catalog">iOS 开发高手课</a></li><li><a href="https://blackteachinese.github.io/2017/07/12/arm64/">10分钟入门arm64汇编</a></li><li><a href="https://github.com/bestswifter/BSBacktraceLogger/issues/8">BSBacktraceLogger - 请问为什么不用系统提供的dladdr方法，而需要自己写一个fl_dladdr呢？ #8</a></li><li><a href="https://github.com/apple-oss-distributions/dyld/blob/f73171cf0a177f453fdb124952908fe83864acab/dyld/DyldAPIs.cpp#L1016">dyld</a></li><li><a href="https://github.com/ming1016/DecoupleDemo/blob/master/DecoupleDemo/SMCallStack.m#L103">SMCallStack</a></li><li><a href="https://github.com/kstenerud/KSCrash/blob/498aa21d23541b0bb4990f8d3d20bea2c280a18b/Source/KSCrash/Recording/Tools/KSDynamicLinker.c#L232">KSCrash</a></li><li><a href="https://github.com/microsoft/plcrashreporter">plcrashreporter</a></li><li><a href="https://github.com/apple-oss-distributions/lldb">lldb</a></li><li><a href="http://djs66256.github.io/2018/01/21/2018-01-21-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%8E%B7%E5%8F%96%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88/">运行时获取函数调用栈</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;《&lt;a href=&quot;https://book.douban.com/subject/3652388/&quot;&gt;程序员的自我修养–链接、装载与库&lt;/a&gt;》 &lt;code&gt;10.2 栈与调用惯例&lt;/code&gt; 里面讲到了堆栈帧这块的内容，联想到同事面试时说到捕获奔溃调用栈的问题，感觉挺
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从 Fishhook 学到了什么？</title>
    <link href="http://example.com/2022/09/20/fishhook/"/>
    <id>http://example.com/2022/09/20/fishhook/</id>
    <published>2022-09-20T02:10:39.000Z</published>
    <updated>2022-09-28T03:58:48.693Z</updated>
    
    <content type="html"><![CDATA[<p>最近把《<a href="https://book.douban.com/subject/3652388/">程序员的自我修养–链接、装载与库</a>》这本书又重新温习了下，加深了对可执行文件的理解，这篇文章就结合 <a href="https://github.com/facebook/fishhook">fishhook</a> 来实践一下。</p><h1 id="Demo-NSLog"><a href="#Demo-NSLog" class="headerlink" title="Demo - NSLog"></a>Demo - NSLog</h1><p>先从一个 NSLog 的 Demo 实践开始，讲解调用系统库函数 <code>NSLog</code> 的执行流程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    NSString * appDelegateClassName;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        &#x2F;&#x2F; Setup code that might create autoreleased objects goes here.</span><br><span class="line">        appDelegateClassName &#x3D; NSStringFromClass([AppDelegate class]);</span><br><span class="line">        NSLog(@&quot;%@&quot;, @&quot;hello world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return UIApplicationMain(argc, argv, nil, appDelegateClassName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lldb"><a href="#lldb" class="headerlink" title="lldb"></a>lldb</h2><p>在 NSLog 处下断点，并在 Xcode 设置 <code>debug -&gt; debug workflow -&gt; always show disassembly</code> 查看其汇编实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    0x10fcf0a79 &lt;+89&gt;:  leaq   0x26f20(%rip), %rdi       ; @&quot;%@&quot;</span><br><span class="line">    0x10fcf0a80 &lt;+96&gt;:  leaq   0x26f39(%rip), %rsi       ; @&quot;hello world&quot;</span><br><span class="line">-&gt;  0x10fcf0a87 &lt;+103&gt;: movb   $0x0, %al</span><br><span class="line">    0x10fcf0a89 &lt;+105&gt;: callq  0x10fd12000               ; symbol stub for: NSLog</span><br><span class="line">    0x10fcf0a8e &lt;+110&gt;: movq   -0x20(%rbp), %rdi</span><br><span class="line">    0x10fcf0a92 &lt;+114&gt;: callq  0x10fd122ac               ; symbol stub for: objc_autoreleasePoolPop</span><br></pre></td></tr></table></figure><p>在 <code>0x10fd12000</code> 处下断点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) b 0x10fd12000</span><br><span class="line">Breakpoint 3: where &#x3D; Demo_fishhook&#96;symbol stub for: NSLog, address &#x3D; 0x000000010fd12000</span><br></pre></td></tr></table></figure><p>单步执行过掉 <code>NSLog</code> 处的断点，到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Demo_fishhook&#96;NSLog:</span><br><span class="line">-&gt;  0x10fd12000 &lt;+0&gt;: jmpq   *0x50ea(%rip)             ; (void *)0x00007fff207ee762: NSLog</span><br></pre></td></tr></table></figure><p>这条指令的意思获取 <code>rip + 0x50ea</code> 地址(A)，然后跳转到该地址存储的值(B)（类比二级指针）。</p><p>那我们先找出 rip 的地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(lldb) register read</span><br><span class="line">General Purpose Registers:</span><br><span class="line">       rax &#x3D; 0x0000600002f3e400</span><br><span class="line">       rbx &#x3D; 0x000000010fda3060</span><br><span class="line">       rcx &#x3D; 0x0000000114fbf600  dyld&#96;_main_thread</span><br><span class="line">       rdx &#x3D; 0x000000000000002c</span><br><span class="line">       rdi &#x3D; 0x000000010fd179a0  @&quot;%@&quot;</span><br><span class="line">       rsi &#x3D; 0x000000010fd179c0  @&quot;hello world&quot;</span><br><span class="line">       rbp &#x3D; 0x00007ff7b0212ca0</span><br><span class="line">       rsp &#x3D; 0x00007ff7b0212c78</span><br><span class="line">        r8 &#x3D; 0x00007fff862a40c0  libsystem_pthread.dylib&#96;_pthread_keys</span><br><span class="line">        r9 &#x3D; 0x0000000000000000</span><br><span class="line">       r10 &#x3D; 0x00007fff862da642  (void *)0xe6b800007fff862d</span><br><span class="line">       r11 &#x3D; 0x00007fff2019c15c  libobjc.A.dylib&#96;-[NSObject autorelease]</span><br><span class="line">       r12 &#x3D; 0x0000000114fbf3a0  dyld&#96;_NSConcreteStackBlock</span><br><span class="line">       r13 &#x3D; 0x00007ff7b0212d68</span><br><span class="line">       r14 &#x3D; 0x000000010ff98e14  dyld_sim&#96;start_sim</span><br><span class="line">       r15 &#x3D; 0x0000000114fb3010  dyld&#96;dyld4::sConfigBuffer</span><br><span class="line">       rip &#x3D; 0x000000010fd12000  Demo_fishhook&#96;symbol stub for: NSLog</span><br><span class="line">    rflags &#x3D; 0x0000000000000246</span><br><span class="line">        cs &#x3D; 0x000000000000002b</span><br><span class="line">        fs &#x3D; 0x0000000000000000</span><br><span class="line">        gs &#x3D; 0x0000000000000000</span><br></pre></td></tr></table></figure><p>当前指令还卡在 <code>0x000000010fd12000</code> 处，所以 rip 还是它。那怎么知道 <code>0x000000010fd12000</code> 下一条指令的地址呢？也就是 <code>0x000000010fd12000</code> 这条指令的长度（PS: 按道理应该有文档能找到 AT&amp;T X86-64 汇编 jmpq 指令的长度，但没搜到）。<br>后面用 <code>lldb dis</code> 乱猜一通，于是就有了下面的结果。<br><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/fishhook/20220923110933.png"></p><p><code>0x10fd12000</code> 下一条指令是 <code>0x10fd12006</code>，所以地址(A)就是 <code>0x000000010fd170f0</code>，而 <code>0x000000010fd170f0</code> 里面存储的值(B)就是 <code>0x00007fff207ee762</code>，在系统库 <code>Foundation</code> 里面，也就是找到 <code>NSLog</code> 的实现了。这跟 <a href="https://zhang759740844.github.io/2019/07/07/fishhook/">fishhook 源码解析</a> 里面提到的第一次会通过 <code>__stub_helper</code> 去查找不符合，这里 <code>__DATA,__la_symbol_ptr</code> 直接存储的就是实际地址值了。(PS: 我 Xcode 版本是 <code>Version 13.1 (13A1030d)</code>，通过下断点得知是 dyld4, 我以为是 dyld4 做了什么优化，把电脑重启后再次运行还是一样的结果。)</p><p><strong>Note</strong>: </p><ol><li>大小端，内存地址存储的值是小端模式，即 <code>0x10fd170f0: 62 e7 7e 20 ff 7f 00 00</code> </li><li>lldb image 指令的其他玩法，可以在 help 调试下输入 <code>image help</code> 查看</li></ol><h2 id="MachOView"><a href="#MachOView" class="headerlink" title="MachOView"></a>MachOView</h2><p>既然 lldb 调试推理不出 <code>__stub_helper</code>，那就看下是否能通过 macho 可执行文件里面存储的原始值能推理出来不？</p><p>还是前面的断点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(lldb) image lookup -a 0x10fd12000</span><br><span class="line">      Address: Demo_fishhook[0x0000000100027000] (Demo_fishhook.__TEXT.__stubs + 18)</span><br><span class="line">      Summary: Demo_fishhook&#96;symbol stub for: NSLog</span><br></pre></td></tr></table></figure><p>在 <code>__TEXT.__stubs</code> section, 用 <a href="https://sourceforge.net/projects/machoview/">MachOView</a> 来查看该 Demo 的可执行文件。</p><p><strong>Note</strong>:</p><ol><li><code>0x10fd12000</code> 是虚拟内存地址</li><li><code>0x0000000100027000</code> 是加上虚拟基地址的文件偏移(offset), 而虚拟基地址一般都是 <code>0x0000000100000000</code>, 即 2^32.</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(lldb) image list &#x2F;&#x2F; 得出该可执行文件 image 在虚拟内存中的起始地址：&#96;0x000000010fceb000&#96;</span><br><span class="line">[  0] 0D70A5F7-C54D-312D-B242-ADE1AB9BEF9D 0x000000010fceb000 &#x2F;Users&#x2F;joakim&#x2F;Library&#x2F;Developer&#x2F;Xcode&#x2F;DerivedData&#x2F;Demo_fishhook-ebwkhxbcogafxbclcdeifrppsgdu&#x2F;Build&#x2F;Products&#x2F;Debug-iphonesimulator&#x2F;Demo_fishhook.app&#x2F;Demo_fishhook </span><br><span class="line">      &#x2F;Users&#x2F;joakim&#x2F;Library&#x2F;Developer&#x2F;Xcode&#x2F;DerivedData&#x2F;Demo_fishhook-ebwkhxbcogafxbclcdeifrppsgdu&#x2F;Build&#x2F;Products&#x2F;Debug-iphonesimulator&#x2F;Demo_fishhook.app.dSYM&#x2F;Contents&#x2F;Resources&#x2F;DWARF&#x2F;Demo_fishhook</span><br><span class="line"></span><br><span class="line">(lldb) image list -o -f &#x2F;&#x2F; 得到可执行文件的 ASLR 值</span><br><span class="line">[  0] 0x000000000fceb000 &#x2F;Users&#x2F;joakim&#x2F;Library&#x2F;Developer&#x2F;Xcode&#x2F;DerivedData&#x2F;Demo_fishhook-ebwkhxbcogafxbclcdeifrppsgdu&#x2F;Build&#x2F;Products&#x2F;Debug-iphonesimulator&#x2F;Demo_fishhook.app&#x2F;Demo_fishhook     </span><br><span class="line"></span><br><span class="line">(lldb) p&#x2F;x 0x000000010fceb000 - 0x000000000fceb000</span><br><span class="line">(long) $0 &#x3D; 0x0000000100000000  &#x2F;&#x2F; 上面两个地址相减，就得到了虚拟基址</span><br><span class="line"></span><br><span class="line">(lldb) p&#x2F;x 0x0000000100027000 - 0x0000000100000000 &#x2F;&#x2F; 得到 &#96;Demo_fishhook.__TEXT.__stubs&#96; 在 macho 文件中的 offset</span><br><span class="line">(long) $1 &#x3D; 0x0000000000027000</span><br><span class="line"></span><br><span class="line">(lldb) p&#x2F;x 0x10fd12006 + 0x50ea - 0x000000000fceb000 &#x2F;&#x2F; 得到前面提到的地址 A, 还是通过前面 lldb 计算得来，发现跟下面 MachOView 所查看到的是一样的</span><br><span class="line">(int) $2 &#x3D; 0x000000010002c0f0</span><br></pre></td></tr></table></figure><p>在 <code>RVA</code> tab 找到 <code>0x000000010002c0f0</code> 地址<br><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/fishhook/20220923124046.png"><br>注意 <code>Data</code> 那一栏的值 <code>00000001000273D8</code>, 继续查找。</p><ul><li>RVA: Relative Virtual Address, 相对虚拟地址（没添加 ASLR 的值）</li><li>RAW: offset, 在 macho 文件中的偏移</li></ul><p><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/fishhook/20220923124324.png"><br><strong>push 0x59</strong><br><code>push 0x59</code>: 表示将 0x59 立即数入栈，而我们知道栈一般用做函数调用时的传参。<br>那 0x59 立即数又是什么意思呢？<br>根据 <a href="https://tannerjin.github.io/2019/09/25/AntiHook/">AntiHook</a> 的内容可知</p><blockquote><p>其实在dyld源码里，dyld_ stub_bind最后会调用fastBindLazySymbol函数，这个函数的第二个参数是lazyBindingInfoOffset, 即0x0120是Binding Info或者Lazy Binding Info区起始开始到符号信息的偏移，而符号信息如下图</p></blockquote><p>因为 <code>NSLog</code> 符号在 <code>__DATA,__la_symbol_ptr</code>(la: lazy), 所以就是相对于 <code>Lazy Binding Info</code> 偏移 0x59 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p&#x2F;x 0x1000370F8 + 0x59</span><br><span class="line">(long) $17 &#x3D; 0x0000000100037151</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/fishhook/20220923124908.png"><br>嗯，有趣的事情来了，这里竟然有符号名 <code>name(_NSLog)</code>。<br>那 <code>dylib(3)</code> 呢？表示该符号在所加载的第3个 dylib 里面（如下图）。<br><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/fishhook/20220923125118.png"><br><strong>Note:</strong> 从这里可以看出，进行链接的时候会把动态库里符号的相关信息存储起来（即：该符号属于哪个动态库）。</p><p><strong>jmp 0x10002733c</strong><br><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/fishhook/20220923125508.png"></p><ul><li><code>lea r11, qword ptr [rip + 0x4cbd]</code><ul><li>将 <code>rip + 0x4cbd = 0x100027343 + 0x4cbd = 0x000000010002c000</code> 地址的值存入 r11 寄存器</li></ul></li><li><code>push r11</code><ul><li>所以此时栈中有两个参数：前面的 0x59; 这里的 <code>0x000000010002c000</code></li></ul></li><li><code>jmp qword ptr [rip + 0x4d85]</code><ul><li>跳转到 <code>rip + 0x4cbd = 0x10002734B + 0x4d85 = 0x000000010002c0d0</code> 执行函数</li></ul></li></ul><p>注意：这里分为两块</p><ol><li>前面这一块的就是 <code>__stub_helper</code> 的具体执行逻辑</li><li>后面这一块就是传参、然后调用 <code>__stub_helper</code> // 而这里的参数具体在前面讲解 0x59 的时候有提到</li></ol><p><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/fishhook/20220923130136.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p&#x2F;x 0x000000000fceb000 + 0x10002C000</span><br><span class="line">(long) $24 &#x3D; 0x000000010fd17000</span><br><span class="line">(lldb) x 0x000000010fd17000</span><br><span class="line">0x10fd17000: 00 00 00 00 00 00 00 00 00 94 4d 8a ff 7f 00 00  ..........M.....</span><br><span class="line">0x10fd17010: 08 28 2a 86 ff 7f 00 00 1a 33 25 20 ff 7f 00 00  .(*......3% ....</span><br></pre></td></tr></table></figure><p>诶，在程序启动后，它的值还是为 0, 这是为什么呢？</p><p><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/fishhook/20220923130225.png"><br>奈斯，终于看到 <code>dyld_stub_binder</code> 了，并且它已经有值了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p&#x2F;x 0x000000000fceb000 + 0x10002C0D0</span><br><span class="line">(long) $25 &#x3D; 0x000000010fd170d0</span><br><span class="line">(lldb) x 0x000000010fd170d0</span><br><span class="line">0x10fd170d0: 80 a6 2c 86 ff 7f 00 00 b9 85 36 20 ff 7f 00 00  ..,.......6 ....</span><br><span class="line">0x10fd170e0: 10 ad 7d 20 ff 7f 00 00 84 c0 3f 20 ff 7f 00 00  ..&#125; ......? ....</span><br></pre></td></tr></table></figure><p><strong>Note</strong>：这里的 <code>__DATA,__nl_symbol_ptr</code> 和 <code>__DATA,__got</code> Section 都是属于非懒加载的，在程序启动时 dyld 就会修正这些符号值。</p><p><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/fishhook/20220923131201.png" alt="__DATA,__nl_symbol_ptr Section"></p><p><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/fishhook/20220923131234.png" alt="__DATA,__got Section"></p><p><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/fishhook/20220923131308.png" alt="__DATA,__la_symbol_ptr Section"><br><strong>Note</strong>: 注意这里的 Indirect Sym Index(Reserved1): 168, 后面讲解 fishhook 的时候会提到。</p><p>因为它们存在于有可读可写权限的 <code>DATA Segment</code>。<br><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/fishhook/20220923131011.png" alt="TEXT Segment"><br>可读可执行。</p><p><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/fishhook/20220923131111.png" alt="DATA Segment"><br>可读可写。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>NSLog</code> 这块的逻辑大致分为</p><ol><li>lazy binding 的符号地址最开始指向 <code>__TEXT,__stubs</code> 里所指向的方法，调用该方法的时候，它会调用 <code>__DATA,__la_symbol_ptr</code> 所指向地址里面的方法</li><li>未绑定的时候，<code>__DATA,__la_symbol_ptr</code> 指向 <code>___TEXT,__stub_helper</code> ，而后者会执行系统函数(dyld_stub_binder)找到方法实现后，会修改 <code>__DATA,__la_symbol_ptr</code> 的值，从而指向实际的函数地址</li><li>已绑定的时候，<code>__DATA,__la_symbol_ptr</code> 则指向实际的函数地址。// 而 fishhook 就是这么干的，修改 <code>__DATA,__la_symbol_ptr</code> 里面相关符号的值</li></ol><h1 id="fishhook"><a href="#fishhook" class="headerlink" title="fishhook"></a>fishhook</h1><p>有了前面 <code>NSLog</code> lazy binding 的调试经验，现在调试 fishhook 就会轻松很多。这里的 Demo 参考自 <a href="https://zhang759740844.github.io/2019/07/07/fishhook/">fishhook 源码解析</a>。</p><h2 id="rebind-symbols"><a href="#rebind-symbols" class="headerlink" title="rebind_symbols"></a>rebind_symbols</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">struct rebindings_entry &#123;</span><br><span class="line">    struct rebinding *rebindings; &#x2F;&#x2F; rebinding 类型的数组</span><br><span class="line">    size_t rebindings_nel; &#x2F;&#x2F; 该数组的长度</span><br><span class="line">    struct rebindings_entry *next; &#x2F;&#x2F; 链表的下一个 entry</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 链表头</span><br><span class="line">static struct rebindings_entry *_rebindings_head;</span><br><span class="line"></span><br><span class="line">int rebind_symbols(struct rebinding rebindings[], size_t rebindings_nel) &#123;</span><br><span class="line">    &#x2F;&#x2F; 维护一个 rebindings_entry 的结构</span><br><span class="line">    &#x2F;&#x2F; 将 rebinding 的多个实例组织成一个链表</span><br><span class="line">    int retval &#x3D; prepend_rebindings(&amp;_rebindings_head, rebindings, rebindings_nel);</span><br><span class="line">    &#x2F;&#x2F; 判断是否 malloc 失败，失败会返回 -1</span><br><span class="line">    if (retval &lt; 0) &#123;</span><br><span class="line">        return retval;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; _rebindings_head -&gt; next 是第一次调用的标志符，NULL 则代表第一次调用</span><br><span class="line">    if (!_rebindings_head-&gt;next) &#123;</span><br><span class="line">        &#x2F;&#x2F; 第一次调用，将 _rebind_symbols_for_image 注册为回调</span><br><span class="line">        _dyld_register_func_for_add_image(_rebind_symbols_for_image);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 先获取 dyld 镜像数量</span><br><span class="line">        uint32_t c &#x3D; _dyld_image_count();</span><br><span class="line">        for (uint32_t i &#x3D; 0; i &lt; c; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 根据下标依次进行重绑定过程</span><br><span class="line">            _rebind_symbols_for_image(_dyld_get_image_header(i), _dyld_get_image_vmaddr_slide(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 返回状态值</span><br><span class="line">    return retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="prepend-rebindings"><a href="#prepend-rebindings" class="headerlink" title="prepend_rebindings"></a>prepend_rebindings</h2><p>该方法使用链表存储 <code>rebindings_entry</code> 结构，使用头插法将一个链表串起来，链表头用 <code>_rebindings_head</code> 保存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static struct rebindings_entry *_rebindings_head;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">rebindings_head: 静态的链表头</span><br><span class="line">rebindings: 方法符号数组</span><br><span class="line">nel: 数组长度</span><br><span class="line">*&#x2F;</span><br><span class="line">static int prepend_rebindings(struct rebindings_entry **rebindings_head,</span><br><span class="line">                              struct rebinding rebindings[],</span><br><span class="line">                              size_t nel) &#123;</span><br><span class="line">  &#x2F;&#x2F; 声明 rebindings_entry 一个指针，并为其分配空间</span><br><span class="line">  struct rebindings_entry *new_entry &#x3D; (struct rebindings_entry *) malloc(sizeof(struct rebindings_entry));</span><br><span class="line">  if (!new_entry) &#123;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 为数组 rebindings 分配内存</span><br><span class="line">  new_entry-&gt;rebindings &#x3D; (struct rebinding *) malloc(sizeof(struct rebinding) * nel);</span><br><span class="line">  if (!new_entry-&gt;rebindings) &#123;</span><br><span class="line">    free(new_entry);</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 内存拷贝，将 rebindings 数组中 copy 到 new_entry -&gt; rebingdings 成员中</span><br><span class="line">  memcpy(new_entry-&gt;rebindings, rebindings, sizeof(struct rebinding) * nel);</span><br><span class="line">  new_entry-&gt;rebindings_nel &#x3D; nel;</span><br><span class="line">  &#x2F;&#x2F; 头插法</span><br><span class="line">  new_entry-&gt;next &#x3D; *rebindings_head;</span><br><span class="line">  *rebindings_head &#x3D; new_entry;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过多次操作后，结果如下图所示<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/fishhook_11.png?raw=true" alt="rebindings_entry"></p><p><strong>Note</strong>: 这里 <code>*rebindings</code> 是一个数组。</p><h2 id="rebind-symbols-for-image"><a href="#rebind-symbols-for-image" class="headerlink" title="_rebind_symbols_for_image"></a>_rebind_symbols_for_image</h2><p><code>_dyld_register_func_for_add_image</code> 方法是 dyld 注册回调函数的方法，当镜像被加载的时候，就会主动触发注册的回调方法。</p><blockquote><p>一个可执行文件会加载非常多的动态库，每个动态库的成功加载都会触发注册的回调方法。每个动态库镜像都会根据设置重绑定符号</p></blockquote><p>这里多个 image 可以在程序运行的时候通过 <code>image list</code> 获取。</p><p>而这里，就注册了 <code>_rebind_symbols_for_image</code> 方法，但里面没做任何事情，直接调用另外一个方法。</p><p><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/fishhook/20220923150819.png"></p><ul><li>header: 当前可执行文件的虚拟内存地址；也就是 image 的 header 头信息，结构体如下图所示<br><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/fishhook/202209231503977.png" alt="Mach Header"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(lldb) image list</span><br><span class="line">[  0] 0D70A5F7-C54D-312D-B242-ADE1AB9BEF9D 0x000000010d574000 &#x2F;Users&#x2F;joakim&#x2F;Library&#x2F;Developer&#x2F;Xcode&#x2F;DerivedData&#x2F;Demo_fishhook-ebwkhxbcogafxbclcdeifrppsgdu&#x2F;Build&#x2F;Products&#x2F;Debug-iphonesimulator&#x2F;Demo_fishhook.app&#x2F;Demo_fishhook </span><br><span class="line">      &#x2F;Users&#x2F;joakim&#x2F;Library&#x2F;Developer&#x2F;Xcode&#x2F;DerivedData&#x2F;Demo_fishhook-ebwkhxbcogafxbclcdeifrppsgdu&#x2F;Build&#x2F;Products&#x2F;Debug-iphonesimulator&#x2F;Demo_fishhook.app.dSYM&#x2F;Contents&#x2F;Resources&#x2F;DWARF&#x2F;Demo_fishhook</span><br></pre></td></tr></table></figure></li><li>slide: ASLR 偏移值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) image list -o -f</span><br><span class="line">[  0] 0x000000000d574000 &#x2F;Users&#x2F;joakim&#x2F;Library&#x2F;Developer&#x2F;Xcode&#x2F;DerivedData&#x2F;Demo_fishhook-ebwkhxbcogafxbclcdeifrppsgdu&#x2F;Build&#x2F;Products&#x2F;Debug-iphonesimulator&#x2F;Demo_fishhook.app&#x2F;Demo_fishhook</span><br></pre></td></tr></table></figure></li><li>magic: 0x00000000feedfacf, 同 MachOView 那一栏的值，这里是大端模式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p&#x2F;x 4277009103</span><br><span class="line">(long) $2 &#x3D; 0x00000000feedfacf</span><br></pre></td></tr></table></figure></li></ul><p><strong>Note:</strong> 该进程有多少个 image, 该方法就会回调多少次。</p><h2 id="rebind-symbols-for-image-1"><a href="#rebind-symbols-for-image-1" class="headerlink" title="rebind_symbols_for_image"></a>rebind_symbols_for_image</h2><p>核心方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">static void rebind_symbols_for_image(struct rebindings_entry *rebindings,</span><br><span class="line">                                     const struct mach_header *header,</span><br><span class="line">                                     intptr_t slide) &#123;</span><br><span class="line">  Dl_info info;</span><br><span class="line">    &#x2F;&#x2F; header 无效</span><br><span class="line">  if (dladdr(header, &amp;info) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F; 1. 查找 linkedit_segment symtab_cmd dysymtab_cmd</span><br><span class="line">  segment_command_t *cur_seg_cmd;</span><br><span class="line">  segment_command_t *linkedit_segment &#x3D; NULL;</span><br><span class="line">  struct symtab_command* symtab_cmd &#x3D; NULL;</span><br><span class="line">  struct dysymtab_command* dysymtab_cmd &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 过掉 Mach-O Header, 到 Load Commands</span><br><span class="line">  uintptr_t cur &#x3D; (uintptr_t)header + sizeof(mach_header_t);</span><br><span class="line">    &#x2F;*</span><br><span class="line">     遍历每个 Load Command</span><br><span class="line">     header-&gt;ncmds: Load Commands 的数量</span><br><span class="line">     cur_seg_cmd-&gt;cmdsize: 当前 load command 的大小</span><br><span class="line">     *&#x2F;</span><br><span class="line">  for (uint i &#x3D; 0; i &lt; header-&gt;ncmds; i++, cur +&#x3D; cur_seg_cmd-&gt;cmdsize) &#123;</span><br><span class="line">    cur_seg_cmd &#x3D; (segment_command_t *)cur;</span><br><span class="line">      &#x2F;&#x2F; 判断类型是否是 SEG_LINKEDIT LC_SYMTAB LC_DYSYMTAB</span><br><span class="line">    if (cur_seg_cmd-&gt;cmd &#x3D;&#x3D; LC_SEGMENT_ARCH_DEPENDENT) &#123;</span><br><span class="line">      if (strcmp(cur_seg_cmd-&gt;segname, SEG_LINKEDIT) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        linkedit_segment &#x3D; cur_seg_cmd;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (cur_seg_cmd-&gt;cmd &#x3D;&#x3D; LC_SYMTAB) &#123;</span><br><span class="line">      symtab_cmd &#x3D; (struct symtab_command*)cur_seg_cmd;</span><br><span class="line">    &#125; else if (cur_seg_cmd-&gt;cmd &#x3D;&#x3D; LC_DYSYMTAB) &#123;</span><br><span class="line">      dysymtab_cmd &#x3D; (struct dysymtab_command*)cur_seg_cmd;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    &#x2F;&#x2F; 没找到，则 return</span><br><span class="line">  if (!symtab_cmd || !dysymtab_cmd || !linkedit_segment ||</span><br><span class="line">      !dysymtab_cmd-&gt;nindirectsyms) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Find base symbol&#x2F;string table addresses</span><br><span class="line">    &#x2F;*</span><br><span class="line">     2. 获取相关地址值</span><br><span class="line">     slide: ASLR 值</span><br><span class="line">     vmaddr: 虚拟地址值，fileoff: 文件偏移量，两者相减即可得 VM Size.</span><br><span class="line">     linkedit_base 就是在虚拟内存加载的基地址(image list 下 image 的值&#x2F;header)</span><br><span class="line">     *&#x2F;</span><br><span class="line">  uintptr_t linkedit_base &#x3D; (uintptr_t)slide + linkedit_segment-&gt;vmaddr - linkedit_segment-&gt;fileoff;</span><br><span class="line">  nlist_t *symtab &#x3D; (nlist_t *)(linkedit_base + symtab_cmd-&gt;symoff);</span><br><span class="line">  char *strtab &#x3D; (char *)(linkedit_base + symtab_cmd-&gt;stroff);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Get indirect symbol table (array of uint32_t indices into symbol table)</span><br><span class="line">  uint32_t *indirect_symtab &#x3D; (uint32_t *)(linkedit_base + dysymtab_cmd-&gt;indirectsymoff);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 3. 查找 section</span><br><span class="line">    &#x2F;&#x2F; 游标重置</span><br><span class="line">  cur &#x3D; (uintptr_t)header + sizeof(mach_header_t);</span><br><span class="line">  for (uint i &#x3D; 0; i &lt; header-&gt;ncmds; i++, cur +&#x3D; cur_seg_cmd-&gt;cmdsize) &#123;</span><br><span class="line">    cur_seg_cmd &#x3D; (segment_command_t *)cur;</span><br><span class="line">    if (cur_seg_cmd-&gt;cmd &#x3D;&#x3D; LC_SEGMENT_ARCH_DEPENDENT) &#123;</span><br><span class="line">      if (strcmp(cur_seg_cmd-&gt;segname, SEG_DATA) !&#x3D; 0 &amp;&amp;</span><br><span class="line">          strcmp(cur_seg_cmd-&gt;segname, SEG_DATA_CONST) !&#x3D; 0) &#123;</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line">        &#x2F;&#x2F; __DATA segment load command 后面跟 n 个 sections</span><br><span class="line">      for (uint j &#x3D; 0; j &lt; cur_seg_cmd-&gt;nsects; j++) &#123;</span><br><span class="line">        section_t *sect &#x3D;</span><br><span class="line">          (section_t *)(cur + sizeof(segment_command_t)) + j;</span><br><span class="line">        if ((sect-&gt;flags &amp; SECTION_TYPE) &#x3D;&#x3D; S_LAZY_SYMBOL_POINTERS) &#123;</span><br><span class="line">          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</span><br><span class="line">        &#125;</span><br><span class="line">        if ((sect-&gt;flags &amp; SECTION_TYPE) &#x3D;&#x3D; S_NON_LAZY_SYMBOL_POINTERS) &#123;</span><br><span class="line">          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找-linkedit-segment-symtab-cmd-dysymtab-cmd"><a href="#查找-linkedit-segment-symtab-cmd-dysymtab-cmd" class="headerlink" title="查找 linkedit_segment symtab_cmd dysymtab_cmd"></a>查找 linkedit_segment symtab_cmd dysymtab_cmd</h3><p>这没什么说的，就是常规的查找操作。</p><h4 id="Load-Commands"><a href="#Load-Commands" class="headerlink" title="Load Commands"></a>Load Commands</h4><p>见下面 <code>__LINKEDIT</code> 截图左侧的三个箭头。</p><h4 id="LINKEDIT"><a href="#LINKEDIT" class="headerlink" title="__LINKEDIT"></a>__LINKEDIT</h4><p><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/fishhook/20220923151356.png" alt="__LINKEDIT"><br>这是一个有意思的地方，<code>__DATA Section</code> 后面的都是 <code>__LINKEDIT Segment</code>，如下图。<br><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/fishhook/20220923151704.png" alt="__LINKEDIT Segment Start"><br><strong>Note:</strong> 这里切换成 RAW 了。</p><p><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/fishhook/20220923151925.png" alt="__LINKEDIT Segment End"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p&#x2F;x 0x34000 + 0x836B0 &#x2F;&#x2F; </span><br><span class="line">(int) $5 &#x3D; 0x000b76b0</span><br><span class="line">(lldb) p&#x2F;x 0xB76A0 + 0x10 &#x2F;&#x2F; 16: 0x10</span><br><span class="line">(int) $6 &#x3D; 0x000b76b0</span><br></pre></td></tr></table></figure><p>最后一个 Section 的 index 是 0xB76A0, 占 16Bytes, 也就是 0x000b76b0，没毛病。</p><h4 id="LC-SYSTAB"><a href="#LC-SYSTAB" class="headerlink" title="LC_SYSTAB"></a>LC_SYSTAB</h4><p><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/fishhook/20220923152549.png" alt="LC_SYSTAB"><br>注意两个 Table Offset, 分别对应 Symbol Table 和 String Table 的 file offset.</p><h4 id="LC-DYSYSTAB"><a href="#LC-DYSYSTAB" class="headerlink" title="LC_DYSYSTAB"></a>LC_DYSYSTAB</h4><p><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/fishhook/20220923152650.png" alt="LC_DYSYSTAB"><br>动态符号表。</p><h3 id="获取相关地址值"><a href="#获取相关地址值" class="headerlink" title="获取相关地址值"></a>获取相关地址值</h3><p><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/fishhook/20220923174959.png"></p><p>从上可知</p><ol><li>linkedit_base = header, 就是虚拟内存中加载的基地址</li><li>symtab, 看上面的 LC_SYSTAB 截图，<strong>Symbol Table Offset</strong>(symtab_cmd-&gt;symoff): 00039f28<br><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/fishhook/20220923153345.png" alt="Symbol Table"></li><li>strtab, 看上面的 LC_SYSTAB 截图，<strong>String Table Offset</strong>(symtab_cmd-&gt;stroff): 0005C8B0<br><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/fishhook/20220923153636.png" alt="String Table"></li><li>indirect_symtab, 看上面的 LC_DYSYSTAB 截图，IndSym Table Offset: 0005C3D8<br><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/fishhook/20220923153807.png" alt="Dynamic Symbol Table"></li></ol><h3 id="查找-section"><a href="#查找-section" class="headerlink" title="查找 section"></a>查找 section</h3><p>在 <code>__DATA</code> Segment, 下找到 type 为 <code>S_LAZY_SYMBOL_POINTERS/S_NON_LAZY_SYMBOL_POINTER</code> 的 section。<br>详见前面的相关截图<br><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/fishhook/20220923131201.png" alt="__DATA,__nl_symbol_ptr Section"></p><h2 id="perform-rebinding-with-section"><a href="#perform-rebinding-with-section" class="headerlink" title="perform_rebinding_with_section"></a>perform_rebinding_with_section</h2><p>重新绑定的逻辑，这里以 <code>__la_symbol_ptr</code> Section 为例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">static void perform_rebinding_with_section(struct rebindings_entry *rebindings,</span><br><span class="line">                                           section_t *section,</span><br><span class="line">                                           intptr_t slide,</span><br><span class="line">                                           nlist_t *symtab,</span><br><span class="line">                                           char *strtab,</span><br><span class="line">                                           uint32_t *indirect_symtab) &#123;</span><br><span class="line">    &#x2F;&#x2F; 该 section(__la_symbol_ptr) 在 indirect_symtab 的起始下标, 指向 indirect_symtab</span><br><span class="line">  uint32_t *indirect_symbol_indices &#x3D; indirect_symtab + section-&gt;reserved1;</span><br><span class="line">    &#x2F;&#x2F; 指向具体地址，Section64(__DATA, __la_symbol_ptr)</span><br><span class="line">  void **indirect_symbol_bindings &#x3D; (void **)((uintptr_t)slide + section-&gt;addr);</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">指针格式 sizeof(void *) &#x3D; 8, </span><br><span class="line">section-&gt;size &#x3D; 1128, 在 MachOView Section64 Header(__la_symbol_ptr), size 也是 1128</span><br><span class="line">所以共 1128&#x2F;8 &#x3D; 141 个符号，具体值在 Section64(__DATA, __la_symbol_ptr)</span><br><span class="line">*&#x2F;</span><br><span class="line">  for (uint i &#x3D; 0; i &lt; section-&gt;size &#x2F; sizeof(void *); i++) &#123;</span><br><span class="line">    uint32_t symtab_index &#x3D; indirect_symbol_indices[i];</span><br><span class="line">      &#x2F;&#x2F; 无效的符号</span><br><span class="line">    if (symtab_index &#x3D;&#x3D; INDIRECT_SYMBOL_ABS || symtab_index &#x3D;&#x3D; INDIRECT_SYMBOL_LOCAL ||</span><br><span class="line">        symtab_index &#x3D;&#x3D; (INDIRECT_SYMBOL_LOCAL   | INDIRECT_SYMBOL_ABS)) &#123;</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">      &#x2F;&#x2F; 在字符串表的下标</span><br><span class="line">    uint32_t strtab_offset &#x3D; symtab[symtab_index].n_un.n_strx;</span><br><span class="line">      &#x2F;&#x2F; 获取字符串名</span><br><span class="line">    char *symbol_name &#x3D; strtab + strtab_offset;</span><br><span class="line">    bool symbol_name_longer_than_1 &#x3D; symbol_name[0] &amp;&amp; symbol_name[1];</span><br><span class="line">    struct rebindings_entry *cur &#x3D; rebindings;</span><br><span class="line">    while (cur) &#123;</span><br><span class="line">      for (uint j &#x3D; 0; j &lt; cur-&gt;rebindings_nel; j++) &#123;</span><br><span class="line">          &#x2F;&#x2F; &amp;symbol_name[1] 去掉函数修饰时前面的 &#96;_&#96;, eg: _NSLog</span><br><span class="line">        if (symbol_name_longer_than_1 &amp;&amp; strcmp(&amp;symbol_name[1], cur-&gt;rebindings[j].name) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">          kern_return_t err;</span><br><span class="line"></span><br><span class="line">          if (cur-&gt;rebindings[j].replaced !&#x3D; NULL &amp;&amp; indirect_symbol_bindings[i] !&#x3D; cur-&gt;rebindings[j].replacement)</span><br><span class="line">              &#x2F;&#x2F; 替换前的原函数地址</span><br><span class="line">            *(cur-&gt;rebindings[j].replaced) &#x3D; indirect_symbol_bindings[i];</span><br><span class="line"></span><br><span class="line">          &#x2F;**</span><br><span class="line">           * 1. Moved the vm protection modifying codes to here to reduce the</span><br><span class="line">           *    changing scope.</span><br><span class="line">           * 2. Adding VM_PROT_WRITE mode unconditionally because vm_region</span><br><span class="line">           *    API on some iOS&#x2F;Mac reports mismatch vm protection attributes.</span><br><span class="line">           * -- Lianfu Hao Jun 16th, 2021</span><br><span class="line">           **&#x2F;</span><br><span class="line">          err &#x3D; vm_protect (mach_task_self (), (uintptr_t)indirect_symbol_bindings, section-&gt;size, 0, VM_PROT_READ | VM_PROT_WRITE | VM_PROT_COPY);</span><br><span class="line">          if (err &#x3D;&#x3D; KERN_SUCCESS) &#123;</span><br><span class="line">            &#x2F;**</span><br><span class="line">             * Once we failed to change the vm protection, we</span><br><span class="line">             * MUST NOT continue the following write actions!</span><br><span class="line">             * iOS 15 has corrected the const segments prot.</span><br><span class="line">             * -- Lionfore Hao Jun 11th, 2021</span><br><span class="line">             **&#x2F;</span><br><span class="line">              &#x2F;&#x2F; 修改函数指向的地方</span><br><span class="line">            indirect_symbol_bindings[i] &#x3D; cur-&gt;rebindings[j].replacement;</span><br><span class="line">          &#125;</span><br><span class="line">          goto symbol_loop;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      cur &#x3D; cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">  symbol_loop:;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SECTION-TYPE"><a href="#SECTION-TYPE" class="headerlink" title="SECTION_TYPE"></a>SECTION_TYPE</h3><p>该 header(0x000000010d574000) 会过掉三个 section </p><ul><li>0x000000010d5744b8: __nl_symbol_ptr</li><li>0x000000010d574508: __got</li><li>0x000000010d574558: __la_symbol_ptr</li></ul><p><strong>Note:</strong> 这里纠正了我之前的一个问题，以为只会处理 <code>__nl_symbol_ptr</code> 和 <code>__la_symbol_ptr</code> 这两个 section 的值，其实不是的，代码里面是判断的类型，而不是根据 Section 名字来的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if ((sect-&gt;flags &amp; SECTION_TYPE) &#x3D;&#x3D; S_NON_LAZY_SYMBOL_POINTERS)</span><br></pre></td></tr></table></figure><h3 id="indirect-symtab"><a href="#indirect-symtab" class="headerlink" title="indirect_symtab"></a>indirect_symtab</h3><p>只处理 <code>__la_symbol_ptr</code> section.</p><p><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/fishhook/20220923154802.png"><br><code>0xa8=168</code>, 还记得前面的截图<br><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/fishhook/20220923131308.png" alt="__DATA,__la_symbol_ptr Section"><br><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/fishhook/20220923153807.png" alt="Dynamic Symbol Table"><br>从 <code>Dynamic Symbol Table</code> 开始，第 168 个符号的 Offset 为 <code>0x000000000005c678</code>。<br><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/fishhook/20220923161044.png"><br>从这里开始遍历，共遍历 141 个符号。<br>PS: 这里 MachOView 的 Dynamic Symbol Table 已经把符号都显示出来了（见 Symbol 那一行）。</p><h3 id="symtab"><a href="#symtab" class="headerlink" title="symtab"></a>symtab</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po symtab_index</span><br><span class="line">8656</span><br></pre></td></tr></table></figure><p>在符号表里面找第 8656 个符号。<br>PS: 这里是以 <code>NSLog</code> 来跟踪的。</p><p><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/fishhook/20220923161741.png"></p><h3 id="strtab"><a href="#strtab" class="headerlink" title="strtab"></a>strtab</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p&#x2F;x 0x0005C8B0 + 0x000031C5</span><br><span class="line">0x5FA75</span><br></pre></td></tr></table></figure><p><code>0005C8B0</code> 是前面 strtab 的起始地址。</p><p><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/fishhook/20220923162233.png"><br>如上图，即 0x5FA70: m, 开始数到 0x5FA75: _, 遇到 .(0x5FA7B) 就结束。这里的 Data 都是 ASCII 码来着，查看 <a href="https://www.asciitable.com/">asciitable</a>。</p><ul><li>6D: m</li><li>0(00): .</li><li>5F: _</li><li>4E: N</li></ul><h3 id="代码具体地址"><a href="#代码具体地址" class="headerlink" title="代码具体地址"></a>代码具体地址</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 指向具体地址，Section64(__DATA, __la_symbol_ptr)</span><br><span class="line">void **indirect_symbol_bindings &#x3D; (void **)((uintptr_t)slide + section-&gt;addr);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p&#x2F;x slide</span><br><span class="line">(intptr_t) $52 &#x3D; 0x000000000d574000</span><br><span class="line">(lldb) p&#x2F;x section-&gt;addr</span><br><span class="line">(uint64_t) $53 &#x3D; 0x000000010002c0d8</span><br><span class="line">(lldb) p indirect_symbol_bindings</span><br><span class="line">(void **) $54 &#x3D; 0x000000010d5a00d8</span><br><span class="line">(lldb) p&#x2F;x 0x000000010d5a00d8 - 0x000000010d574000</span><br><span class="line">(long) $55 &#x3D; 0x000000000002c0d8</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/fishhook/20220923162922.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p 0x2c540 - 0x2c0d8</span><br><span class="line">(int) $60 &#x3D; 1128</span><br><span class="line">(lldb) p 1128&#x2F;8</span><br><span class="line">(int) $61 &#x3D; 141</span><br></pre></td></tr></table></figure><p><code>0x2c540</code> 是 <code>__DATA,__mod_init_func</code> 的地址。<br>这里共 141 个数据，所以通过 Load Command 下面每个 Section Header 的描述信息可知该 Section 下面的符号大小和个数。</p><h3 id="替换函数地址"><a href="#替换函数地址" class="headerlink" title="替换函数地址"></a>替换函数地址</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p &amp;indirect_symbol_bindings[i]</span><br><span class="line">(void **) $62 &#x3D; 0x000000010d5a00f0</span><br><span class="line">(lldb) p&#x2F;x 0x000000010d5a00f0 - 0x000000010d574000</span><br><span class="line">(long) $63 &#x3D; 0x000000000002c0f0</span><br></pre></td></tr></table></figure><p>就是上面截图 <code>NSLog</code> 符号在 <code>Section64(__DATA, __la_symbol_ptr)</code> 的值，因为 <code>indirect_symbol_bindings</code> 是二维指针数组，所以，这里需要进行取地址操作(&amp;)，所以这里替换 <code>Section64(__DATA, __la_symbol_ptr)</code>里面的具体地址值。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ol><li>通过注册系统回调 <code>_dyld_register_func_for_add_image</code> 获取每个 image 的虚拟内存起始地址和 ASLR 偏移</li><li>根据 image 的起始地址，加上 Header 的大小(Header 固定大小为 0x20)，得出 <code>SEG_LINKEDIT/LC_SYMTAB/LC_DYSYMTAB</code> 这3个 Load Commands 的起始地址</li><li>遍历 Load Commands，拿到 __DATA segment 里面类型为 <code>S_LAZY_SYMBOL_POINTERS/S_NON_LAZY_SYMBOL_POINTERS</code> 的 section (包括  <code>__DATA,__nl_symbol_ptr/__got/__la_symbol_ptr</code> 三个) 的各项信息，包括段的位置，段的大小，段在 Dynamic Symbol Table 的起始索引 reserved1（也就是 MachOView 中的 Indirect Sym Index）</li><li>在 <code>Dynamic Symbol Table</code> 遍历相关 Section(eg: <code>Section64(__DATA, __la_symbol_ptr)</code>) 的每个符号，然后找到符号在 <code>LC_SYMTAB</code> 的地址，从而得知该符号的名字</li><li>拿到该名字跟需要替换的符号做对比，如果对得上的话，进行替换，修改该 Section 下对应符号的指针指向</li></ol><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="lldb-image"><a href="#lldb-image" class="headerlink" title="lldb - image"></a>lldb - image</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">(lldb) image help</span><br><span class="line">Commands for accessing information for one or more target modules.</span><br><span class="line"></span><br><span class="line">Syntax: target modules &lt;sub-command&gt; ...</span><br><span class="line"></span><br><span class="line">The following subcommands are supported:</span><br><span class="line"></span><br><span class="line">      add          -- Add a new module to the current target&#39;s modules.</span><br><span class="line">      dump         -- Commands for dumping information about one or more target</span><br><span class="line">                      modules.</span><br><span class="line">      list         -- List current executable and dependent shared library</span><br><span class="line">                      images.</span><br><span class="line">      load         -- Set the load addresses for one or more sections in a</span><br><span class="line">                      target module.</span><br><span class="line">      lookup       -- Look up information within executable and dependent</span><br><span class="line">                      shared library images.</span><br><span class="line">      search-paths -- Commands for managing module search paths for a target.</span><br><span class="line">      show-unwind  -- Show synthesized unwind instructions for a function.</span><br><span class="line"></span><br><span class="line">(lldb) help image lookup</span><br><span class="line">Look up information within executable and dependent shared library images.</span><br><span class="line"></span><br><span class="line">Syntax: target modules lookup &lt;cmd-options&gt; [&lt;filename&gt; [&lt;filename&gt; [...]]]</span><br><span class="line"></span><br><span class="line">Command Options Usage:</span><br><span class="line">  target modules lookup [-Av] -a &lt;address-expression&gt; [-o &lt;offset&gt;] [&lt;filename&gt; [&lt;filename&gt; [...]]]</span><br><span class="line">  target modules lookup [-Arv] -s &lt;symbol&gt; [&lt;filename&gt; [&lt;filename&gt; [...]]]</span><br><span class="line">  target modules lookup [-Aiv] -f &lt;filename&gt; [-l &lt;linenum&gt;] [&lt;filename&gt; [&lt;filename&gt; [...]]]</span><br><span class="line">  target modules lookup [-Airv] -F &lt;function-name&gt; [&lt;filename&gt; [&lt;filename&gt; [...]]]</span><br><span class="line">  target modules lookup [-Airv] -n &lt;function-or-symbol&gt; [&lt;filename&gt; [&lt;filename&gt; [...]]]</span><br><span class="line">  target modules lookup [-Av] -t &lt;name&gt; [&lt;filename&gt; [&lt;filename&gt; [...]]]</span><br><span class="line"></span><br><span class="line">       -A ( --all )</span><br><span class="line">            Print all matches, not just the best match, if a best match is</span><br><span class="line">            available.</span><br><span class="line"></span><br><span class="line">       -F &lt;function-name&gt; ( --function &lt;function-name&gt; )</span><br><span class="line">            Lookup a function by name in the debug symbols in one or more</span><br><span class="line">            target modules.</span><br><span class="line"></span><br><span class="line">       -a &lt;address-expression&gt; ( --address &lt;address-expression&gt; )</span><br><span class="line">            Lookup an address in one or more target modules.</span><br><span class="line"></span><br><span class="line">       -f &lt;filename&gt; ( --file &lt;filename&gt; )</span><br><span class="line">            Lookup a file by fullpath or basename in one or more target</span><br><span class="line">            modules.</span><br><span class="line"></span><br><span class="line">       -i ( --no-inlines )</span><br><span class="line">            Ignore inline entries (must be used in conjunction with --file or</span><br><span class="line">            --function).</span><br><span class="line"></span><br><span class="line">       -l &lt;linenum&gt; ( --line &lt;linenum&gt; )</span><br><span class="line">            Lookup a line number in a file (must be used in conjunction with</span><br><span class="line">            --file).</span><br><span class="line"></span><br><span class="line">       -n &lt;function-or-symbol&gt; ( --name &lt;function-or-symbol&gt; )</span><br><span class="line">            Lookup a function or symbol by name in one or more target modules.</span><br><span class="line"></span><br><span class="line">       -o &lt;offset&gt; ( --offset &lt;offset&gt; )</span><br><span class="line">            When looking up an address subtract &lt;offset&gt; from any addresses</span><br><span class="line">            before doing the lookup.</span><br><span class="line"></span><br><span class="line">       -r ( --regex )</span><br><span class="line">            The &lt;name&gt; argument for name lookups are regular expressions.</span><br><span class="line"></span><br><span class="line">       -s &lt;symbol&gt; ( --symbol &lt;symbol&gt; )</span><br><span class="line">            Lookup a symbol by name in the symbol tables in one or more target</span><br><span class="line">            modules.</span><br><span class="line"></span><br><span class="line">       -t &lt;name&gt; ( --type &lt;name&gt; )</span><br><span class="line">            Lookup a type by name in the debug symbols in one or more target</span><br><span class="line">            modules.</span><br><span class="line"></span><br><span class="line">       -v ( --verbose )</span><br><span class="line">            Enable verbose lookup information.</span><br><span class="line">     </span><br><span class="line">     This command takes options and free-form arguments.  If your arguments</span><br><span class="line">     resemble option specifiers (i.e., they start with a - or --), you must use</span><br><span class="line">     &#39; -- &#39; between the end of the command options and the beginning of the</span><br><span class="line">     arguments.</span><br><span class="line"></span><br><span class="line">&#39;image&#39; is an abbreviation for &#39;target modules&#39;</span><br></pre></td></tr></table></figure><p>比如</p><ol><li>image list: 输出当前进程所依赖的共享库</li><li>image list -o -f: 上个命令简洁版，输出相关库的 ASLR 地址(o: offset)</li><li>image lookup -n xxx: 输出 xxx 符号的相关信息</li><li>image lookup -t xxx: 输出 xxx 符号的类型</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(lldb) image lookup -n NSLog</span><br><span class="line">1 match found in &#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Platforms&#x2F;iPhoneOS.platform&#x2F;Library&#x2F;Developer&#x2F;CoreSimulator&#x2F;Profiles&#x2F;Runtimes&#x2F;iOS.simruntime&#x2F;Contents&#x2F;Resources&#x2F;RuntimeRoot&#x2F;System&#x2F;Library&#x2F;Frameworks&#x2F;Foundation.framework&#x2F;Foundation:</span><br><span class="line">        Address: Foundation[0x00000000000f7762] (Foundation.__TEXT.__text + 1006242)</span><br><span class="line">        Summary: Foundation&#96;NSLog</span><br><span class="line"></span><br><span class="line">(lldb) image lookup -t FBBlockStrongRelationDetector</span><br><span class="line">0 match found in &#x2F;Users&#x2F;joakim&#x2F;Library&#x2F;Developer&#x2F;Xcode&#x2F;DerivedData&#x2F;Demo_fishhook-ebwkhxbcogafxbclcdeifrppsgdu&#x2F;Build&#x2F;Products&#x2F;Debug-iphonesimulator&#x2F;Demo_fishhook.app&#x2F;Demo_fishhook:</span><br><span class="line">id &#x3D; &#123;0x00071c41&#125;, name &#x3D; &quot;FBBlockStrongRelationDetector&quot;, byte-size &#x3D; 176, decl &#x3D; FBBlockStrongRelationDetector.h:23, compiler_type &#x3D; &quot;@interface FBBlockStrongRelationDetector : NSObject&#123;</span><br><span class="line">    void * forwarding;</span><br><span class="line">    int flags;</span><br><span class="line">    int size;</span><br><span class="line">    void (*)(_block_byref_block *, _block_byref_block *) byref_keep;</span><br><span class="line">    void (*)(_block_byref_block *) byref_dispose;</span><br><span class="line">    void *[16] captured;</span><br><span class="line">    BOOL _strong;</span><br><span class="line">&#125;</span><br><span class="line">@property(nonatomic, assign, readwrite, getter &#x3D; isStrong, setter &#x3D; setStrong:) BOOL strong;</span><br><span class="line">@end&quot;</span><br></pre></td></tr></table></figure><h2 id="antifishhook"><a href="#antifishhook" class="headerlink" title="antifishhook"></a>antifishhook</h2><p>从前面可知 <a href="https://github.com/facebook/fishhook">fishhook</a> 的原理就是修改相关 Section <code>__DATA,__nl_symbol_ptr/__got/__la_symbol_ptr</code> 下对应符号的指向。<br>Q: 那怎么防止 fishhook 呢？<br>A: 那在改回去呗，找到最初始的符号指向，即<br><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/fishhook/20220923124046.png"><br>然后通过 fishhook 再替换一波，使得调用 <code>NSLog</code> 的时候走 <code>__stub_helper</code> 的逻辑。<br>具体实现可参考 <a href="https://tannerjin.github.io/2019/09/25/AntiHook/">AntiHook</a>，代码是用 Swift 实现的，值得一看。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://book.douban.com/subject/3652388/">程序员的自我修养–链接、装载与库</a></li><li><a href="https://github.com/facebook/fishhook">fishhook</a></li><li><a href="https://sourceforge.net/projects/machoview/">MachOView</a></li><li><a href="https://zhang759740844.github.io/2019/07/07/fishhook/">fishhook 源码解析</a></li><li><a href="https://developer.apple.com/library/archive/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/lldb-command-examples.html#//apple_ref/doc/uid/TP40012917-CH3-SW5">LLDB Quick Start Guide</a></li><li><a href="https://tannerjin.github.io/2019/09/25/AntiHook/">AntiHook</a></li><li><a href="https://www.asciitable.com/">asciitable</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近把《&lt;a href=&quot;https://book.douban.com/subject/3652388/&quot;&gt;程序员的自我修养–链接、装载与库&lt;/a&gt;》这本书又重新温习了下，加深了对可执行文件的理解，这篇文章就结合 &lt;a href=&quot;https://github.com/f
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS Flutter Main runApp</title>
    <link href="http://example.com/2021/04/09/flutter-main-runApp/"/>
    <id>http://example.com/2021/04/09/flutter-main-runApp/</id>
    <published>2021-04-09T10:15:05.000Z</published>
    <updated>2021-05-31T14:03:40.883Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>使用下面 demo 来探究 main 函数干了啥。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// 见 [2.1]</span></span><br><span class="line">  runApp(</span><br><span class="line">    materialApp(),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _MyAppState createState() =&gt; _MyAppState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyAppState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyApp</span>&gt; </span>&#123;</span><br><span class="line">    Widget build(BuildContext context) &#123;</span><br><span class="line">        <span class="keyword">return</span> Container();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        // 因为 MaterialApp 里面的逻辑比较多，所以直接上 Container.</span></span><br><span class="line"><span class="comment">        return MaterialApp(home: Container(),);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-启动流程"><a href="#2-启动流程" class="headerlink" title="2. 启动流程"></a>2. 启动流程</h1><p>调试堆栈如下</p><p><img src="https://sat02pap001files.storage.live.com/y4m87hRH1uo3ATjkTReKsStkU1r_iq_9l6gH1KZllL1didR5PF6jQ2eCN87_h45A2rWRMwC4zeigiNRm-_ey3jiSNCtHkHiMb-7jlhM_q6UXec8l1uVyvSEbHKzvLLtUaxFVM8Q_5Ti9paHc40DDrHDfrdRh0w23Cpj0uaMaNhoCgiEWZyvpJ5cVP8UMlw1SzKX?width=2494&height=818&cropmode=none" alt="-w1247"></p><h2 id="2-1-runApp"><a href="#2-1-runApp" class="headerlink" title="2.1 runApp"></a>2.1 runApp</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scr/widgets/binding.dart</span></span><br><span class="line"><span class="keyword">void</span> runApp(Widget app) &#123;</span><br><span class="line">  WidgetsFlutterBinding.ensureInitialized() <span class="comment">// 见 [2.2]</span></span><br><span class="line">    ..scheduleAttachRootWidget(app) <span class="comment">// 见 [2.4]</span></span><br><span class="line">    ..scheduleWarmUpFrame(); <span class="comment">// 见 [2.10]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-ensureInitialized"><a href="#2-2-ensureInitialized" class="headerlink" title="2.2 ensureInitialized"></a>2.2 ensureInitialized</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scr/widgets/binding.dart</span></span><br><span class="line"><span class="comment">/// <span class="markdown">A concrete binding for applications based on the Widgets framework.</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="markdown">This is the glue that binds the framework to the Flutter engine.</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetsFlutterBinding</span> <span class="keyword">extends</span> <span class="title">BindingBase</span> <span class="title">with</span> <span class="title">GestureBinding</span>, <span class="title">SchedulerBinding</span>, <span class="title">ServicesBinding</span>, <span class="title">PaintingBinding</span>, <span class="title">SemanticsBinding</span>, <span class="title">RendererBinding</span>, <span class="title">WidgetsBinding</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> WidgetsBinding ensureInitialized() &#123;</span><br><span class="line">    <span class="keyword">if</span> (WidgetsBinding.instance == <span class="keyword">null</span>)</span><br><span class="line">      WidgetsFlutterBinding(); <span class="comment">// 见 [2.2.1]</span></span><br><span class="line">    <span class="keyword">return</span> WidgetsBinding.instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-1-BindingBase-初始化"><a href="#2-2-1-BindingBase-初始化" class="headerlink" title="2.2.1 BindingBase 初始化"></a>2.2.1 BindingBase 初始化</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BindingBase() &#123;</span><br><span class="line">    <span class="comment">// 见 [2.3]</span></span><br><span class="line">    initInstances();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    initServiceExtensions();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-initInstances"><a href="#2-3-initInstances" class="headerlink" title="2.3 initInstances"></a>2.3 initInstances</h2><p><code>initInstances</code> 方法的调用顺序是从右到左的，即 </p><ol><li>WidgetsBinding: The glue between the widgets layer and the Flutter engine.</li><li>RendererBinding: The glue between the render tree and the Flutter engine.</li><li>SemanticsBinding: The glue between the semantics layer and the Flutter engine.</li><li>PaintingBinding: Binding for the painting library.</li><li>ServicesBinding: Listens for platform messages and directs them to the [defaultBinaryMessenger].</li><li>SchedulerBinding: Scheduler for running the following: xxx.</li><li>GestureBinding: A binding for the gesture subsystem.</li></ol><p>按照上面的顺序执行完 <code>initInstances</code> 中的 <code>super.initInstances()</code>, 再按照上面的逆序执行各个 <code>Binding</code> 类 <code>initInstances</code> 中剩余逻辑，然后执行 <code>initServiceExtensions</code>。</p><h3 id="2-3-1-GestureBinding"><a href="#2-3-1-GestureBinding" class="headerlink" title="2.3.1 GestureBinding"></a>2.3.1 GestureBinding</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scr/gestures/binding.dart</span></span><br><span class="line"><span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initInstances();</span><br><span class="line">    _instance = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 设置 window 的 `onPointerDataPacket` 回调方法，在该回调方法中处理手势等交互逻辑。</span></span><br><span class="line">    <span class="built_in">window</span>.onPointerDataPacket = _handlePointerDataPacket;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-2-SchedulerBinding"><a href="#2-3-2-SchedulerBinding" class="headerlink" title="2.3.2 SchedulerBinding"></a>2.3.2 SchedulerBinding</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scr/scheduler/binding.dart</span></span><br><span class="line"><span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initInstances();</span><br><span class="line">    _instance = <span class="keyword">this</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 非 `kReleaseMode` 模式下，添加 `addTimingsCallback` 回调，用来记录 frame 等相关信息。</span></span><br><span class="line">    <span class="keyword">if</span> (!kReleaseMode) &#123;</span><br><span class="line">      <span class="built_in">int</span> frameNumber = <span class="number">0</span>;</span><br><span class="line">      addTimingsCallback((<span class="built_in">List</span>&lt;FrameTiming&gt; timings) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> FrameTiming frameTiming <span class="keyword">in</span> timings) &#123;</span><br><span class="line">          frameNumber += <span class="number">1</span>;</span><br><span class="line">          _profileFramePostEvent(frameNumber, frameTiming);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-3-ServicesBinding"><a href="#2-3-3-ServicesBinding" class="headerlink" title="2.3.3 ServicesBinding"></a>2.3.3 ServicesBinding</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scr/services/binding.dart</span></span><br><span class="line"><span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initInstances();</span><br><span class="line">    _instance = <span class="keyword">this</span>;</span><br><span class="line">    _defaultBinaryMessenger = createBinaryMessenger();</span><br><span class="line">    _restorationManager = createRestorationManager();</span><br><span class="line">    <span class="built_in">window</span>.onPlatformMessage = defaultBinaryMessenger.handlePlatformMessage;</span><br><span class="line">    initLicenses();</span><br><span class="line">    SystemChannels.system.setMessageHandler((<span class="built_in">dynamic</span> message) =&gt; handleSystemMessage(message <span class="keyword">as</span> <span class="built_in">Object</span>));</span><br><span class="line">    SystemChannels.lifecycle.setMessageHandler(_handleLifecycleMessage);</span><br><span class="line">    readInitialLifecycleStateFromNativeWindow();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>创建 <code>_defaultBinaryMessenger</code>，用来处理 platform channel 消息，<a href="http://joakimliu.github.io/2021/04/07/flutter-source-code-ios-platform-channels/">iOS Flutter Platform Channel</a> 有讲到。</p><h3 id="2-3-4-PaintingBinding"><a href="#2-3-4-PaintingBinding" class="headerlink" title="2.3.4 PaintingBinding"></a>2.3.4 PaintingBinding</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scr/painting/binding.dart</span></span><br><span class="line"><span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initInstances();</span><br><span class="line">    _instance = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 创建 image chache.</span></span><br><span class="line">    _imageCache = createImageCache();</span><br><span class="line">    shaderWarmUp?.execute();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-5-SemanticsBinding"><a href="#2-3-5-SemanticsBinding" class="headerlink" title="2.3.5 SemanticsBinding"></a>2.3.5 SemanticsBinding</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scr/semantics/binding.dart</span></span><br><span class="line"><span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initInstances();</span><br><span class="line">    _instance = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 给 _accessibilityFeatures 赋值</span></span><br><span class="line">    _accessibilityFeatures = <span class="built_in">window</span>.accessibilityFeatures;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-6-RendererBinding"><a href="#2-3-6-RendererBinding" class="headerlink" title="2.3.6 RendererBinding"></a>2.3.6 RendererBinding</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scr/rendering/binding.dart</span></span><br><span class="line"><span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initInstances();</span><br><span class="line">    _instance = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 见 [2.3.6.1]</span></span><br><span class="line">    _pipelineOwner = PipelineOwner(</span><br><span class="line">      onNeedVisualUpdate: ensureVisualUpdate,</span><br><span class="line">      onSemanticsOwnerCreated: _handleSemanticsOwnerCreated,</span><br><span class="line">      onSemanticsOwnerDisposed: _handleSemanticsOwnerDisposed,</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 设置 window 的相关回调</span></span><br><span class="line">    <span class="built_in">window</span></span><br><span class="line">      ..onMetricsChanged = handleMetricsChanged</span><br><span class="line">      ..onTextScaleFactorChanged = handleTextScaleFactorChanged</span><br><span class="line">      ..onPlatformBrightnessChanged = handlePlatformBrightnessChanged</span><br><span class="line">      ..onSemanticsEnabledChanged = _handleSemanticsEnabledChanged</span><br><span class="line">      ..onSemanticsAction = _handleSemanticsAction;</span><br><span class="line">    <span class="comment">// 见 [2.3.6.2] </span></span><br><span class="line">    initRenderView();</span><br><span class="line">    _handleSemanticsEnabledChanged();</span><br><span class="line">    <span class="keyword">assert</span>(renderView != <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 添加 addPersistentFrameCallback 回调</span></span><br><span class="line">    addPersistentFrameCallback(_handlePersistentFrameCallback);</span><br><span class="line">    initMouseTracker();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-6-1-PipelineOwner-初始化"><a href="#2-3-6-1-PipelineOwner-初始化" class="headerlink" title="2.3.6.1 PipelineOwner 初始化"></a>2.3.6.1 PipelineOwner 初始化</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The pipeline owner manages the rendering pipeline.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PipelineOwner</span> </span>&#123;</span><br><span class="line">    PipelineOwner(&#123;</span><br><span class="line">        <span class="keyword">this</span>.onNeedVisualUpdate,</span><br><span class="line">        <span class="keyword">this</span>.onSemanticsOwnerCreated,</span><br><span class="line">        <span class="keyword">this</span>.onSemanticsOwnerDisposed,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用来管理 rendering pipeline 的类，在 rendering pipeline 过程中，会按序执行以下方法(这几个阶段的操作对象都是 <code>render objects</code>)</p><ol><li>flushLayout</li><li>flushCompositingBits</li><li>flushPaint</li><li>flushSemantics</li></ol><h4 id="2-3-6-2-initRenderView"><a href="#2-3-6-2-initRenderView" class="headerlink" title="2.3.6.2 initRenderView"></a>2.3.6.2 initRenderView</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> initRenderView() &#123;</span><br><span class="line">    <span class="keyword">assert</span>(!_debugIsRenderViewInitialized);</span><br><span class="line">    <span class="keyword">assert</span>(() &#123;</span><br><span class="line">      _debugIsRenderViewInitialized = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;());</span><br><span class="line">    <span class="comment">// 创建 RenderView 对象，并赋值给 renderView, 见 [2.3.6.3]</span></span><br><span class="line">    renderView = RenderView(configuration: createViewConfiguration(), <span class="built_in">window</span>: <span class="built_in">window</span>);</span><br><span class="line">    <span class="comment">// 准备首帧</span></span><br><span class="line">    renderView.prepareInitialFrame();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-6-3-set-renderView"><a href="#2-3-6-3-set-renderView" class="headerlink" title="2.3.6.3 set renderView"></a>2.3.6.3 set renderView</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The root of the render tree.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderView</span> <span class="keyword">extends</span> <span class="title">RenderObject</span> <span class="title">with</span> <span class="title">RenderObjectWithChildMixin</span>&lt;<span class="title">RenderBox</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">set</span> renderView(RenderView value) &#123;</span><br><span class="line">        <span class="keyword">assert</span>(value != <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 见 [2.3.6.4]</span></span><br><span class="line">        _pipelineOwner.rootNode = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-6-4-set-rootNode"><a href="#2-3-6-4-set-rootNode" class="headerlink" title="2.3.6.4 set rootNode"></a>2.3.6.4 set rootNode</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PipelineOwner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">set</span> rootNode(AbstractNode? value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_rootNode == value)</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        _rootNode?.detach();</span><br><span class="line">        _rootNode = value;</span><br><span class="line">        _rootNode?.attach(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractNode</span> </span>&#123;</span><br><span class="line">    <span class="meta">@mustCallSuper</span></span><br><span class="line">    <span class="keyword">void</span> detach() &#123;</span><br><span class="line">        <span class="keyword">assert</span>(_owner != <span class="keyword">null</span>);</span><br><span class="line">        _owner = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">assert</span>(parent == <span class="keyword">null</span> || attached == parent!.attached);</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@mustCallSuper</span></span><br><span class="line">    <span class="keyword">void</span> attach(<span class="keyword">covariant</span> <span class="built_in">Object</span> owner) &#123;</span><br><span class="line">        <span class="keyword">assert</span>(owner != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">assert</span>(_owner == <span class="keyword">null</span>);</span><br><span class="line">        _owner = owner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_owner 和 _rootNode 的赋值。</p><ul><li>将 RenderView 对象赋值给 _pipelineOwner 的 rootNode 成员变量</li><li>将 _pipelineOwner 赋值给 RenderView 对象的 _owner 成员变量</li></ul><h3 id="2-3-7-WidgetsBinding"><a href="#2-3-7-WidgetsBinding" class="headerlink" title="2.3.7 WidgetsBinding"></a>2.3.7 WidgetsBinding</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scr/widgets/binding.dart</span></span><br><span class="line"><span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initInstances();</span><br><span class="line">    _instance = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// Initialization of [_buildOwner] has to be done after</span></span><br><span class="line">    <span class="comment">// [super.initInstances] is called, as it requires [ServicesBinding] to</span></span><br><span class="line">    <span class="comment">// properly setup the [defaultBinaryMessenger] instance.</span></span><br><span class="line">    _buildOwner = BuildOwner(); <span class="comment">// 见 [2.3.7.1]</span></span><br><span class="line">    buildOwner.onBuildScheduled = _handleBuildScheduled;</span><br><span class="line">    <span class="built_in">window</span>.onLocaleChanged = handleLocaleChanged;</span><br><span class="line">    <span class="built_in">window</span>.onAccessibilityFeaturesChanged = handleAccessibilityFeaturesChanged;</span><br><span class="line">    SystemChannels.navigation.setMethodCallHandler(_handleNavigationInvocation);</span><br><span class="line">    FlutterErrorDetails.propertiesTransformers.add(transformDebugCreator);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-7-1-BuildOwner-初始化"><a href="#2-3-7-1-BuildOwner-初始化" class="headerlink" title="2.3.7.1 BuildOwner 初始化"></a>2.3.7.1 BuildOwner 初始化</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scr/widgets/framework.dart</span></span><br><span class="line"><span class="comment">/// <span class="markdown">Manager class for the widgets framework.</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuildOwner</span> </span>&#123;</span><br><span class="line">    BuildOwner(&#123; <span class="keyword">this</span>.onBuildScheduled &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-scheduleAttachRootWidget"><a href="#2-4-scheduleAttachRootWidget" class="headerlink" title="2.4 scheduleAttachRootWidget"></a>2.4 scheduleAttachRootWidget</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> scheduleAttachRootWidget(Widget rootWidget) &#123;</span><br><span class="line">    <span class="comment">// 异步执行</span></span><br><span class="line">    Timer.run(() &#123;</span><br><span class="line">      <span class="comment">// 见 [2.4.1]</span></span><br><span class="line">      attachRootWidget(rootWidget);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-1-attachRootWidget"><a href="#2-4-1-attachRootWidget" class="headerlink" title="2.4.1 attachRootWidget"></a>2.4.1 attachRootWidget</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> attachRootWidget(Widget rootWidget) &#123;</span><br><span class="line">    _readyToProduceFrames = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 见 [2.4.2]</span></span><br><span class="line">    _renderViewElement = RenderObjectToWidgetAdapter&lt;RenderBox&gt;(</span><br><span class="line">      container: renderView, </span><br><span class="line">      debugShortDescription: <span class="string">&#x27;[root]&#x27;</span>, <span class="comment">// debug 描述信息</span></span><br><span class="line">      child: rootWidget,  </span><br><span class="line">    ).attachToRenderTree(buildOwner, renderViewElement <span class="keyword">as</span> RenderObjectToWidgetElement&lt;RenderBox&gt;); <span class="comment">// 见 [2.5]</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>该方法的主要参数</p><ul><li>renderView: 见 [2.3.6.2]</li><li>rootWidget: 见 [1] 中的 demo, materialApp widget, 就是我们的 root widget</li><li>buildOwner: 见 [2.3.7.1]</li><li>_renderViewElement: 执行 attachToRenderTree 方法后，返回的 Element 类型的对象，可通过 <code>WidgetsBinding.renderViewElement</code> 获取，是 Element tree 的根节点(通过注释 <code>The [Element] that is at the root of the hierarchy (and which wraps the [RenderView] object at the root of the rendering hierarchy).</code>)。</li></ul><h3 id="2-4-2-RenderObjectToWidgetAdapter-初始化"><a href="#2-4-2-RenderObjectToWidgetAdapter-初始化" class="headerlink" title="2.4.2 RenderObjectToWidgetAdapter 初始化"></a>2.4.2 RenderObjectToWidgetAdapter 初始化</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A bridge from a [RenderObject] to an [Element] tree.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderObjectToWidgetAdapter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">RenderObject</span>&gt; <span class="keyword">extends</span> <span class="title">RenderObjectWidget</span> </span>&#123;</span><br><span class="line">    RenderObjectToWidgetAdapter(&#123;</span><br><span class="line">    <span class="keyword">this</span>.child, <span class="comment">// widget tree 中的对象</span></span><br><span class="line">    <span class="keyword">this</span>.container, <span class="comment">// The [RenderObject] that is the parent of the [Element] created by this widget.</span></span><br><span class="line">    <span class="keyword">this</span>.debugShortDescription,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(key: GlobalObjectKey(container));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RenderObjectToWidgetAdapter 是一个从 <code>[RenderObject]</code>(root of render tree) 到 <code>[Element]</code>(root of element tree) 的桥接类，该类的主要方法有</p><ul><li>createElement: 返回 RenderObjectToWidgetElement 对象, 见 [2.5.1]</li><li>createRenderObject: 返回 [2.3.6.2] 的 renderView, 见 [2.7]</li><li>attachToRenderTree: 创建 element, 见 [2.5]</li></ul><h2 id="2-5-attachToRenderTree"><a href="#2-5-attachToRenderTree" class="headerlink" title="2.5 attachToRenderTree"></a>2.5 attachToRenderTree</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">RenderObjectToWidgetElement&lt;T&gt; attachToRenderTree(BuildOwner owner, [ RenderObjectToWidgetElement&lt;T&gt; element ]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (element == <span class="keyword">null</span>) &#123;</span><br><span class="line">      owner.lockState(() &#123;</span><br><span class="line">        <span class="comment">// 见 [2.5.1]</span></span><br><span class="line">        element = createElement();</span><br><span class="line">        <span class="keyword">assert</span>(element != <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 见 [2.5.2]</span></span><br><span class="line">        element.assignOwner(owner);</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 见 [2.5.3]</span></span><br><span class="line">      owner.buildScope(element, () &#123;</span><br><span class="line">        <span class="comment">// 见 [2.5.4]</span></span><br><span class="line">        element.mount(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">      SchedulerBinding.instance.ensureVisualUpdate();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element._newWidget = <span class="keyword">this</span>;</span><br><span class="line">      element.markNeedsBuild();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>首次调用 attachToRenderTree 方法时，入参 element 为空，会创建 element 对象(RenderObjectToWidgetElement 类型)，然后赋值给 [2.4.1] 的 <code>_renderViewElement</code> 成员变量。 </p><h3 id="2-5-1-createElement"><a href="#2-5-1-createElement" class="headerlink" title="2.5.1 createElement"></a>2.5.1 createElement</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RenderObjectToWidgetAdapter(&#123;</span><br><span class="line">    <span class="keyword">this</span>.child,</span><br><span class="line">    <span class="keyword">this</span>.container,</span><br><span class="line">    <span class="keyword">this</span>.debugShortDescription,</span><br><span class="line">&#125;) : <span class="keyword">super</span>(key: GlobalObjectKey(container));</span><br><span class="line">  </span><br><span class="line">RenderObjectToWidgetElement&lt;T&gt; createElement() =&gt; RenderObjectToWidgetElement&lt;T&gt;(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>返回 RenderObjectToWidgetElement 类型的对象。</p><h3 id="2-5-2-assignOwner"><a href="#2-5-2-assignOwner" class="headerlink" title="2.5.2 assignOwner"></a>2.5.2 assignOwner</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The element at the root of the tree.</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RootRenderObjectElement</span> <span class="keyword">extends</span> <span class="title">RenderObjectElement</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> assignOwner(BuildOwner owner) &#123;</span><br><span class="line">        _owner = owner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟 [2.3.6.4] 类似，都是将 <code>_pipelineOwner</code> 赋值给 <code>_owner</code> 成员变量，<code>_pipelineOwner</code> 不亏是一个管理类。</p><h3 id="2-5-3-buildScope"><a href="#2-5-3-buildScope" class="headerlink" title="2.5.3 buildScope"></a>2.5.3 buildScope</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> buildScope(<span class="built_in">Element</span> context, [ VoidCallback callback ]) &#123;</span><br><span class="line">  <span class="keyword">if</span> (callback == <span class="keyword">null</span> &amp;&amp; _dirtyElements.isEmpty)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// ...  </span></span><br><span class="line">  Timeline.startSync(<span class="string">&#x27;Build&#x27;</span>, arguments: timelineArgumentsIndicatingLandmarkEvent);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    _scheduledFlushDirtyElements = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      _dirtyElementsNeedsResorting = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        callback(); <span class="comment">// 见 [2.5.4]</span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对脏 elements 进行排序</span></span><br><span class="line">    _dirtyElements.sort(<span class="built_in">Element</span>._sort);</span><br><span class="line">    _dirtyElementsNeedsResorting = <span class="keyword">false</span>;</span><br><span class="line">    <span class="built_in">int</span> dirtyCount = _dirtyElements.length;</span><br><span class="line">    <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; dirtyCount) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行脏 element 的 rebuild 方法</span></span><br><span class="line">        _dirtyElements[index].rebuild();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">      index += <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (dirtyCount &lt; _dirtyElements.length || _dirtyElementsNeedsResorting) &#123;</span><br><span class="line">        _dirtyElements.sort(<span class="built_in">Element</span>._sort);</span><br><span class="line">        _dirtyElementsNeedsResorting = <span class="keyword">false</span>;</span><br><span class="line">        dirtyCount = _dirtyElements.length;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span> &amp;&amp; _dirtyElements[index - <span class="number">1</span>].dirty) &#123;</span><br><span class="line">          index -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-4-RenderObjectToWidgetElement-mount"><a href="#2-5-4-RenderObjectToWidgetElement-mount" class="headerlink" title="2.5.4 RenderObjectToWidgetElement.mount"></a>2.5.4 RenderObjectToWidgetElement.mount</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="built_in">dynamic</span> newSlot) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(parent == <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 见 [2.5.4.1]</span></span><br><span class="line">    <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">    <span class="comment">// 见 [2.9]</span></span><br><span class="line">    _rebuild();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>因为 RenderObjectToWidgetElement 对象是 element tree 的根节点，所以这里 parent 为 null.</p><h4 id="2-5-4-1-RootRenderObjectElement-mount"><a href="#2-5-4-1-RootRenderObjectElement-mount" class="headerlink" title="2.5.4.1 RootRenderObjectElement.mount"></a>2.5.4.1 RootRenderObjectElement.mount</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="built_in">dynamic</span> newSlot) &#123;</span><br><span class="line">    <span class="comment">// Root elements should never have parents.</span></span><br><span class="line">    <span class="keyword">assert</span>(parent == <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">assert</span>(newSlot == <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 见 [2.5.4.2]</span></span><br><span class="line">    <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-4-2-RenderObjectElement-mount"><a href="#2-5-4-2-RenderObjectElement-mount" class="headerlink" title="2.5.4.2 RenderObjectElement.mount"></a>2.5.4.2 RenderObjectElement.mount</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="built_in">dynamic</span> newSlot) &#123;</span><br><span class="line">  <span class="comment">// 见 [2.5.4.3]</span></span><br><span class="line">  <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 见 [2.7]</span></span><br><span class="line">  _renderObject = widget.createRenderObject(<span class="keyword">this</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 见 [2.8]</span></span><br><span class="line">  attachRenderObject(newSlot);</span><br><span class="line">  _dirty = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-4-3-Element-mount"><a href="#2-5-4-3-Element-mount" class="headerlink" title="2.5.4.3 Element.mount"></a>2.5.4.3 Element.mount</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Element</span>(Widget widget)</span><br><span class="line">    : <span class="keyword">assert</span>(widget != <span class="keyword">null</span>),</span><br><span class="line">      _widget = widget;</span><br><span class="line">      </span><br><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="built_in">dynamic</span> newSlot) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 父 element</span></span><br><span class="line">  _parent = parent;</span><br><span class="line">  <span class="comment">// 当前 element 的 slot</span></span><br><span class="line">  _slot = newSlot;</span><br><span class="line">  <span class="comment">// root element 的 _depth 为 1，子 element 依次 +1</span></span><br><span class="line">  _depth = _parent != <span class="keyword">null</span> ? _parent.depth + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 处于激活状态</span></span><br><span class="line">  _active = <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">// 只用 parent 的 _owner, 也就是说所有 element tree 的上节点公用一个 _owner</span></span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="keyword">null</span>) <span class="comment">// Only assign ownership if the parent is non-null</span></span><br><span class="line">    _owner = parent.owner;</span><br><span class="line">  <span class="comment">// widget 是构造方法中赋值的，也就是 [2.5.1] 中的 RenderObjectToWidgetAdapter, 所以 key 就是 [2.5.1] 中的 GlobalObjectKey(container), 见 [2.6]</span></span><br><span class="line">  <span class="keyword">final</span> Key key = widget.key;</span><br><span class="line">  <span class="keyword">if</span> (key <span class="keyword">is</span> GlobalKey) &#123;</span><br><span class="line">    <span class="comment">// 见 [2.6]</span></span><br><span class="line">    key._register(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  _updateInheritance();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-6-GlobalKey-register"><a href="#2-6-GlobalKey-register" class="headerlink" title="2.6 GlobalKey._register"></a>2.6 GlobalKey._register</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/widgets/framework.dart</span></span><br><span class="line"><span class="meta">@optionalTypeArgs</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalKey</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">StatefulWidget</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">Key</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> GlobalKey.constructor() : <span class="keyword">super</span>.empty();</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">Map</span>&lt;GlobalKey, <span class="built_in">Element</span>&gt; _registry = &lt;GlobalKey, <span class="built_in">Element</span>&gt;&#123;&#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将当前 Key 对象和 Element 对象关联起来，this 就是当前 key 对象</span></span><br><span class="line">  <span class="keyword">void</span> _register(<span class="built_in">Element</span> element) &#123;</span><br><span class="line">    _registry[<span class="keyword">this</span>] = element;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _unregister(<span class="built_in">Element</span> element) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_registry[<span class="keyword">this</span>] == element)</span><br><span class="line">      _registry.remove(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由 [2.5.4.3] 可知，这里是 GlobalObjectKey 类型的对象。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/widgets/framework.dart</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GlobalObjectKey</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">StatefulWidget</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">GlobalKey</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">Creates a global key that uses [identical] on [value] for its [operator==].</span></span></span><br><span class="line">  <span class="keyword">const</span> GlobalObjectKey(<span class="keyword">this</span>.value) : <span class="keyword">super</span>.constructor();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">The object whose identity is used by this key&#x27;s [operator==].</span></span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Object</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">operator</span> ==(<span class="built_in">Object</span> other) &#123;</span><br><span class="line">    <span class="keyword">if</span> (other.runtimeType != runtimeType)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> other <span class="keyword">is</span> GlobalObjectKey&lt;T&gt;</span><br><span class="line">        &amp;&amp; identical(other.value, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> hashCode =&gt; identityHashCode(value);</span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由 [2.5.1] 可知，value 就是 [2.3.3.2] 的 renderView 对象，说明 GlobalObjectKey 是用来处理 render tree 和 element tree 之间的节点关系。</p><h2 id="2-7-createRenderObject"><a href="#2-7-createRenderObject" class="headerlink" title="2.7 createRenderObject"></a>2.7 createRenderObject</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RenderObjectWithChildMixin&lt;T&gt; createRenderObject(BuildContext context) =&gt; container;</span><br></pre></td></tr></table></figure><p>将 [2.3.6.2] 的 renderView 对象赋值给 <code>_renderObject</code> 。</p><h2 id="2-8-attachRenderObject"><a href="#2-8-attachRenderObject" class="headerlink" title="2.8 attachRenderObject"></a>2.8 attachRenderObject</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> attachRenderObject(<span class="built_in">dynamic</span> newSlot) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(_ancestorRenderObjectElement == <span class="keyword">null</span>);</span><br><span class="line">    _slot = newSlot;</span><br><span class="line">    <span class="comment">// 选择此 element tree 的祖先节点，此时为 null.</span></span><br><span class="line">    _ancestorRenderObjectElement = _findAncestorRenderObjectElement();</span><br><span class="line">    <span class="comment">// 向 element 树中插入刚刚创建的 renderObject</span></span><br><span class="line">    _ancestorRenderObjectElement?.insertRenderObjectChild(renderObject, newSlot);</span><br><span class="line">    <span class="keyword">final</span> ParentDataElement&lt;ParentData&gt; parentDataElement = _findAncestorParentDataElement();</span><br><span class="line">    <span class="keyword">if</span> (parentDataElement != <span class="keyword">null</span>)</span><br><span class="line">      _updateParentData(parentDataElement.widget);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>此时 newSlot _ancestorRenderObjectElement _slot 均为 null, 同上，后面的 _ancestorRenderObjectElement parentDataElement 也为 null.</p><h2 id="2-9-rebuild"><a href="#2-9-rebuild" class="headerlink" title="2.9 _rebuild"></a>2.9 _rebuild</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _rebuild() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 见 [2.9.1]</span></span><br><span class="line">    _child = updateChild(_child, widget.child, _rootChildSlot);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (exception, stack) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的相关入参</p><ul><li>_child: 第一次执行，_child 为 null</li><li>widget.child: widget: RenderObjectToWidgetAdapter 对象，所以 widget.child 就是 [2.4.1] 中我们在 main.dart 中自定义的 root widget</li><li>_rootChildSlot: <code>static const Object _rootChildSlot = Object();</code> 是一个常量，表示一个 element 只有一个 child</li></ul><h3 id="2-9-1-Element-updateChild"><a href="#2-9-1-Element-updateChild" class="headerlink" title="2.9.1 Element.updateChild"></a>2.9.1 Element.updateChild</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Element</span> updateChild(<span class="built_in">Element</span> child, Widget newWidget, <span class="built_in">dynamic</span> newSlot) &#123;</span><br><span class="line">  <span class="keyword">if</span> (newWidget == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (child != <span class="keyword">null</span>)</span><br><span class="line">      <span class="comment">// 移除旧的 element</span></span><br><span class="line">      deactivateChild(child);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Element</span> newChild;</span><br><span class="line">  <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="built_in">bool</span> hasSameSuperclass = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (hasSameSuperclass &amp;&amp; child.widget == newWidget) &#123;</span><br><span class="line">      <span class="keyword">if</span> (child.slot != newSlot)</span><br><span class="line">        <span class="comment">// 更新 element</span></span><br><span class="line">        updateSlotForChild(child, newSlot);</span><br><span class="line">      newChild = child;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasSameSuperclass &amp;&amp; Widget.canUpdate(child.widget, newWidget)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (child.slot != newSlot)</span><br><span class="line">        <span class="comment">// 更新 element</span></span><br><span class="line">        updateSlotForChild(child, newSlot);</span><br><span class="line">      <span class="comment">// 更新 widget  </span></span><br><span class="line">      child.update(newWidget);</span><br><span class="line">      newChild = child;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      newChild = inflateWidget(newWidget, newSlot);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 见 [2.9.2]</span></span><br><span class="line">    newChild = inflateWidget(newWidget, newSlot);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-9-2-Element-inflateWidget"><a href="#2-9-2-Element-inflateWidget" class="headerlink" title="2.9.2 Element.inflateWidget"></a>2.9.2 Element.inflateWidget</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Element</span> inflateWidget(Widget newWidget, <span class="built_in">dynamic</span> newSlot) &#123;</span><br><span class="line">  <span class="keyword">final</span> Key key = newWidget.key;</span><br><span class="line">  <span class="keyword">if</span> (key <span class="keyword">is</span> GlobalKey) &#123;</span><br><span class="line">    <span class="comment">// 从 _inactiveElements 中找可复用的 element</span></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">Element</span> newChild = _retakeInactiveElement(key, newWidget);</span><br><span class="line">    <span class="keyword">if</span> (newChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 激活</span></span><br><span class="line">      newChild._activateWithParent(<span class="keyword">this</span>, newSlot);</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">Element</span> updatedChild = updateChild(newChild, newWidget, newSlot);</span><br><span class="line">      <span class="keyword">return</span> updatedChild;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建 element, 见 [2.9.3], 这里是 StatefulElement</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Element</span> newChild = newWidget.createElement();</span><br><span class="line">  <span class="comment">// 见 [2.9.4]</span></span><br><span class="line">  newChild.mount(<span class="keyword">this</span>, newSlot);</span><br><span class="line">  <span class="keyword">return</span> newChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 key 为 null.</p><h3 id="2-9-3-createElement"><a href="#2-9-3-createElement" class="headerlink" title="2.9.3 createElement"></a>2.9.3 createElement</h3><p>这个的 root widget 是 StatefulWidget 类型，所以会走</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatefulElement</span> <span class="keyword">extends</span> <span class="title">ComponentElement</span> </span>&#123;</span><br><span class="line">    StatefulElement(StatefulWidget widget) : _state = widget.createState(), <span class="keyword">super</span>(widget) &#123;</span><br><span class="line">        _state._element = <span class="keyword">this</span>;</span><br><span class="line">        _state._widget = widget;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的方法主要功能</p><ul><li>对 _state 赋值</li><li>对 element 的 widget 赋值，见前面的 <code>2.5.4.3 Element.mount</code></li><li>对 _state._element 赋值</li><li>对 _state._widget 赋值</li></ul><p>由此看见， state 是一个桥接类，关联 element 和 widget.</p><h3 id="2-9-4-ComponentElement-mount"><a href="#2-9-4-ComponentElement-mount" class="headerlink" title="2.9.4 ComponentElement.mount"></a>2.9.4 ComponentElement.mount</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="built_in">dynamic</span> newSlot) &#123;</span><br><span class="line">    <span class="comment">// 见 [2.5.4.3], 不过这里 parent 有值，是 [2.5.4] 新建的 RenderObjectToWidgetElement(root element)</span></span><br><span class="line">    <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">    <span class="keyword">assert</span>(_child == <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">assert</span>(_active);</span><br><span class="line">    <span class="comment">// 见 [2.9.5]</span></span><br><span class="line">    _firstBuild();</span><br><span class="line">    <span class="keyword">assert</span>(_child != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StatefulElement extends ComponentElement extends Element,  ComponentElement 是跟 <code>2.5.4.2 RenderObjectElement</code> 是同级别的子类。</p><h3 id="2-9-5-ComponentElement-firstBuild"><a href="#2-9-5-ComponentElement-firstBuild" class="headerlink" title="2.9.5 ComponentElement._firstBuild"></a>2.9.5 ComponentElement._firstBuild</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _firstBuild() &#123;</span><br><span class="line">    <span class="comment">// 见 [2.9.5.1]</span></span><br><span class="line">    rebuild();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-9-5-1-Element-rebuild"><a href="#2-9-5-1-Element-rebuild" class="headerlink" title="2.9.5.1 Element.rebuild"></a>2.9.5.1 Element.rebuild</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> rebuild() &#123;</span><br><span class="line">    <span class="comment">// 未被激活(没调用 mount 方法) 或者 没被标脏(没调用相关 update 方法或者 markNeedsBuild 方法)，则不会走下面的逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (!_active || !_dirty)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 见 [2.9.5.2]  </span></span><br><span class="line">    performRebuild();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-9-5-2-StatefulElement-performRebuild"><a href="#2-9-5-2-StatefulElement-performRebuild" class="headerlink" title="2.9.5.2 StatefulElement.performRebuild"></a>2.9.5.2 StatefulElement.performRebuild</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> performRebuild() &#123;</span><br><span class="line">    <span class="comment">// 只有调用当前类的 didChangeDependencies 方法，才会将 _didChangeDependencies 置为 true</span></span><br><span class="line">    <span class="keyword">if</span> (_didChangeDependencies) &#123;</span><br><span class="line">      <span class="comment">// 调用 state didChangeDependencies 方法</span></span><br><span class="line">      _state.didChangeDependencies();</span><br><span class="line">      _didChangeDependencies = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 见 [2.9.5.3]</span></span><br><span class="line">    <span class="keyword">super</span>.performRebuild();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-9-5-3-ComponentElement-performRebuild"><a href="#2-9-5-3-ComponentElement-performRebuild" class="headerlink" title="2.9.5.3 ComponentElement.performRebuild"></a>2.9.5.3 ComponentElement.performRebuild</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> performRebuild() &#123;</span><br><span class="line">    Widget built;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 见 [2.9.5.4]</span></span><br><span class="line">        built = build();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 已 build, 后续不要再构建</span></span><br><span class="line">        _dirty = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 同 [2.9.1], 第一次 _child 为 null</span></span><br><span class="line">        _child = updateChild(_child, built, slot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-9-5-4-build"><a href="#2-9-5-4-build" class="headerlink" title="2.9.5.4 build"></a>2.9.5.4 build</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Widget build() =&gt; _state.build(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>自此，最终会调用 rootwidget, 即 _MyAppState 的 build 方法。</p><h2 id="2-10-scheduleWarmUpFrame"><a href="#2-10-scheduleWarmUpFrame" class="headerlink" title="2.10 scheduleWarmUpFrame"></a>2.10 scheduleWarmUpFrame</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> scheduleWarmUpFrame() &#123;</span><br><span class="line">  <span class="keyword">if</span> (_warmUpFrame || schedulerPhase != SchedulerPhase.idle)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  _warmUpFrame = <span class="keyword">true</span>;</span><br><span class="line">  Timeline.startSync(<span class="string">&#x27;Warm-up frame&#x27;</span>);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">bool</span> hadScheduledFrame = _hasScheduledFrame;</span><br><span class="line">  <span class="comment">// 异步执行, 执行完上面的代码才会执行 `2.4.1 attachRootWidget`</span></span><br><span class="line">  <span class="comment">// We use timers here to ensure that microtasks flush in between.</span></span><br><span class="line">  Timer.run(() &#123;</span><br><span class="line">    <span class="keyword">assert</span>(_warmUpFrame);</span><br><span class="line">    handleBeginFrame(<span class="keyword">null</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  Timer.run(() &#123;</span><br><span class="line">    <span class="keyword">assert</span>(_warmUpFrame);</span><br><span class="line">    handleDrawFrame();</span><br><span class="line">    <span class="comment">// We call resetEpoch after this frame so that, in the hot reload case,</span></span><br><span class="line">    <span class="comment">// the very next frame pretends to have occurred immediately after this</span></span><br><span class="line">    <span class="comment">// warm-up frame. The warm-up frame&#x27;s timestamp will typically be far in</span></span><br><span class="line">    <span class="comment">// the past (the time of the last real frame), so if we didn&#x27;t reset the</span></span><br><span class="line">    <span class="comment">// epoch we would see a sudden jump from the old time in the warm-up frame</span></span><br><span class="line">    <span class="comment">// to the new time in the &quot;real&quot; frame. The biggest problem with this is</span></span><br><span class="line">    <span class="comment">// that implicit animations end up being triggered at the old time and</span></span><br><span class="line">    <span class="comment">// then skipping every frame and finishing in the new time.</span></span><br><span class="line">    resetEpoch();</span><br><span class="line">    _warmUpFrame = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (hadScheduledFrame)</span><br><span class="line">      scheduleFrame();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Lock events so touch events etc don&#x27;t insert themselves until the</span></span><br><span class="line">  <span class="comment">// scheduled frame has finished.</span></span><br><span class="line">  lockEvents(() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> endOfFrame;</span><br><span class="line">    Timeline.finishSync();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进行绘制操作。</p><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>从 2.1 的 runApp 入口可知，</p><ol><li>WidgetsFlutterBinding 初始化，这是一个单例，负责创建各种绑定对象，有的时候我们需要将这段代码前置，使得各种绑定操作在 runApp 之前完成；</li><li>attachRootWidget, 自底向上遍历整个视图树，创建 element、renderObject 对象，建立 widget、element、renderObject 三者之间的关系；</li><li>scheduleWarmUpFrame, 执行绘制操作</li></ol><p>Q: 自底向上遍历整个视图树的时候，感觉 mount 无线递归执行，什么时候完成呢？<br>A: 当遍历到最顶层的 widget 时，在调用 updateChild 的时候回返回 null, 也就是<code>递</code>的结束，从而<code>归</code>回来，然后回到 <code>2.5 attachToRenderTree</code>，返回 RenderObjectToWidgetElement 类型的 root element. 我把前面 demo 的 debug 流程贴出来，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">RenderObjectToWidgetElement </span><br><span class="line">- mount  // parent: null, newSlot: null</span><br><span class="line">- _rebuild</span><br><span class="line">- updateChild  // child: null, newWidget: MyApp</span><br><span class="line">- inflateWidget // newWidget: MyApp</span><br><span class="line">- createElement // StatefulElement: ComponentElement</span><br><span class="line">- mount  </span><br><span class="line"></span><br><span class="line">StatefulElement: ComponentElement </span><br><span class="line">- mount // parent: [root](renderObject: RenderView#5a380 NEEDS-LAYOUT NEEDS-PAINT)</span><br><span class="line">- _firstBuild</span><br><span class="line">- rebuild</span><br><span class="line">- performRebuild</span><br><span class="line">- updateChild // child: null, newWidget: Container</span><br><span class="line">- inflateWidget // newWidget: Container</span><br><span class="line">- createElement // StatelessElement: ComponentElement</span><br><span class="line">- mount // </span><br><span class="line"></span><br><span class="line">StatelessElement: ComponentElement</span><br><span class="line">- mount // parent: MyApp(state: _MyAppState#9e4bc)</span><br><span class="line">- _firstBuild</span><br><span class="line">- rebuild</span><br><span class="line">- performRebuild // StatelessElement.build</span><br><span class="line">- updateChild // child: null, newWidget: LimitedBox</span><br><span class="line">- inflateWidget // newWidget: LimitedBox(maxWidth: 0.0, maxHeight: 0.0)</span><br><span class="line">- createElement // SingleChildRenderObjectElement: RenderObjectElement</span><br><span class="line">- mount</span><br><span class="line"></span><br><span class="line">SingleChildRenderObjectElement</span><br><span class="line">- mount // parent: Container</span><br><span class="line">- updateChild // child: null, newWidget: ConstrainedBox(BoxConstraints(biggest))</span><br><span class="line">- inflateWidget // newWidget: ConstrainedBox(BoxConstraints(biggest))</span><br><span class="line">- createElement // SingleChildRenderObjectElement: RenderObjectElement</span><br><span class="line">- mount</span><br><span class="line"></span><br><span class="line">SingleChildRenderObjectElement</span><br><span class="line">- mount // parent: LimitedBox(maxWidth: 0.0, maxHeight: 0.0, renderObject: RenderLimitedBox#3d07c NEEDS-LAYOUT NEEDS-PAINT NEEDS-COMPOSITING-BITS-U</span><br><span class="line">- updateChild // child: null, newWidget: null</span><br></pre></td></tr></table></figure><h2 id="3-1-问题"><a href="#3-1-问题" class="headerlink" title="3.1 问题"></a>3.1 问题</h2><ol><li>三棵树的关系，element 的具体功能</li><li>不同 element 执行 build 方法的时机</li><li>key slot 等联系</li><li>整个执行一帧的流程</li><li>页面刷新的具体流程，setState vs provider 局部刷新</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h1&gt;&lt;p&gt;使用下面 demo 来探究 main 函数干了啥。&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;
      
    
    </summary>
    
      <category term="flutter" scheme="http://example.com/categories/flutter/"/>
    
    
      <category term="flutter" scheme="http://example.com/tags/flutter/"/>
    
      <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>iOS Flutter Platform Channel</title>
    <link href="http://example.com/2021/04/07/flutter-source-code-ios-platform-channels/"/>
    <id>http://example.com/2021/04/07/flutter-source-code-ios-platform-channels/</id>
    <published>2021-04-07T10:37:37.000Z</published>
    <updated>2021-04-10T14:38:58.102Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文基于 flutter 1.22.2 源码，在 ios_debug_unopt 产物下调试。</p></blockquote><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文下面的 demo(来自 <a href="https://flutter.dev/docs/development/platform-integration/platform-channels">Writing custom platform-specific code</a>) 和 flutter 源码来分析 ios platform channels 的实现。</p><h2 id="1-1-demo"><a href="#1-1-demo" class="headerlink" title="1.1 demo"></a>1.1 demo</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:async&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/services.dart&#x27;</span>;</span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> platform = <span class="keyword">const</span> MethodChannel(<span class="string">&#x27;samples.flutter.dev/battery&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get battery level.</span></span><br><span class="line">  <span class="built_in">String</span> _batteryLevel = <span class="string">&#x27;Unknown battery level.&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; _getBatteryLevel() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="built_in">String</span> batteryLevel;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">int</span> result = <span class="keyword">await</span> platform.invokeMethod(<span class="string">&#x27;getBatteryLevel&#x27;</span>);</span><br><span class="line">      batteryLevel = <span class="string">&#x27;Battery level at <span class="subst">$result</span> % .&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">on</span> PlatformException <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      batteryLevel = <span class="string">&quot;Failed to get battery level: &#x27;<span class="subst">$&#123;e.message&#125;</span>&#x27;.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _batteryLevel = batteryLevel;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Flutter&#x2F;Flutter.h&gt;</span><br><span class="line">#import &quot;GeneratedPluginRegistrant.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation AppDelegate</span><br><span class="line">- (BOOL)application:(UIApplication*)application didFinishLaunchingWithOptions:(NSDictionary*)launchOptions &#123;</span><br><span class="line">  FlutterViewController* controller &#x3D; (FlutterViewController*)self.window.rootViewController;</span><br><span class="line"></span><br><span class="line">  FlutterMethodChannel* batteryChannel &#x3D; [FlutterMethodChannel</span><br><span class="line">                                          methodChannelWithName:@&quot;samples.flutter.dev&#x2F;battery&quot;</span><br><span class="line">                                          binaryMessenger:controller.binaryMessenger];</span><br><span class="line"></span><br><span class="line">  __weak typeof(self) weakSelf &#x3D; self;</span><br><span class="line">  [batteryChannel setMethodCallHandler:^(FlutterMethodCall* call, FlutterResult result) &#123;</span><br><span class="line">      &#x2F;&#x2F; Note: this method is invoked on the UI thread.</span><br><span class="line">      if ([@&quot;getBatteryLevel&quot; isEqualToString:call.method]) &#123;</span><br><span class="line">        int batteryLevel &#x3D; [weakSelf getBatteryLevel];</span><br><span class="line">        </span><br><span class="line">        if (batteryLevel &#x3D;&#x3D; -1) &#123;</span><br><span class="line">          result([FlutterError errorWithCode:@&quot;UNAVAILABLE&quot;</span><br><span class="line">                                     message:@&quot;Battery info unavailable&quot;</span><br><span class="line">                                     details:nil]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          result(@(batteryLevel));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        result(FlutterMethodNotImplemented);</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;];</span><br><span class="line"></span><br><span class="line">  [GeneratedPluginRegistrant registerWithRegistry:self];</span><br><span class="line">  return [super application:application didFinishLaunchingWithOptions:launchOptions];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (int)getBatteryLevel &#123;</span><br><span class="line">  UIDevice* device &#x3D; UIDevice.currentDevice;</span><br><span class="line">  device.batteryMonitoringEnabled &#x3D; YES;</span><br><span class="line">  if (device.batteryState &#x3D;&#x3D; UIDeviceBatteryStateUnknown) &#123;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return (int)(device.batteryLevel * 100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-Dart-层"><a href="#2-Dart-层" class="headerlink" title="2. Dart 层"></a>2. Dart 层</h1><h2 id="2-1-MethodChannel-初始化"><a href="#2-1-MethodChannel-初始化" class="headerlink" title="2.1 MethodChannel 初始化"></a>2.1 MethodChannel 初始化</h2><blockquote><p>flutter/packages/flutter/lib/src/services/platform_channel.dart</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">A named channel for communicating with platform plugins using asynchronous method calls.</span></span></span><br><span class="line"><span class="keyword">const</span> MethodChannel(<span class="keyword">this</span>.name, [<span class="keyword">this</span>.codec = <span class="keyword">const</span> StandardMethodCodec(), BinaryMessenger? binaryMessenger ])</span><br><span class="line">      : <span class="keyword">assert</span>(name != <span class="keyword">null</span>),</span><br><span class="line">        <span class="keyword">assert</span>(codec != <span class="keyword">null</span>),</span><br><span class="line">        _binaryMessenger = binaryMessenger;</span><br></pre></td></tr></table></figure><p>初始化，默认是使用标准编解码器 <code>StandardMethodCodec</code>，在发送到 <code>platform plugin</code> 要使用 <code>codec</code> 进行编码，同样 <code>platform plugin</code> 发送过来的消息要解码成 Dart 层的数据。所以，<code>platform plugin</code> 那边需要兼容 Dart 层的 <code>codec</code>。</p><h2 id="2-2-MessageCodec-抽象类"><a href="#2-2-MessageCodec-抽象类" class="headerlink" title="2.2 MessageCodec 抽象类"></a>2.2 MessageCodec 抽象类</h2><blockquote><p>flutter/packages/flutter/lib/src/services/message_codec.dart</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">A message encoding/decoding mechanism.</span></span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageCodec</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  ByteData? encodeMessage(T message);</span><br><span class="line">  T decodeMessage(ByteData? message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>StandardMethodCodec</code> 实现了抽象类 <code>MessageCodec</code> 的编解码方法。</p><p><img src="https://sat02pap001files.storage.live.com/y4mzy8_dvuO_7jpkfRcL_zpKQPzaxo5SWf7xWupP1dN-lR4kd9U5Z-UG7VVpscyQGF7iMkN6ijMHGd6VS5xe-Oc8cJ5pn3-MDVTgn-7Ofeu5LUNkq8JbdlrhzjHkx7vSWZNXT7llmx5wNwpQdHXKPDJi8Gd0zjwISaK4eUHUZSn7WPjvJM2v-JpSKbwzi91ISeq?width=1510&height=298&cropmode=none" alt="-w755"></p><p>从上图可知，目标有四个类实现了 <code>MessageCodec</code> 。</p><ul><li>BinaryCodec: [MessageCodec] with unencoded binary messages represented using [ByteData]. // 没编码的原始二进制数据类型 </li><li>JSONMessageCodec: [MessageCodec] with UTF-8 encoded JSON messages. // utf-8 编码的 json 消息</li><li>StandardMessageCodec: [MessageCodec] using the Flutter standard binary encoding. // flutter 标准的二进制编码，可以参考 <a href="https://flutter.dev/docs/development/platform-integration/platform-channels">Writing custom platform-specific code</a> 的 <code>Platform channel data types support and codecs</code> 小节，当然 <code>class StandardMessageCodec implements MessageCodec&lt;dynamic&gt; &#123;</code> 定义上面的注释也有解释。</li><li>StringCodec: [MessageCodec] with UTF-8 encoded String messages. // utf-8 编码的字符串消息 </li></ul><h2 id="2-3-invokeMethod"><a href="#2-3-invokeMethod" class="headerlink" title="2.3 invokeMethod"></a>2.3 invokeMethod</h2><blockquote><p>flutter/packages/flutter/lib/src/services/platform_channel.dart</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;T?&gt; invokeMethod&lt;T&gt;(<span class="built_in">String</span> method, [ <span class="built_in">dynamic</span> arguments ]) &#123;</span><br><span class="line">    <span class="keyword">return</span> _invokeMethod&lt;T&gt;(method, missingOk: <span class="keyword">false</span>, arguments: arguments);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="meta">@optionalTypeArgs</span></span><br><span class="line">  Future&lt;T?&gt; _invokeMethod&lt;T&gt;(<span class="built_in">String</span> method, &#123; <span class="keyword">required</span> <span class="built_in">bool</span> missingOk, <span class="built_in">dynamic</span> arguments &#125;) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span>(method != <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 见 2.6</span></span><br><span class="line">    <span class="keyword">final</span> ByteData? result = <span class="keyword">await</span> binaryMessenger.send(</span><br><span class="line">      name,</span><br><span class="line">      codec.encodeMethodCall(MethodCall(method, arguments)),</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (missingOk) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> MissingPluginException(<span class="string">&#x27;No implementation found for method <span class="subst">$method</span> on channel <span class="subst">$name</span>&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 见 [6.6]</span></span><br><span class="line">    <span class="keyword">return</span> codec.decodeEnvelope(result) <span class="keyword">as</span> T;</span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure><p>该方法主要功能：</p><ol><li>创建 MethodCall 对象[见 2.3.1]</li><li>调用 StandardMessageCodec 的 encodeMethodCall, 将 MethodCall 对象编码成 ByteData 数据[见 2.3.2]</li><li>调用 BinaryMessenger 来发送 ByteData 数据 [见 2.4]</li><li>调用 StandardMessageCodec 的 decodeEnvelope, 将发送返回后的结果进行解码</li></ol><h3 id="2-3-1-MethodCall初始化"><a href="#2-3-1-MethodCall初始化" class="headerlink" title="2.3.1 MethodCall初始化"></a>2.3.1 MethodCall初始化</h3><blockquote><p>flutter/packages/flutter/lib/src/services/message_codec.dart</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MethodCall(<span class="keyword">this</span>.method, [<span class="keyword">this</span>.arguments])</span><br><span class="line">    : <span class="keyword">assert</span>(method != <span class="keyword">null</span>); <span class="comment">// 方法名，非空</span></span><br></pre></td></tr></table></figure><p>这里的参数就是 <code>invokeMethod</code> 方法的入参 <code>method</code> 和 <code>arguments</code> 。</p><h3 id="2-3-2-encodeMethodCall"><a href="#2-3-2-encodeMethodCall" class="headerlink" title="2.3.2 encodeMethodCall"></a>2.3.2 encodeMethodCall</h3><blockquote><p>flutter/packages/flutter/lib/src/services/message_codec.dart</p></blockquote><p>来自抽象类 <code>MethodCodec</code>, 对方法调用和结果进行编解码。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">A codec for method calls and enveloped results.</span></span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodCodec</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">Encodes the specified [methodCall] into binary.</span></span></span><br><span class="line">  ByteData encodeMethodCall(MethodCall methodCall);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Decodes the specified [methodCall] from binary.</span></span></span><br><span class="line">  MethodCall decodeMethodCall(ByteData? methodCall);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Decodes the specified result [envelope] from binary.</span></span></span><br><span class="line">  <span class="built_in">dynamic</span> decodeEnvelope(ByteData envelope);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Encodes a successful [result] into a binary envelope.</span></span></span><br><span class="line">  ByteData encodeSuccessEnvelope(<span class="built_in">dynamic</span> result);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Encodes an error result into a binary envelope.</span></span></span><br><span class="line">  ByteData encodeErrorEnvelope(&#123; <span class="keyword">required</span> <span class="built_in">String</span> code, <span class="built_in">String?</span> message, <span class="built_in">dynamic</span> details&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>flutter/packages/flutter/lib/src/services/message_codecs.dart</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">ByteData encodeMethodCall(MethodCall call) &#123;</span><br><span class="line">    <span class="comment">// 创建一个写buffer, 见 [2.3.3]</span></span><br><span class="line">    <span class="keyword">final</span> WriteBuffer buffer = WriteBuffer();</span><br><span class="line">    <span class="comment">// 调用 StandardMessageCodec 的 writeValue 方法，将数据写入 buffer</span></span><br><span class="line">    messageCodec.writeValue(buffer, call.method);</span><br><span class="line">    messageCodec.writeValue(buffer, call.arguments);</span><br><span class="line">    <span class="keyword">return</span> buffer.done();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-3-WriteBuffer"><a href="#2-3-3-WriteBuffer" class="headerlink" title="2.3.3 WriteBuffer"></a>2.3.3 WriteBuffer</h3><blockquote><p>flutter/packages/flutter/lib/src/foundation/serialization.dart</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">WriteBuffer()</span><br><span class="line">    : _buffer = Uint8Buffer(),</span><br><span class="line">      _eightBytes = ByteData(<span class="number">8</span>) &#123;</span><br><span class="line">    _eightBytesAsList = _eightBytes.buffer.asUint8List();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"> ByteData done() &#123;</span><br><span class="line">    <span class="keyword">final</span> ByteData result = _buffer!.buffer.asByteData(<span class="number">0</span>, _buffer!.lengthInBytes);</span><br><span class="line">    _buffer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 返回最后的写入结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure><h2 id="2-4-binaryMessenger-send"><a href="#2-4-binaryMessenger-send" class="headerlink" title="2.4 binaryMessenger.send"></a>2.4 binaryMessenger.send</h2><blockquote><p>flutter/packages/flutter/lib/src/services/platform_channel.dart</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">BinaryMessenger <span class="keyword">get</span> binaryMessenger =&gt; _binaryMessenger ?? defaultBinaryMessenger;</span><br><span class="line"></span><br><span class="line">BinaryMessenger <span class="keyword">get</span> defaultBinaryMessenger &#123;</span><br><span class="line">  <span class="keyword">assert</span>(() &#123;</span><br><span class="line">    <span class="keyword">if</span> (ServicesBinding.instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> FlutterError(</span><br><span class="line">        <span class="string">&#x27;ServicesBinding.defaultBinaryMessenger was accessed before the &#x27;</span></span><br><span class="line">        <span class="string">&#x27;binding was initialized.\n&#x27;</span></span><br><span class="line">        <span class="string">&quot;If you&#x27;re running an application and need to access the binary &quot;</span></span><br><span class="line">        <span class="string">&#x27;messenger before `runApp()` has been called (for example, during &#x27;</span></span><br><span class="line">        <span class="string">&#x27;plugin initialization), then you need to explicitly call the &#x27;</span></span><br><span class="line">        <span class="string">&#x27;`WidgetsFlutterBinding.ensureInitialized()` first.\n&#x27;</span></span><br><span class="line">        <span class="string">&quot;If you&#x27;re running a test, you can call the &quot;</span></span><br><span class="line">        <span class="string">&#x27;`TestWidgetsFlutterBinding.ensureInitialized()` as the first line in &#x27;</span></span><br><span class="line">        <span class="string">&quot;your test&#x27;s `main()` method to initialize the binding.&quot;</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;());</span><br><span class="line">  <span class="comment">// 见 [2.4.1]</span></span><br><span class="line">  <span class="keyword">return</span> ServicesBinding.instance!.defaultBinaryMessenger;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <code>MethodChannel</code> 初始化的时候没有传 <code>BinaryMessenger</code> 对象，所以这里是用的默认值：<code>ServicesBinding.instance!.defaultBinaryMessenger</code>.</p><h3 id="2-4-1-sendPlatformMessage"><a href="#2-4-1-sendPlatformMessage" class="headerlink" title="2.4.1 _sendPlatformMessage"></a>2.4.1 _sendPlatformMessage</h3><blockquote><p>flutter/packages/flutter/lib/src/services/binding.dart</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_DefaultBinaryMessenger</span> <span class="keyword">extends</span> <span class="title">BinaryMessenger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> _DefaultBinaryMessenger._();</span><br><span class="line">  Future&lt;ByteData?&gt; _sendPlatformMessage(<span class="built_in">String</span> channel, ByteData? message) &#123;</span><br><span class="line">    <span class="comment">// 见 [2.4.2]</span></span><br><span class="line">    <span class="keyword">final</span> Completer&lt;ByteData?&gt; completer = Completer&lt;ByteData?&gt;();</span><br><span class="line">    <span class="comment">// ui.window is accessed directly instead of using ServicesBinding.instance.window</span></span><br><span class="line">    <span class="comment">// because this method might be invoked before any binding is initialized.</span></span><br><span class="line">    <span class="comment">// This issue was reported in #27541. It is not ideal to statically access</span></span><br><span class="line">    <span class="comment">// ui.window because the Window may be dependency injected elsewhere with</span></span><br><span class="line">    <span class="comment">// a different instance. However, static access at this location seems to be</span></span><br><span class="line">    <span class="comment">// the least bad option.</span></span><br><span class="line">    <span class="comment">// 见 [2.5]</span></span><br><span class="line">    ui.<span class="built_in">window</span>.sendPlatformMessage(channel, message, (ByteData? reply) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 见 [3.1.1], 会在 engine 层保存起来</span></span><br><span class="line">        completer.complete(reply);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (exception, stack) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> completer.future;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-2-Completer-初始化"><a href="#2-4-2-Completer-初始化" class="headerlink" title="2.4.2 Completer 初始化"></a>2.4.2 Completer 初始化</h3><blockquote><p>flutter/bin/cache/pkg/sky_engine/lib/async/future.dart</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 见 [2.4.3]</span></span><br><span class="line"><span class="keyword">factory</span> Completer() =&gt; <span class="keyword">new</span> _AsyncCompleter&lt;T&gt;();</span><br></pre></td></tr></table></figure><h3 id="2-4-3-AsyncCompleter-初始化"><a href="#2-4-3-AsyncCompleter-初始化" class="headerlink" title="2.4.3 _AsyncCompleter 初始化"></a>2.4.3 _AsyncCompleter 初始化</h3><blockquote><p>flutter/bin/cache/pkg/sky_engine/lib/async/future_impl.dart</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">_Completer</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Completer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> _Future&lt;T&gt; future = <span class="keyword">new</span> _Future&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> complete([FutureOr&lt;T&gt;? value]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _completeError(<span class="built_in">Object</span> error, StackTrace stackTrace);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The future&#x27;s _isComplete doesn&#x27;t take into account pending completions.</span></span><br><span class="line">  <span class="comment">// We therefore use _mayComplete.</span></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> isCompleted =&gt; !future._mayComplete;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AsyncCompleter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">_Completer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> complete([FutureOr&lt;T&gt;? value]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!future._mayComplete) <span class="keyword">throw</span> <span class="keyword">new</span> StateError(<span class="string">&quot;Future already completed&quot;</span>);</span><br><span class="line">    <span class="comment">// 见 [6.5]</span></span><br><span class="line">    future._asyncComplete(value == <span class="keyword">null</span> ? value <span class="keyword">as</span> <span class="built_in">dynamic</span> : value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-window-sendPlatformMessage"><a href="#2-5-window-sendPlatformMessage" class="headerlink" title="2.5 window.sendPlatformMessage"></a>2.5 window.sendPlatformMessage</h2><blockquote><p>flutter/bin/cache/pkg/sky_engine/lib/ui/window.dart</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> sendPlatformMessage(<span class="built_in">String</span> name,</span><br><span class="line">                         ByteData? data,</span><br><span class="line">                         PlatformMessageResponseCallback? callback) &#123;</span><br><span class="line">  <span class="comment">// 见[2.5.1]</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String?</span> error =</span><br><span class="line">      _sendPlatformMessage(name, _zonedPlatformMessageResponseCallback(callback), data); </span><br><span class="line">  <span class="keyword">if</span> (error != <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> Exception(error);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 见 [3.1]</span></span><br><span class="line"><span class="built_in">String?</span> _sendPlatformMessage(<span class="built_in">String</span> name,</span><br><span class="line">                            PlatformMessageResponseCallback? callback,</span><br><span class="line">                            ByteData? data) native <span class="string">&#x27;PlatformConfiguration_sendPlatformMessage&#x27;</span>;</span><br></pre></td></tr></table></figure><p><code>_sendPlatformMessage</code> 是一个 Native 代码，会调用到引擎层。</p><h3 id="2-5-1-zonedPlatformMessageResponseCallback"><a href="#2-5-1-zonedPlatformMessageResponseCallback" class="headerlink" title="2.5.1 _zonedPlatformMessageResponseCallback"></a>2.5.1 _zonedPlatformMessageResponseCallback</h3><blockquote><p>flutter/bin/cache/pkg/sky_engine/lib/ui/window.dart</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">Wraps the given [callback] in another callback that ensures that the</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">original callback is called in the zone it was registered in.</span></span></span><br><span class="line">  <span class="keyword">static</span> PlatformMessageResponseCallback? _zonedPlatformMessageResponseCallback(PlatformMessageResponseCallback? callback) &#123;</span><br><span class="line">    <span class="keyword">if</span> (callback == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Store the zone in which the callback is being registered.</span></span><br><span class="line">    <span class="keyword">final</span> Zone registrationZone = Zone.current;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (ByteData? data) &#123;</span><br><span class="line">      registrationZone.runUnaryGuarded(callback, data);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>将当前注册回调的 <code>Zone.current</code> 存起来。</p><h1 id="3-engine-层"><a href="#3-engine-层" class="headerlink" title="3. engine 层"></a>3. engine 层</h1><h2 id="3-1-SendPlatformMessage"><a href="#3-1-SendPlatformMessage" class="headerlink" title="3.1 _SendPlatformMessage"></a>3.1 _SendPlatformMessage</h2><blockquote><p>engine/src/flutter/lib/ui/window/platform_configuration.cc</p></blockquote><p>在 flutter 源码中搜索 <code>_sendPlatformMessage</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// platform_configuration.cc -L137</span></span><br><span class="line"><span class="keyword">void</span> _SendPlatformMessage(Dart_NativeArguments args) &#123;</span><br><span class="line">  tonic::DartCallStatic(&amp;SendPlatformMessage, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// platform_configuration.cc -L105</span></span><br><span class="line"><span class="function">Dart_Handle <span class="title">SendPlatformMessage</span><span class="params">(Dart_Handle window,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                Dart_Handle callback,</span></span></span><br><span class="line"><span class="function"><span class="params">                                Dart_Handle data_handle)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取当前 dart_state                               </span></span><br><span class="line">  UIDartState* dart_state = UIDartState::Current();</span><br><span class="line">  <span class="comment">// 没有 platform_configuration, 抛出异常</span></span><br><span class="line">  <span class="keyword">if</span> (!dart_state-&gt;platform_configuration()) &#123;</span><br><span class="line">    <span class="keyword">return</span> tonic::ToDart(</span><br><span class="line">        <span class="string">&quot;Platform messages can only be sent from the main isolate&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fml::RefPtr&lt;PlatformMessageResponse&gt; response;</span><br><span class="line">  <span class="keyword">if</span> (!Dart_IsNull(callback)) &#123;</span><br><span class="line">    <span class="comment">// 见 [3.1.1] 和 [3.1.2]</span></span><br><span class="line">    response = fml::MakeRefCounted&lt;PlatformMessageResponseDart&gt;(</span><br><span class="line">        tonic::DartPersistentValue(dart_state, callback),</span><br><span class="line">        dart_state-&gt;GetTaskRunners().GetUITaskRunner());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (Dart_IsNull(data_handle)) &#123;</span><br><span class="line">    dart_state-&gt;platform_configuration()-&gt;client()-&gt;HandlePlatformMessage(</span><br><span class="line">        fml::MakeRefCounted&lt;PlatformMessage&gt;(name, response));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    tonic::DartByteData data(data_handle);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span>* buffer = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(data.data());</span><br><span class="line">    <span class="comment">// 见 [3.2]</span></span><br><span class="line">    dart_state-&gt;platform_configuration()-&gt;client()-&gt;HandlePlatformMessage(</span><br><span class="line">        fml::MakeRefCounted&lt;PlatformMessage&gt;(</span><br><span class="line">            name, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint8_t</span>&gt;(buffer, buffer + data.length_in_bytes()),</span><br><span class="line">            response));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Dart_Null();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法主要功能：</p><ol><li>发送平台消息，只允许在主 isolate 中发出，否则会抛出异常</li><li>相关参数<ol><li>window: Dart 层的 window</li><li>name: channel 名</li><li>callback: 见 [3.1.1] 的描述</li><li>data_handle: 编码后的 <code>MethodCall</code> 对象，也就是待执行的方法和参数，后续赋值给 PlatformMessage 对象的 data 成员变量</li></ol></li><li>创建 PlatformMessageResponseDart 对象，保存 callback 和 GetUITaskRunner</li><li>调用 RuntimeController 的 HandlePlatformMessage 方法，入参为 PlatformMessage, 见 [3.1.3]</li></ol><h3 id="3-1-1-DartPersistentValue"><a href="#3-1-1-DartPersistentValue" class="headerlink" title="3.1.1 DartPersistentValue"></a>3.1.1 DartPersistentValue</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dart_persistent_value.cc -L20</span></span><br><span class="line">DartPersistentValue::DartPersistentValue(DartState* dart_state,</span><br><span class="line">                                         Dart_Handle value)</span><br><span class="line">    : value_(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">  Set(dart_state, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dart_persistent_value.cc -L30</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DartPersistentValue::Set</span><span class="params">(DartState* dart_state, Dart_Handle value)</span> </span>&#123;</span><br><span class="line">  TONIC_DCHECK(is_empty());</span><br><span class="line">  dart_state_ = dart_state-&gt;GetWeakPtr();</span><br><span class="line">  value_ = Dart_NewPersistentHandle(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 <code>dart_state</code> 和 <code>callback</code> 封装成 <code>DartPersistentValue</code> 对象，这里的 <code>callback</code> 就是 [2.4] 中的 <code>completer.complete(reply);</code>，处理发送返回的数据。</p><h3 id="3-1-2-PlatformMessageResponseDart-初始化"><a href="#3-1-2-PlatformMessageResponseDart-初始化" class="headerlink" title="3.1.2 PlatformMessageResponseDart 初始化"></a>3.1.2 PlatformMessageResponseDart 初始化</h3><blockquote><p>engine/src/flutter/lib/ui/window/platform_message_response_dart.cc</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PlatformMessageResponseDart::PlatformMessageResponseDart(</span><br><span class="line">    tonic::DartPersistentValue callback,</span><br><span class="line">    fml::RefPtr&lt;fml::TaskRunner&gt; ui_task_runner)</span><br><span class="line">    : callback_(<span class="built_in">std</span>::move(callback)),</span><br><span class="line">      ui_task_runner_(<span class="built_in">std</span>::move(ui_task_runner)) &#123;&#125;</span><br></pre></td></tr></table></figure><p>简单的赋初始值。</p><h3 id="3-1-3-PlatformMessage-初始化"><a href="#3-1-3-PlatformMessage-初始化" class="headerlink" title="3.1.3 PlatformMessage 初始化"></a>3.1.3 PlatformMessage 初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// platform_message.cc -L11</span></span><br><span class="line">PlatformMessage::PlatformMessage(<span class="built_in">std</span>::<span class="built_in">string</span> channel,</span><br><span class="line">                                 <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint8_t</span>&gt; data,</span><br><span class="line">                                 fml::RefPtr&lt;PlatformMessageResponse&gt; response)</span><br><span class="line">    : channel_(<span class="built_in">std</span>::move(channel)),</span><br><span class="line">      data_(<span class="built_in">std</span>::move(data)),</span><br><span class="line">      hasData_(<span class="literal">true</span>),</span><br><span class="line">      response_(<span class="built_in">std</span>::move(response)) &#123;&#125;</span><br></pre></td></tr></table></figure><p>该方法相关入参</p><ul><li>channel: channel 名</li><li>data: data_handle(见 [3.1] 的描述) 转换后的值</li><li>response: 见 [3.1.1], 对 <code>3.1.1</code> 和 <code>callback</code> 的封装</li></ul><p>至此， Dart 层传过来的数据以及在 engine 层转换后的数据，都封装在了 <code>PlatformMessage</code> 对象中，后续在 engine 层都是操作该 <code>PlatformMessage</code> 对象。</p><h2 id="3-2-RuntimeController-HandlePlatformMessage"><a href="#3-2-RuntimeController-HandlePlatformMessage" class="headerlink" title="3.2 RuntimeController::HandlePlatformMessage"></a>3.2 RuntimeController::HandlePlatformMessage</h2><blockquote><p>engine/src/flutter/runtime/runtime_controller.cc </p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// |PlatformConfigurationClient|</span></span><br><span class="line"><span class="comment">// runtime_controller.cc -L328</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RuntimeController::HandlePlatformMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    fml::RefPtr&lt;PlatformMessage&gt; message)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 见 3.3 </span></span><br><span class="line">  client_.HandlePlatformMessage(<span class="built_in">std</span>::move(message));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>note: 这块的逻辑代码需要了解 flutter 的引擎启动。</p><p>相关调用链在 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime_controller.cc -L64</span></span><br><span class="line">RuntimeController::RuntimeController(</span><br><span class="line">    RuntimeDelegate&amp; p_client,</span><br><span class="line">    DartVM* p_vm,</span><br><span class="line">    fml::RefPtr&lt;<span class="keyword">const</span> DartSnapshot&gt; p_isolate_snapshot,</span><br><span class="line">    TaskRunners p_task_runners,</span><br><span class="line">    fml::WeakPtr&lt;SnapshotDelegate&gt; p_snapshot_delegate,</span><br><span class="line">    fml::WeakPtr&lt;HintFreedDelegate&gt; p_hint_freed_delegate,</span><br><span class="line">    fml::WeakPtr&lt;IOManager&gt; p_io_manager,</span><br><span class="line">    fml::RefPtr&lt;SkiaUnrefQueue&gt; p_unref_queue,</span><br><span class="line">    fml::WeakPtr&lt;ImageDecoder&gt; p_image_decoder,</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> p_advisory_script_uri,</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> p_advisory_script_entrypoint,</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int64_t</span>)&gt;&amp; idle_notification_callback,</span><br><span class="line">    <span class="keyword">const</span> PlatformData&amp; p_platform_data,</span><br><span class="line">    <span class="keyword">const</span> fml::closure&amp; p_isolate_create_callback,</span><br><span class="line">    <span class="keyword">const</span> fml::closure&amp; p_isolate_shutdown_callback,</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">const</span> fml::Mapping&gt; p_persistent_isolate_data)</span><br><span class="line">    : client_(p_client),</span><br><span class="line">      vm_(p_vm),</span><br><span class="line">      isolate_snapshot_(<span class="built_in">std</span>::move(p_isolate_snapshot)),</span><br><span class="line">      task_runners_(p_task_runners),</span><br><span class="line">      snapshot_delegate_(p_snapshot_delegate),</span><br><span class="line">      hint_freed_delegate_(p_hint_freed_delegate),</span><br><span class="line">      io_manager_(p_io_manager),</span><br><span class="line">      unref_queue_(p_unref_queue),</span><br><span class="line">      image_decoder_(p_image_decoder),</span><br><span class="line">      advisory_script_uri_(p_advisory_script_uri),</span><br><span class="line">      advisory_script_entrypoint_(p_advisory_script_entrypoint),</span><br><span class="line">      idle_notification_callback_(idle_notification_callback),</span><br><span class="line">      platform_data_(<span class="built_in">std</span>::move(p_platform_data)),</span><br><span class="line">      isolate_create_callback_(p_isolate_create_callback),</span><br><span class="line">      isolate_shutdown_callback_(p_isolate_shutdown_callback),</span><br><span class="line">      persistent_isolate_data_(<span class="built_in">std</span>::move(p_persistent_isolate_data)) &#123;</span><br><span class="line">  <span class="comment">// Create the root isolate as soon as the runtime controller is initialized.</span></span><br><span class="line">  <span class="comment">// It will be run at a later point when the engine provides a run</span></span><br><span class="line">  <span class="comment">// configuration and then runs the isolate.</span></span><br><span class="line">  <span class="keyword">auto</span> strong_root_isolate =</span><br><span class="line">      DartIsolate::CreateRootIsolate(</span><br><span class="line">          vm_-&gt;GetVMData()-&gt;GetSettings(),                <span class="comment">//</span></span><br><span class="line">          isolate_snapshot_,                              <span class="comment">//</span></span><br><span class="line">          task_runners_,                                  <span class="comment">//</span></span><br><span class="line">          <span class="built_in">std</span>::make_unique&lt;PlatformConfiguration&gt;(<span class="keyword">this</span>),  <span class="comment">//</span></span><br><span class="line">          snapshot_delegate_,                             <span class="comment">//</span></span><br><span class="line">          hint_freed_delegate_,                           <span class="comment">//</span></span><br><span class="line">          io_manager_,                                    <span class="comment">//</span></span><br><span class="line">          unref_queue_,                                   <span class="comment">//</span></span><br><span class="line">          image_decoder_,                                 <span class="comment">//</span></span><br><span class="line">          p_advisory_script_uri,                          <span class="comment">//</span></span><br><span class="line">          p_advisory_script_entrypoint,                   <span class="comment">//</span></span><br><span class="line">          <span class="literal">nullptr</span>,                                        <span class="comment">//</span></span><br><span class="line">          isolate_create_callback_,                       <span class="comment">//</span></span><br><span class="line">          isolate_shutdown_callback_                      <span class="comment">//</span></span><br><span class="line">          )</span><br><span class="line">          .lock();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::make_unique&lt;PlatformConfiguration&gt;(this)</code>: 将当前 <code>RuntimeController</code> 对象作为入参初始化 <code>PlatformConfiguration</code> 对象(赋值给 <code>client_</code> 成员变量)。</p><h2 id="3-3-Engine-HandlePlatformMessage"><a href="#3-3-Engine-HandlePlatformMessage" class="headerlink" title="3.3 Engine::HandlePlatformMessage"></a>3.3 Engine::HandlePlatformMessage</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// engine.cc -L496</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Engine::HandlePlatformMessage</span><span class="params">(fml::RefPtr&lt;PlatformMessage&gt; message)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (message-&gt;channel() == kAssetChannel) &#123;</span><br><span class="line">    HandleAssetPlatformMessage(<span class="built_in">std</span>::move(message));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 见 [3.4]</span></span><br><span class="line">    delegate_.OnEngineHandlePlatformMessage(<span class="built_in">std</span>::move(message));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关调用链在 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// engine.cc -L59</span></span><br><span class="line">Engine::Engine(Delegate&amp; delegate,</span><br><span class="line">               <span class="keyword">const</span> PointerDataDispatcherMaker&amp; dispatcher_maker,</span><br><span class="line">               DartVM&amp; vm,</span><br><span class="line">               fml::RefPtr&lt;<span class="keyword">const</span> DartSnapshot&gt; isolate_snapshot,</span><br><span class="line">               TaskRunners task_runners,</span><br><span class="line">               <span class="keyword">const</span> PlatformData platform_data,</span><br><span class="line">               Settings settings,</span><br><span class="line">               <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Animator&gt; animator,</span><br><span class="line">               fml::WeakPtr&lt;IOManager&gt; io_manager,</span><br><span class="line">               fml::RefPtr&lt;SkiaUnrefQueue&gt; unref_queue,</span><br><span class="line">               fml::WeakPtr&lt;SnapshotDelegate&gt; snapshot_delegate)</span><br><span class="line">    : Engine(delegate,</span><br><span class="line">             dispatcher_maker,</span><br><span class="line">             vm.GetConcurrentWorkerTaskRunner(),</span><br><span class="line">             task_runners,</span><br><span class="line">             settings,</span><br><span class="line">             <span class="built_in">std</span>::move(animator),</span><br><span class="line">             io_manager,</span><br><span class="line">             <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  runtime_controller_ = <span class="built_in">std</span>::make_unique&lt;RuntimeController&gt;(</span><br><span class="line">      *<span class="keyword">this</span>,                                 <span class="comment">// runtime delegate</span></span><br><span class="line">      &amp;vm,                                   <span class="comment">// VM</span></span><br><span class="line">      <span class="built_in">std</span>::move(isolate_snapshot),           <span class="comment">// isolate snapshot</span></span><br><span class="line">      task_runners_,                         <span class="comment">// task runners</span></span><br><span class="line">      <span class="built_in">std</span>::move(snapshot_delegate),          <span class="comment">// snapshot delegate</span></span><br><span class="line">      GetWeakPtr(),                          <span class="comment">// hint freed delegate</span></span><br><span class="line">      <span class="built_in">std</span>::move(io_manager),                 <span class="comment">// io manager</span></span><br><span class="line">      <span class="built_in">std</span>::move(unref_queue),                <span class="comment">// Skia unref queue</span></span><br><span class="line">      image_decoder_.GetWeakPtr(),           <span class="comment">// image decoder</span></span><br><span class="line">      settings_.advisory_script_uri,         <span class="comment">// advisory script uri</span></span><br><span class="line">      settings_.advisory_script_entrypoint,  <span class="comment">// advisory script entrypoint</span></span><br><span class="line">      settings_.idle_notification_callback,  <span class="comment">// idle notification callback</span></span><br><span class="line">      platform_data,                         <span class="comment">// platform data</span></span><br><span class="line">      settings_.isolate_create_callback,     <span class="comment">// isolate create callback</span></span><br><span class="line">      settings_.isolate_shutdown_callback,   <span class="comment">// isolate shutdown callback</span></span><br><span class="line">      settings_.persistent_isolate_data      <span class="comment">// persistent isolate data</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::make_unique&lt;RuntimeController&gt;(</code>: 将当前 <code>engine</code> 对象作为入参初始化 <code>RuntimeController</code> 对象(赋值给 <code>client_</code> 成员变量)。</p><h2 id="3-4-Shell-OnEngineHandlePlatformMessage"><a href="#3-4-Shell-OnEngineHandlePlatformMessage" class="headerlink" title="3.4 Shell::OnEngineHandlePlatformMessage"></a>3.4 Shell::OnEngineHandlePlatformMessage</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// |Engine::Delegate|</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Shell::OnEngineHandlePlatformMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    fml::RefPtr&lt;PlatformMessage&gt; message)</span> </span>&#123;</span><br><span class="line">  FML_DCHECK(is_setup_);</span><br><span class="line">  FML_DCHECK(task_runners_.GetUITaskRunner()-&gt;RunsTasksOnCurrentThread());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (message-&gt;channel() == kSkiaChannel) &#123;</span><br><span class="line">    HandleEngineSkiaMessage(<span class="built_in">std</span>::move(message));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 在 Platform 线程中执行任务  </span></span><br><span class="line">  task_runners_.GetPlatformTaskRunner()-&gt;PostTask(</span><br><span class="line">      [view = platform_view_-&gt;GetWeakPtr(), message = <span class="built_in">std</span>::move(message)]() &#123;</span><br><span class="line">        <span class="keyword">if</span> (view) &#123;</span><br><span class="line">          <span class="comment">// 见 [3.5]</span></span><br><span class="line">          view-&gt;HandlePlatformMessage(<span class="built_in">std</span>::move(message));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关调用链在 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shell.cc -L152</span></span><br><span class="line">  fml::TaskRunner::RunNowOrPostTask(</span><br><span class="line">      shell-&gt;GetTaskRunners().GetUITaskRunner(),</span><br><span class="line">      fml::MakeCopyable([&amp;engine_promise,                                 <span class="comment">//</span></span><br><span class="line">                         shell = shell.get(),                             <span class="comment">//</span></span><br><span class="line">                         &amp;dispatcher_maker,                               <span class="comment">//</span></span><br><span class="line">                         &amp;platform_data,                                  <span class="comment">//</span></span><br><span class="line">                         isolate_snapshot = <span class="built_in">std</span>::move(isolate_snapshot),  <span class="comment">//</span></span><br><span class="line">                         vsync_waiter = <span class="built_in">std</span>::move(vsync_waiter),          <span class="comment">//</span></span><br><span class="line">                         &amp;weak_io_manager_future,                         <span class="comment">//</span></span><br><span class="line">                         &amp;snapshot_delegate_future,                       <span class="comment">//</span></span><br><span class="line">                         &amp;unref_queue_future                              <span class="comment">//</span></span><br><span class="line">  ]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">        TRACE_EVENT0(<span class="string">&quot;flutter&quot;</span>, <span class="string">&quot;ShellSetupUISubsystem&quot;</span>);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; task_runners = shell-&gt;GetTaskRunners();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The animator is owned by the UI thread but it gets its vsync pulses</span></span><br><span class="line">        <span class="comment">// from the platform.</span></span><br><span class="line">        <span class="keyword">auto</span> animator = <span class="built_in">std</span>::make_unique&lt;Animator&gt;(*shell, task_runners,</span><br><span class="line">                                                   <span class="built_in">std</span>::move(vsync_waiter));</span><br><span class="line"></span><br><span class="line">        engine_promise.set_value(<span class="built_in">std</span>::make_unique&lt;Engine&gt;(</span><br><span class="line">            *shell,                         <span class="comment">//</span></span><br><span class="line">            dispatcher_maker,               <span class="comment">//</span></span><br><span class="line">            *shell-&gt;GetDartVM(),            <span class="comment">//</span></span><br><span class="line">            <span class="built_in">std</span>::move(isolate_snapshot),    <span class="comment">//</span></span><br><span class="line">            task_runners,                   <span class="comment">//</span></span><br><span class="line">            platform_data,                  <span class="comment">//</span></span><br><span class="line">            shell-&gt;GetSettings(),           <span class="comment">//</span></span><br><span class="line">            <span class="built_in">std</span>::move(animator),            <span class="comment">//</span></span><br><span class="line">            weak_io_manager_future.get(),   <span class="comment">//</span></span><br><span class="line">            unref_queue_future.get(),       <span class="comment">//</span></span><br><span class="line">            snapshot_delegate_future.get()  <span class="comment">//</span></span><br><span class="line">            ));</span><br><span class="line">      &#125;));</span><br></pre></td></tr></table></figure><p><code>std::make_unique&lt;Engine&gt;(</code>: 将 <code>*shell</code> 指针作为入参初始化 <code>Engine</code> 对象(赋值给 <code>delegate_</code> 成员变量)。</p><h2 id="3-5-PlatformViewIOS-HandlePlatformMessage"><a href="#3-5-PlatformViewIOS-HandlePlatformMessage" class="headerlink" title="3.5 PlatformViewIOS::HandlePlatformMessage"></a>3.5 PlatformViewIOS::HandlePlatformMessage</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// |PlatformView|</span></span><br><span class="line"><span class="comment">// platform_view_ios.mm -L61</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PlatformViewIOS::HandlePlatformMessage</span><span class="params">(fml::RefPtr&lt;flutter::PlatformMessage&gt; message)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 见 [3.6]</span></span><br><span class="line">  platform_message_router_.HandlePlatformMessage(<span class="built_in">std</span>::move(message));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>platform_view_</p><p>相关调用链如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shell.cc -L544, 给 platform_view_ 赋值</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Shell::Setup</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PlatformView&gt; platform_view,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Engine&gt; engine,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Rasterizer&gt; rasterizer,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ShellIOManager&gt; io_manager)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  platform_view_ = <span class="built_in">std</span>::move(platform_view);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// shell.cc -L167</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Shell&gt; <span class="title">Shell::CreateShellOnPlatformThread</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    DartVMRef vm,</span></span></span><br><span class="line"><span class="function"><span class="params">    TaskRunners task_runners,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> PlatformData platform_data,</span></span></span><br><span class="line"><span class="function"><span class="params">    Settings settings,</span></span></span><br><span class="line"><span class="function"><span class="params">    fml::RefPtr&lt;<span class="keyword">const</span> DartSnapshot&gt; isolate_snapshot,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> Shell::CreateCallback&lt;PlatformView&gt;&amp; on_create_platform_view,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> Shell::CreateCallback&lt;Rasterizer&gt;&amp; on_create_rasterizer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 获取 platform_view</span></span><br><span class="line">    <span class="keyword">auto</span> platform_view = on_create_platform_view(*shell.get());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (!shell-&gt;Setup(<span class="built_in">std</span>::move(platform_view),  <span class="comment">//</span></span><br><span class="line">                    engine_future.get(),       <span class="comment">//</span></span><br><span class="line">                    rasterizer_future.get(),   <span class="comment">//</span></span><br><span class="line">                    io_manager_future.get())   <span class="comment">//</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FlutterEngine.mm -L513</span></span><br><span class="line">- (BOOL)createShell:(NSString*)entrypoint</span><br><span class="line">         libraryURI:(NSString*)libraryURI</span><br><span class="line">       initialRoute:(NSString*)initialRoute &#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   <span class="comment">// on_create_platform_view 回调</span></span><br><span class="line">   flutter::Shell::CreateCallback&lt;flutter::PlatformView&gt; on_create_platform_view =</span><br><span class="line">      [](flutter::Shell&amp; shell) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::make_unique&lt;flutter::PlatformViewIOS&gt;(</span><br><span class="line">            shell, flutter::GetRenderingAPIForProcess(), shell.GetTaskRunners());</span><br><span class="line">      &#125;;      </span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-6-PlatformMessageRouter-HandlePlatformMessage"><a href="#3-6-PlatformMessageRouter-HandlePlatformMessage" class="headerlink" title="3.6 PlatformMessageRouter::HandlePlatformMessage"></a>3.6 PlatformMessageRouter::HandlePlatformMessage</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// platform_message_router.mm -L17</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PlatformMessageRouter::HandlePlatformMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    fml::RefPtr&lt;flutter::PlatformMessage&gt; message)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// [3.1.2] 中的 PlatformMessageResponseDart 对象  </span></span><br><span class="line">  fml::RefPtr&lt;flutter::PlatformMessageResponse&gt; completer = message-&gt;response();</span><br><span class="line">  <span class="comment">// message-&gt;channel(): [3.1] 中的 channel 名</span></span><br><span class="line">  <span class="keyword">auto</span> it = message_handlers_.find(message-&gt;channel());</span><br><span class="line">  <span class="keyword">if</span> (it != message_handlers_.end()) &#123;</span><br><span class="line">    FlutterBinaryMessageHandler handler = it-&gt;second;</span><br><span class="line">    NSData* data = nil;</span><br><span class="line">    <span class="keyword">if</span> (message-&gt;hasData()) &#123;</span><br><span class="line">      <span class="comment">// 由 [3.1.3] 可知， message-&gt;data() 就是编码后的 `MethodCall` 对象</span></span><br><span class="line">      data = GetNSDataFromVector(message-&gt;data());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 见 [5.4]</span></span><br><span class="line">    handler(data, ^(NSData* reply) &#123;</span><br><span class="line">      <span class="keyword">if</span> (completer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">          <span class="comment">// 见 [6.1]</span></span><br><span class="line">          completer-&gt;Complete(GetMappingFromNSData(reply));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          completer-&gt;CompleteEmpty();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (completer) &#123;</span><br><span class="line">      completer-&gt;CompleteEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法注意功能：</p><ol><li>根据 channel 名在 message_handlers_ unordered_map 中找到对应的 FlutterBinaryMessageHandler 类型的 handler</li><li>调用 handler 回调方法获取 reply 数据</li><li>将 reply 数据作为入参，调用 PlatformMessageResponseDart 对象的 Complete 方法</li></ol><p>现在的问题是， FlutterBinaryMessageHandler 类型的 handler 是在哪里赋值的，也就是什么时候调用 [4.4] 的方法，详见下一小节：[4]。</p><h1 id="4-shell-层"><a href="#4-shell-层" class="headerlink" title="4. shell 层"></a>4. shell 层</h1><p>note: 这块的逻辑代码需要了解 flutter 的引擎启动。<br>在创建 engine 的时候，会设置 engine 层相关的 channel. </p><blockquote><p>engine/src/flutter/shell/platform/darwin/ios/framework/Source/FlutterEngine.mm </p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FlutterEngine.mm  -L541</span></span><br><span class="line">- (BOOL)createShell:(NSString*)entrypoint</span><br><span class="line">         libraryURI:(NSString*)libraryURI</span><br><span class="line">       initialRoute:(NSString*)initialRoute &#123;</span><br><span class="line">   <span class="comment">// ...    </span></span><br><span class="line">   <span class="comment">// 见 [4.1]</span></span><br><span class="line">   [self setupChannels];</span><br><span class="line">   <span class="comment">// ...    </span></span><br><span class="line">   [self maybeSetupPlatformViewChannels];</span><br><span class="line">   <span class="comment">// ...    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-1-setupChannels"><a href="#4-1-setupChannels" class="headerlink" title="4.1 setupChannels"></a>4.1 setupChannels</h2><blockquote><p>engine/src/flutter/shell/platform/darwin/ios/framework/Source/FlutterEngine.mm </p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FlutterEngine.mm -L367</span></span><br><span class="line">- (<span class="keyword">void</span>)setupChannels &#123;</span><br><span class="line">  <span class="comment">// This will be invoked once the shell is done setting up and the isolate ID</span></span><br><span class="line">  <span class="comment">// for the UI isolate is available.</span></span><br><span class="line">  fml::WeakPtr&lt;FlutterEngine&gt; weakSelf = [self getWeakPtr];</span><br><span class="line">  <span class="comment">// 见 [4.2]</span></span><br><span class="line">  [_binaryMessenger setMessageHandlerOnChannel:@<span class="string">&quot;flutter/isolate&quot;</span></span><br><span class="line">                          binaryMessageHandler:^(NSData* message, FlutterBinaryReply reply) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (weakSelf) &#123;</span><br><span class="line">                              weakSelf.get().isolateId =</span><br><span class="line">                                  [[FlutterStringCodec sharedInstance] decode:message];</span><br><span class="line">                            &#125;</span><br><span class="line">                          &#125;];</span><br><span class="line">  <span class="comment">// ...                          </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置 <code>flutter/isolate</code> channel。</p><h3 id="4-1-1-FlutterBinaryMessengerRelay-初始化"><a href="#4-1-1-FlutterBinaryMessengerRelay-初始化" class="headerlink" title="4.1.1 FlutterBinaryMessengerRelay 初始化"></a>4.1.1 FlutterBinaryMessengerRelay 初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FlutterEngine.mm -L132</span></span><br><span class="line">- (instancetype)initWithName:(NSString*)labelPrefix</span><br><span class="line">                     project:(FlutterDartProject*)project</span><br><span class="line">      allowHeadlessExecution:(BOOL)allowHeadlessExecution &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="comment">// 将当前 FlutterEngine 对象赋值给 FlutterBinaryMessengerRelay 对象 _binaryMessenger 的 parent 成员变量。</span></span><br><span class="line">      _binaryMessenger = [[FlutterBinaryMessengerRelay alloc] initWithParent:self];</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-setMessageHandlerOnChannel"><a href="#4-2-setMessageHandlerOnChannel" class="headerlink" title="4.2 setMessageHandlerOnChannel"></a>4.2 setMessageHandlerOnChannel</h2><blockquote><p>engine/src/flutter/shell/platform/darwin/ios/framework/Source/FlutterBinaryMessengerRelay.mm</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FlutterBinaryMessengerRelay.mm -L42</span></span><br><span class="line">- (FlutterBinaryMessengerConnection)setMessageHandlerOnChannel:(NSString*)channel</span><br><span class="line">                                          binaryMessageHandler:</span><br><span class="line">                                              (FlutterBinaryMessageHandler)handler &#123;</span><br><span class="line">  <span class="keyword">if</span> (self.parent) &#123;</span><br><span class="line">    <span class="comment">// 见 [4.3]</span></span><br><span class="line">    <span class="keyword">return</span> [self.parent setMessageHandlerOnChannel:channel binaryMessageHandler:handler];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    FML_LOG(WARNING) &lt;&lt; <span class="string">&quot;Communicating on a dead channel.&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-setMessageHandlerOnChannel"><a href="#4-3-setMessageHandlerOnChannel" class="headerlink" title="4.3 setMessageHandlerOnChannel"></a>4.3 setMessageHandlerOnChannel</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FlutterEngine.mm -L730</span></span><br><span class="line">- (FlutterBinaryMessengerConnection)setMessageHandlerOnChannel:(NSString*)channel</span><br><span class="line">                                          binaryMessageHandler:</span><br><span class="line">                                              (FlutterBinaryMessageHandler)handler &#123;</span><br><span class="line">  NSParameterAssert(channel);</span><br><span class="line">  <span class="keyword">if</span> (_shell &amp;&amp; _shell-&gt;IsSetup()) &#123;</span><br><span class="line">    <span class="comment">// 见 [4.4]</span></span><br><span class="line">    self.iosPlatformView-&gt;GetPlatformMessageRouter().SetMessageHandler(channel.UTF8String, handler);</span><br><span class="line">    <span class="keyword">return</span> _connections-&gt;AquireConnection(channel.UTF8String);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    NSAssert(!handler, @<span class="string">&quot;Setting a message handler before the FlutterEngine has been run.&quot;</span>);</span><br><span class="line">    <span class="comment">// Setting a handler to nil for a not setup channel is a noop.</span></span><br><span class="line">    <span class="keyword">return</span> flutter::ConnectionCollection::MakeErrorConnection(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-PlatformMessageRouter-SetMessageHandler"><a href="#4-4-PlatformMessageRouter-SetMessageHandler" class="headerlink" title="4.4 PlatformMessageRouter::SetMessageHandler"></a>4.4 PlatformMessageRouter::SetMessageHandler</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// platform_message_router.mm -L43</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PlatformMessageRouter::SetMessageHandler</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; channel,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              FlutterBinaryMessageHandler handler)</span> </span>&#123;</span><br><span class="line">  message_handlers_.erase(channel);</span><br><span class="line">  <span class="keyword">if</span> (handler) &#123;</span><br><span class="line">    message_handlers_[channel] =</span><br><span class="line">        fml::ScopedBlock&lt;FlutterBinaryMessageHandler&gt;&#123;handler, fml::OwnershipPolicy::Retain&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-native-层"><a href="#5-native-层" class="headerlink" title="5. native 层"></a>5. native 层</h1><p>现在来看下 native 层的 Objective-C 的代码，来自 [1.1] 节。</p><h2 id="5-1-FlutterMethodChannel-初始化"><a href="#5-1-FlutterMethodChannel-初始化" class="headerlink" title="5.1 FlutterMethodChannel 初始化"></a>5.1 FlutterMethodChannel 初始化</h2><blockquote><p>engine/src/flutter/shell/platform/darwin/common/framework/Source/FlutterChannels.mm</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FlutterChannels.mm -L181</span></span><br><span class="line">+ (instancetype)methodChannelWithName:(NSString*)name</span><br><span class="line">                      binaryMessenger:(NSObject&lt;FlutterBinaryMessenger&gt;*)messenger &#123;</span><br><span class="line">  <span class="comment">// 见 [5.1.1]                    </span></span><br><span class="line">  NSObject&lt;FlutterMethodCodec&gt;* codec = [FlutterStandardMethodCodec sharedInstance];</span><br><span class="line">  <span class="comment">// 创建 FlutterMethodChannel 对象</span></span><br><span class="line">  <span class="keyword">return</span> [FlutterMethodChannel methodChannelWithName:name binaryMessenger:messenger codec:codec];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法注意功能</p><ol><li>入参<ol><li>name: channel 名</li><li>messenger: (FlutterViewController *)controller.binaryMessenger // 也就是 [4.1.1] 里面的对象</li></ol></li><li>创建 FlutterMethodChannel 对象，后面调用它的 <code>setMethodCallHandler</code> 来处理 Dart 层的调用方法 // 见 [5.2]</li></ol><h3 id="5-1-1-FlutterStandardMethodCodec"><a href="#5-1-1-FlutterStandardMethodCodec" class="headerlink" title="5.1.1 FlutterStandardMethodCodec"></a>5.1.1 FlutterStandardMethodCodec</h3><blockquote><p>engine/src/flutter/shell/platform/darwin/common/framework/Source/FlutterStandardCodec.mm </p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FlutterStandardCodec.mm -L60</span></span><br><span class="line">@implementation FlutterStandardMethodCodec &#123;</span><br><span class="line">  FlutterStandardReaderWriter* _readerWriter;</span><br><span class="line">&#125;</span><br><span class="line">+ (instancetype)sharedInstance &#123;</span><br><span class="line">  <span class="keyword">static</span> id _sharedInstance = nil;</span><br><span class="line">  <span class="keyword">if</span> (!_sharedInstance) &#123;</span><br><span class="line">    <span class="comment">// 见 [5.1.2]</span></span><br><span class="line">    FlutterStandardReaderWriter* readerWriter =</span><br><span class="line">        [[[FlutterStandardReaderWriter alloc] init] autorelease];</span><br><span class="line">    _sharedInstance = [[FlutterStandardMethodCodec alloc] initWithReaderWriter:readerWriter];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _sharedInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-2-FlutterMessageCodec"><a href="#5-1-2-FlutterMessageCodec" class="headerlink" title="5.1.2 FlutterMessageCodec"></a>5.1.2 FlutterMessageCodec</h3><blockquote><p>engine/src/flutter/shell/platform/darwin/common/framework/Headers/FlutterCodecs.h</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A factory of compatible reader/writer instances using the Flutter standard</span></span><br><span class="line"><span class="comment"> * binary encoding or extensions thereof.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">FLUTTER_EXPORT</span><br><span class="line">@interface FlutterStandardReaderWriter : NSObject</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A message encoding/decoding mechanism.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">FLUTTER_EXPORT</span><br><span class="line">@protocol FlutterMessageCodec</span><br></pre></td></tr></table></figure><p>上面的注释 <code>A message encoding/decoding mechanism.</code> 跟 [2.2] 是一样的，所以 <code>FlutterCodecs</code> 文件中的相关编解码类是跟 Dart 层是相对应的(Dart 层中 ByteData8 对应 iOS 中的 NSData)。</p><h2 id="5-2-setMethodCallHandler-方法"><a href="#5-2-setMethodCallHandler-方法" class="headerlink" title="5.2 setMethodCallHandler 方法"></a>5.2 setMethodCallHandler 方法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FlutterChannels.mm -L231</span></span><br><span class="line">- (<span class="keyword">void</span>)setMethodCallHandler:(FlutterMethodCallHandler)handler &#123;</span><br><span class="line">  <span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_connection &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      [_messenger cleanupConnection:_connection];</span><br><span class="line">      _connection = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      [_messenger setMessageHandlerOnChannel:_name binaryMessageHandler:nil];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Make sure the block captures the codec, not self.</span></span><br><span class="line">  NSObject&lt;FlutterMethodCodec&gt;* codec = _codec;</span><br><span class="line">  <span class="comment">// 见 [5.3], 这里 messageHandler 就是 [3.6] 中的 handler 。</span></span><br><span class="line">  FlutterBinaryMessageHandler messageHandler = ^(NSData* message, FlutterBinaryReply callback) &#123;</span><br><span class="line">    <span class="comment">// 见 [5.3.1]</span></span><br><span class="line">    FlutterMethodCall* call = [codec decodeMethodCall:message];</span><br><span class="line">    <span class="comment">// 见 [5.4]</span></span><br><span class="line">    handler(call, ^(id result) &#123;</span><br><span class="line">      <span class="keyword">if</span> (result == FlutterMethodNotImplemented)</span><br><span class="line">        callback(nil);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ([result isKindOfClass:[FlutterError class]])</span><br><span class="line">        <span class="comment">// 见 [5.3.2]</span></span><br><span class="line">        callback([codec encodeErrorEnvelope:(FlutterError*)result]);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 见 [5.3.3]</span></span><br><span class="line">        callback([codec encodeSuccessEnvelope:result]);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 见 [4.2]</span></span><br><span class="line">  _connection = [_messenger setMessageHandlerOnChannel:_name binaryMessageHandler:messageHandler];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-3-messageHandler"><a href="#5-3-messageHandler" class="headerlink" title="5.3 messageHandler"></a>5.3 messageHandler</h2><p>由前面 [3.6] 可知，根据 channel 名(<code>samples.flutter.dev/battery</code>) 找到 FlutterBinaryMessageHandler 回调后，就会调用它，里面就是 NSData 和 FlutterMethodCall 的相互转换，见 [5.3.1 ~ 5.3.3] 小节。</p><h3 id="5-3-1-decodeMethodCall"><a href="#5-3-1-decodeMethodCall" class="headerlink" title="5.3.1 decodeMethodCall"></a>5.3.1 decodeMethodCall</h3><p>由 [5.1.1] 可知，在 <code>FlutterStandardMethodCodec</code> 中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FlutterStandardCodec.mm -L115</span></span><br><span class="line">- (FlutterMethodCall*)decodeMethodCall:(NSData*)message &#123;</span><br><span class="line">  FlutterStandardReader* reader = [_readerWriter readerWithData:message];</span><br><span class="line">  id value1 = [reader readValue];</span><br><span class="line">  id value2 = [reader readValue];</span><br><span class="line">  NSAssert(![reader hasMore], @<span class="string">&quot;Corrupted standard method call&quot;</span>);</span><br><span class="line">  NSAssert([value1 isKindOfClass:[NSString class]], @<span class="string">&quot;Corrupted standard method call&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> [FlutterMethodCall methodCallWithMethodName:value1 arguments:value2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将消息读出来，然后封装成 <code>FlutterMethodCall</code> 对象。</p><h3 id="5-3-2-encodeErrorEnvelope"><a href="#5-3-2-encodeErrorEnvelope" class="headerlink" title="5.3.2 encodeErrorEnvelope"></a>5.3.2 encodeErrorEnvelope</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FlutterStandardCodec.mm -L105</span></span><br><span class="line">- (NSData*)encodeErrorEnvelope:(FlutterError*)error &#123;</span><br><span class="line">  NSMutableData* data = [NSMutableData dataWithCapacity:<span class="number">32</span>];</span><br><span class="line">  FlutterStandardWriter* writer = [_readerWriter writerWithData:data];</span><br><span class="line">  [writer writeByte:<span class="number">1</span>];</span><br><span class="line">  [writer writeValue:error.code];</span><br><span class="line">  [writer writeValue:error.message];</span><br><span class="line">  [writer writeValue:error.details];</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 Error 组装成二进制数据。</p><h3 id="5-3-3-encodeSuccessEnvelope"><a href="#5-3-3-encodeSuccessEnvelope" class="headerlink" title="5.3.3 encodeSuccessEnvelope"></a>5.3.3 encodeSuccessEnvelope</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FlutterStandardCodec.mm -L97</span></span><br><span class="line">- (NSData*)encodeSuccessEnvelope:(id)result &#123;</span><br><span class="line">  NSMutableData* data = [NSMutableData dataWithCapacity:<span class="number">32</span>];</span><br><span class="line">  FlutterStandardWriter* writer = [_readerWriter writerWithData:data];</span><br><span class="line">  [writer writeByte:<span class="number">0</span>];</span><br><span class="line">  [writer writeValue:result];</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将成功数据组装成二进制数据。</p><h3 id="5-4-setMethodCallHandler-回调"><a href="#5-4-setMethodCallHandler-回调" class="headerlink" title="5.4 setMethodCallHandler 回调"></a>5.4 setMethodCallHandler 回调</h3><p>这里以 [1.1] 为例，就是获取当前电量值，然后回调 result，在通过 [5.3.3] 或 [5.3.4] 转成 NSData 后，作为入参给 Complete 调用（见[6.1]）。</p><h1 id="6-回传结果"><a href="#6-回传结果" class="headerlink" title="6. 回传结果"></a>6. 回传结果</h1><h2 id="6-1-PlatformMessageResponseDart-Complete"><a href="#6-1-PlatformMessageResponseDart-Complete" class="headerlink" title="6.1 PlatformMessageResponseDart::Complete"></a>6.1 PlatformMessageResponseDart::Complete</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// platform_message_response_dart.cc -L30</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PlatformMessageResponseDart::Complete</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;fml::Mapping&gt; data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (callback_.is_empty()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  FML_DCHECK(!is_complete_);</span><br><span class="line">  is_complete_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// 在 UI 线程中执行任务</span></span><br><span class="line">  ui_task_runner_-&gt;PostTask(fml::MakeCopyable(</span><br><span class="line">      [callback = <span class="built_in">std</span>::move(callback_), data = <span class="built_in">std</span>::move(data)]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">        <span class="comment">// callback_ 见 [3.1.1] 的赋初始值</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;tonic::DartState&gt; dart_state =</span><br><span class="line">            callback.dart_state().lock();</span><br><span class="line">        <span class="keyword">if</span> (!dart_state) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tonic::DartState::Scope scope(dart_state);</span><br><span class="line">        <span class="comment">// 见 [6.2]</span></span><br><span class="line">        Dart_Handle byte_buffer =</span><br><span class="line">            tonic::DartByteData::Create(data-&gt;GetMapping(), data-&gt;GetSize());</span><br><span class="line">        <span class="comment">// 见 [6.3]    </span></span><br><span class="line">        tonic::DartInvoke(callback.Release(), &#123;byte_buffer&#125;);</span><br><span class="line">      &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-2-DartByteData-Create"><a href="#6-2-DartByteData-Create" class="headerlink" title="6.2 DartByteData::Create"></a>6.2 DartByteData::Create</h2><blockquote><p>engine/src/flutter/third_party/tonic/typed_data/dart_byte_data.cc </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Dart_Handle <span class="title">DartByteData::Create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* data, <span class="keyword">size_t</span> length)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (length &lt; kExternalSizeThreshold) &#123;</span><br><span class="line">    <span class="keyword">auto</span> handle = DartByteData&#123;data, length&#125;.dart_handle();</span><br><span class="line">    <span class="comment">// The destructor should release the typed data.</span></span><br><span class="line">    <span class="keyword">return</span> handle;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">void</span>* buf = ::<span class="built_in">malloc</span>(length);</span><br><span class="line">    TONIC_DCHECK(buf);</span><br><span class="line">    ::<span class="built_in">memcpy</span>(buf, data, length);</span><br><span class="line">    <span class="keyword">return</span> Dart_NewExternalTypedDataWithFinalizer(</span><br><span class="line">        Dart_TypedData_kByteData, buf, length, buf, length, FreeFinalizer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 [5.4.3] 或 [5.4.4] 返回的 NSData 转成 Dart 层的 Data 类型。</p><h2 id="6-3-DartInvoke"><a href="#6-3-DartInvoke" class="headerlink" title="6.3 DartInvoke"></a>6.3 DartInvoke</h2><blockquote><p>engine/src/flutter/third_party/tonic/logging/dart_invoke.cc </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Dart_Handle <span class="title">DartInvoke</span><span class="params">(Dart_Handle closure,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;Dart_Handle&gt; args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> argc = args.size();</span><br><span class="line">  Dart_Handle* argv = <span class="keyword">const_cast</span>&lt;Dart_Handle*&gt;(args.begin());</span><br><span class="line">  <span class="comment">// 见 [6.4]</span></span><br><span class="line">  Dart_Handle handle = Dart_InvokeClosure(closure, argc, argv);</span><br><span class="line">  LogIfError(handle);</span><br><span class="line">  <span class="keyword">return</span> handle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-4-Dart-InvokeClosure"><a href="#6-4-Dart-InvokeClosure" class="headerlink" title="6.4 Dart_InvokeClosure"></a>6.4 Dart_InvokeClosure</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DART_EXPORT Dart_Handle <span class="title">Dart_InvokeClosure</span><span class="params">(Dart_Handle closure,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">int</span> number_of_arguments,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           Dart_Handle* arguments)</span> </span>&#123;</span><br><span class="line">  DARTSCOPE(Thread::Current());</span><br><span class="line">  API_TIMELINE_DURATION(T);</span><br><span class="line">  CHECK_CALLBACK_STATE(T);</span><br><span class="line">  <span class="keyword">const</span> Instance&amp; closure_obj = Api::UnwrapInstanceHandle(Z, closure);</span><br><span class="line">  <span class="keyword">if</span> (closure_obj.IsNull() || !closure_obj.IsCallable(<span class="literal">NULL</span>)) &#123;</span><br><span class="line">    RETURN_TYPE_ERROR(Z, closure, Instance);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (number_of_arguments &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Api::NewError(</span><br><span class="line">        <span class="string">&quot;%s expects argument &#x27;number_of_arguments&#x27; to be non-negative.&quot;</span>,</span><br><span class="line">        CURRENT_FUNC);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set up arguments to include the closure as the first argument.</span></span><br><span class="line">  <span class="keyword">const</span> Array&amp; args = Array::Handle(Z, Array::New(number_of_arguments + <span class="number">1</span>));</span><br><span class="line">  Object&amp; obj = Object::Handle(Z);</span><br><span class="line">  args.SetAt(<span class="number">0</span>, closure_obj);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number_of_arguments; i++) &#123;</span><br><span class="line">    obj = Api::UnwrapHandle(arguments[i]);</span><br><span class="line">    <span class="keyword">if</span> (!obj.IsNull() &amp;&amp; !obj.IsInstance()) &#123;</span><br><span class="line">      RETURN_TYPE_ERROR(Z, arguments[i], Instance);</span><br><span class="line">    &#125;</span><br><span class="line">    args.SetAt(i + <span class="number">1</span>, obj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Now try to invoke the closure.</span></span><br><span class="line">  <span class="keyword">return</span> Api::NewHandle(T, DartEntry::InvokeClosure(args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 Closure 的回调，也就是前面 [3.1] 的 <code>callback</code>, 详见 [3.1.1] 的描述，最终会调用到 [2.4.1] 的回调，也就是 [2.4.3] 中的方法。</p><h2 id="6-5-asyncComplete"><a href="#6-5-asyncComplete" class="headerlink" title="6.5 _asyncComplete"></a>6.5 _asyncComplete</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// future_impl.dart -L540</span></span><br><span class="line"><span class="keyword">void</span> _asyncComplete(FutureOr&lt;T&gt; value) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(!_isComplete);</span><br><span class="line">    <span class="comment">// Two corner cases if the value is a future:</span></span><br><span class="line">    <span class="comment">//   1. the future is already completed and an error.</span></span><br><span class="line">    <span class="comment">//   2. the future is not yet completed but might become an error.</span></span><br><span class="line">    <span class="comment">// The first case means that we must not immediately complete the Future,</span></span><br><span class="line">    <span class="comment">// as our code would immediately start propagating the error without</span></span><br><span class="line">    <span class="comment">// giving the time to install error-handlers.</span></span><br><span class="line">    <span class="comment">// However the second case requires us to deal with the value immediately.</span></span><br><span class="line">    <span class="comment">// Otherwise the value could complete with an error and report an</span></span><br><span class="line">    <span class="comment">// unhandled error, even though we know we are already going to listen to</span></span><br><span class="line">    <span class="comment">// it.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">is</span> Future&lt;T&gt;) &#123;</span><br><span class="line">      _chainFuture(value);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TODO(40014): Remove cast when type promotion works.</span></span><br><span class="line">    <span class="comment">// This would normally be `as T` but we use `as dynamic` to make the</span></span><br><span class="line">    <span class="comment">// unneeded check be implict to match dart2js unsound optimizations in the</span></span><br><span class="line">    <span class="comment">// user code.</span></span><br><span class="line">    _asyncCompleteWithValue(value <span class="keyword">as</span> <span class="built_in">dynamic</span>); <span class="comment">// Value promoted to T.</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里的 value 就是 [6.1] 的入参 data, 就是 [1.1] <code>setMethodCallHandler</code> 后回调的值，通过 Complete 异步调用后，最终会调用到 [6.6].</p><h2 id="6-6-decodeEnvelope"><a href="#6-6-decodeEnvelope" class="headerlink" title="6.6 decodeEnvelope"></a>6.6 decodeEnvelope</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// message_codecs.dart -L570</span></span><br><span class="line"><span class="built_in">dynamic</span> decodeEnvelope(ByteData envelope) &#123;</span><br><span class="line">    <span class="comment">// First byte is zero in success case, and non-zero otherwise.</span></span><br><span class="line">    <span class="keyword">if</span> (envelope.lengthInBytes == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">const</span> FormatException(<span class="string">&#x27;Expected envelope, got nothing&#x27;</span>);</span><br><span class="line">    <span class="comment">// 创建 ReadBuffer 对象</span></span><br><span class="line">    <span class="keyword">final</span> ReadBuffer buffer = ReadBuffer(envelope);</span><br><span class="line">    <span class="keyword">if</span> (buffer.getUint8() == <span class="number">0</span>)</span><br><span class="line">      <span class="comment">// 见 [6.6.1]</span></span><br><span class="line">      <span class="keyword">return</span> messageCodec.readValue(buffer);</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">dynamic</span> errorCode = messageCodec.readValue(buffer);</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">dynamic</span> errorMessage = messageCodec.readValue(buffer);</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">dynamic</span> errorDetails = messageCodec.readValue(buffer);</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">String?</span> errorStacktrace = (buffer.hasRemaining) ? messageCodec.readValue(buffer) <span class="keyword">as</span> <span class="built_in">String</span> : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (errorCode <span class="keyword">is</span> <span class="built_in">String</span> &amp;&amp; (errorMessage == <span class="keyword">null</span> || errorMessage <span class="keyword">is</span> <span class="built_in">String</span>) &amp;&amp; !buffer.hasRemaining)</span><br><span class="line">      <span class="keyword">throw</span> PlatformException(code: errorCode, message: errorMessage <span class="keyword">as</span> <span class="built_in">String</span>, details: errorDetails, stacktrace: errorStacktrace);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">const</span> FormatException(<span class="string">&#x27;Invalid envelope&#x27;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="6-6-1-readValue"><a href="#6-6-1-readValue" class="headerlink" title="6.6.1 readValue"></a>6.6.1 readValue</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dynamic</span> readValue(ReadBuffer buffer) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!buffer.hasRemaining)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">const</span> FormatException(<span class="string">&#x27;Message corrupted&#x27;</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">int</span> type = buffer.getUint8();</span><br><span class="line">    <span class="comment">// 转成 await 调用处需要的数据类型</span></span><br><span class="line">    <span class="keyword">return</span> readValueOfType(type, buffer);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="7-native-gt-dart"><a href="#7-native-gt-dart" class="headerlink" title="7. native -&gt; dart"></a>7. native -&gt; dart</h1><p>前面讲的是 dart 层异步调用 native 层，现在来讲下 native -&gt; dart 的大致逻辑，代码来自我们项目中的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)test &#123;</span><br><span class="line">    &#x2F;&#x2F; 见 [7.1]</span><br><span class="line">    [_channel invokeMethod:@&quot;didBeforeLoadRequest&quot; arguments:urlStr result:^(id  _Nullable result) &#123;</span><br><span class="line">        if ([result isKindOfClass:[NSNumber class]]) &#123;</span><br><span class="line">            if ([result boolValue]) &#123;</span><br><span class="line">                decisionHandler(WKNavigationActionPolicyAllow);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                decisionHandler(WKNavigationActionPolicyCancel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            decisionHandler(WKNavigationActionPolicyAllow);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-1-invokeMethod-arguments-result"><a href="#7-1-invokeMethod-arguments-result" class="headerlink" title="7.1 invokeMethod:arguments:result:"></a>7.1 invokeMethod:arguments:result:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FlutterChannels.mm -L219</span></span><br><span class="line">- (<span class="keyword">void</span>)invokeMethod:(NSString*)method arguments:(id)arguments result:(FlutterResult)callback &#123;</span><br><span class="line">  <span class="comment">// 初始化 FlutterMethodCall</span></span><br><span class="line">  FlutterMethodCall* methodCall = [FlutterMethodCall methodCallWithMethodName:method</span><br><span class="line">                                                                    arguments:arguments];</span><br><span class="line">  <span class="comment">// 将 FlutterMethodCall 编码成 NSData </span></span><br><span class="line">  NSData* message = [_codec encodeMethodCall:methodCall];</span><br><span class="line">  <span class="comment">// 回调操作</span></span><br><span class="line">  FlutterBinaryReply reply = ^(NSData* data) &#123;</span><br><span class="line">    <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">      callback((data == nil) ? FlutterMethodNotImplemented : [_codec decodeEnvelope:data]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 见 [7.2.1]</span></span><br><span class="line">  [_messenger sendOnChannel:_name message:message binaryReply:reply];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法主要功能：</p><ol><li>创建 <code>FlutterMethodCall</code> 对象，跟 [2.3] 是类似的</li><li>对 <code>FlutterMethodCall</code> 对象进行编码操作</li><li>reply: 对 dart 层返回的数据进行解码操作，并执行 callback 回调</li></ol><h3 id="7-2-1-sendOnChannel-message"><a href="#7-2-1-sendOnChannel-message" class="headerlink" title="7.2.1 sendOnChannel:message:"></a>7.2.1 sendOnChannel:message:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FlutterBinaryMessengerRelay.mm -L28</span></span><br><span class="line">- (<span class="keyword">void</span>)sendOnChannel:(NSString*)channel</span><br><span class="line">              message:(NSData*)message</span><br><span class="line">          binaryReply:(FlutterBinaryReply)callback &#123;</span><br><span class="line">  <span class="keyword">if</span> (self.parent) &#123;</span><br><span class="line">    <span class="comment">// 见 [7.2.2]</span></span><br><span class="line">    [self.parent sendOnChannel:channel message:message binaryReply:callback];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    FML_LOG(WARNING) &lt;&lt; <span class="string">&quot;Communicating on a dead channel.&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-2-sendOnChannel-message-binaryReply"><a href="#7-2-2-sendOnChannel-message-binaryReply" class="headerlink" title="7.2.2 sendOnChannel:message:binaryReply:"></a>7.2.2 sendOnChannel:message:binaryReply:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FlutterEngine.mm -L704</span></span><br><span class="line">- (<span class="keyword">void</span>)sendOnChannel:(NSString*)channel</span><br><span class="line">              message:(NSData*)message</span><br><span class="line">          binaryReply:(FlutterBinaryReply)callback &#123;</span><br><span class="line">  NSParameterAssert(channel);</span><br><span class="line">  NSAssert(_shell &amp;&amp; _shell-&gt;IsSetup(),</span><br><span class="line">           @<span class="string">&quot;Sending a message before the FlutterEngine has been run.&quot;</span>);</span><br><span class="line">  <span class="comment">// 创建 PlatformMessageResponseDarwin 对象，后续在 Platform 线程中执行任务，见 [7.2.3]</span></span><br><span class="line">  fml::RefPtr&lt;flutter::PlatformMessageResponseDarwin&gt; response =</span><br><span class="line">      (callback == nil) ? <span class="literal">nullptr</span></span><br><span class="line">                        : fml::MakeRefCounted&lt;flutter::PlatformMessageResponseDarwin&gt;(</span><br><span class="line">                              ^(NSData* reply) &#123;</span><br><span class="line">                                callback(reply);</span><br><span class="line">                              &#125;,</span><br><span class="line">                              _shell-&gt;GetTaskRunners().GetPlatformTaskRunner());</span><br><span class="line">  <span class="comment">// 创建 PlatformMessage 对象，跟 [3.1.3] 是类似的                           </span></span><br><span class="line">  fml::RefPtr&lt;flutter::PlatformMessage&gt; platformMessage =</span><br><span class="line">      (message == nil) ? fml::MakeRefCounted&lt;flutter::PlatformMessage&gt;(channel.UTF8String, response)</span><br><span class="line">                       : fml::MakeRefCounted&lt;flutter::PlatformMessage&gt;(</span><br><span class="line">                             channel.UTF8String, flutter::GetVectorFromNSData(message), response);</span><br><span class="line">  <span class="comment">// 见 [7.3]</span></span><br><span class="line">  _shell-&gt;GetPlatformView()-&gt;DispatchPlatformMessage(platformMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-3-PlatformMessageResponseDarwin"><a href="#7-2-3-PlatformMessageResponseDarwin" class="headerlink" title="7.2.3 PlatformMessageResponseDarwin"></a>7.2.3 PlatformMessageResponseDarwin</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// platform_message_response_darwin.mm -L9</span></span><br><span class="line">PlatformMessageResponseDarwin::PlatformMessageResponseDarwin(</span><br><span class="line">    PlatformMessageResponseCallback callback,</span><br><span class="line">    fml::RefPtr&lt;fml::TaskRunner&gt; platform_task_runner)</span><br><span class="line">    : callback_(callback, fml::OwnershipPolicy::Retain),</span><br><span class="line">      platform_task_runner_(<span class="built_in">std</span>::move(platform_task_runner)) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-4-PlatformMessageResponseDarwin-Complete"><a href="#7-3-4-PlatformMessageResponseDarwin-Complete" class="headerlink" title="7.3.4 PlatformMessageResponseDarwin::Complete"></a>7.3.4 PlatformMessageResponseDarwin::Complete</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// platform_message_response_darwin.mm -L17</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PlatformMessageResponseDarwin::Complete</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;fml::Mapping&gt; data)</span> </span>&#123;</span><br><span class="line">  <span class="function">fml::RefPtr&lt;PlatformMessageResponseDarwin&gt; <span class="title">self</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">  <span class="comment">// 在 platform 线程中执行任务</span></span><br><span class="line">  platform_task_runner_-&gt;PostTask(fml::MakeCopyable([self, data = <span class="built_in">std</span>::move(data)]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">    self-&gt;callback_.get()(GetNSDataFromMapping(<span class="built_in">std</span>::move(data)));</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>callback_</code> 就是 [7.2.2] 里面的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^(NSData* reply) &#123;</span><br><span class="line">    callback(reply);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>从而 <code>callback</code> 回调到 [7.1] 的 <code>reply</code>，最终会将调用到 [7] 的 <code>result</code> 回调，自此，整个链路就完成了。</p><h2 id="7-3-PlatformView-DispatchPlatformMessage"><a href="#7-3-PlatformView-DispatchPlatformMessage" class="headerlink" title="7.3 PlatformView::DispatchPlatformMessage"></a>7.3 PlatformView::DispatchPlatformMessage</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// platform_view.cc -L35</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PlatformView::DispatchPlatformMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    fml::RefPtr&lt;PlatformMessage&gt; message)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 见 [7.4]  </span></span><br><span class="line">  delegate_.OnPlatformViewDispatchPlatformMessage(<span class="built_in">std</span>::move(message));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>PlatformView</code> 是前面 <code>PlatformViewIOS</code> 的父类，所以看下 <code>PlatformViewIOS</code> 的初始化方法，看 <code>delegate_</code>.</p><h3 id="7-3-1-PlatformViewIOS-初始化"><a href="#7-3-1-PlatformViewIOS-初始化" class="headerlink" title="7.3.1 PlatformViewIOS 初始化"></a>7.3.1 PlatformViewIOS 初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// platform_view_ios.mm -47</span></span><br><span class="line">PlatformViewIOS::PlatformViewIOS(PlatformView::Delegate&amp; delegate,</span><br><span class="line">                                 IOSRenderingAPI rendering_api,</span><br><span class="line">                                 flutter::TaskRunners task_runners)</span><br><span class="line">    : PlatformView(delegate, <span class="built_in">std</span>::move(task_runners)),</span><br><span class="line">      ios_context_(IOSContext::Create(rendering_api)),</span><br><span class="line">      accessibility_bridge_([<span class="keyword">this</span>](<span class="keyword">bool</span> enabled) &#123; PlatformView::SetSemanticsEnabled(enabled); &#125;) &#123;&#125;</span><br></pre></td></tr></table></figure><p>由前面 [3.5] 可知，这里的 <code>delegate_</code> 就是 Shell 对象。</p><h2 id="7-4-Shell-OnPlatformViewDispatchPlatformMessage"><a href="#7-4-Shell-OnPlatformViewDispatchPlatformMessage" class="headerlink" title="7.4 Shell::OnPlatformViewDispatchPlatformMessage"></a>7.4 Shell::OnPlatformViewDispatchPlatformMessage</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shell.cc -L838</span></span><br><span class="line"><span class="comment">// |PlatformView::Delegate|</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Shell::OnPlatformViewDispatchPlatformMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    fml::RefPtr&lt;PlatformMessage&gt; message)</span> </span>&#123;</span><br><span class="line">  FML_DCHECK(is_setup_);</span><br><span class="line">  FML_DCHECK(task_runners_.GetPlatformTaskRunner()-&gt;RunsTasksOnCurrentThread());</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 在 UI 线程中执行任务  </span></span><br><span class="line">  task_runners_.GetUITaskRunner()-&gt;PostTask(</span><br><span class="line">      [engine = engine_-&gt;GetWeakPtr(), message = <span class="built_in">std</span>::move(message)] &#123;</span><br><span class="line">        <span class="keyword">if</span> (engine) &#123;</span><br><span class="line">          <span class="comment">// 见 [7.5]  </span></span><br><span class="line">          engine-&gt;DispatchPlatformMessage(<span class="built_in">std</span>::move(message));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-5-Engine-DispatchPlatformMessage"><a href="#7-5-Engine-DispatchPlatformMessage" class="headerlink" title="7.5 Engine::DispatchPlatformMessage"></a>7.5 Engine::DispatchPlatformMessage</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// engine.cc -L333</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Engine::DispatchPlatformMessage</span><span class="params">(fml::RefPtr&lt;PlatformMessage&gt; message)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 判断相关 channel 名，在调用前面 [4.1] setupChannels 方法的时候，会设置这些 channel</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> channel = message-&gt;channel();</span><br><span class="line">  <span class="keyword">if</span> (channel == kLifecycleChannel) &#123;</span><br><span class="line">    <span class="keyword">if</span> (HandleLifecyclePlatformMessage(message.get())) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (channel == kLocalizationChannel) &#123;</span><br><span class="line">    <span class="keyword">if</span> (HandleLocalizationPlatformMessage(message.get())) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (channel == kSettingsChannel) &#123;</span><br><span class="line">    HandleSettingsPlatformMessage(message.get());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!runtime_controller_-&gt;IsRootIsolateRunning() &amp;&amp;</span><br><span class="line">             channel == kNavigationChannel) &#123;</span><br><span class="line">    <span class="comment">// If there&#x27;s no runtime_, we may still need to set the initial route.</span></span><br><span class="line">    HandleNavigationPlatformMessage(<span class="built_in">std</span>::move(message));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在主 isolate 中执行任务</span></span><br><span class="line">  <span class="keyword">if</span> (runtime_controller_-&gt;IsRootIsolateRunning() &amp;&amp;</span><br><span class="line">      <span class="comment">// 见 [7.6]</span></span><br><span class="line">      runtime_controller_-&gt;DispatchPlatformMessage(<span class="built_in">std</span>::move(message))) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  FML_DLOG(WARNING) &lt;&lt; <span class="string">&quot;Dropping platform message on channel: &quot;</span> &lt;&lt; channel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-6-RuntimeController-DispatchPlatformMessage"><a href="#7-6-RuntimeController-DispatchPlatformMessage" class="headerlink" title="7.6 RuntimeController::DispatchPlatformMessage"></a>7.6 RuntimeController::DispatchPlatformMessage</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RuntimeController::DispatchPlatformMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    fml::RefPtr&lt;PlatformMessage&gt; message)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span>* platform_configuration = GetPlatformConfigurationIfAvailable()) &#123;</span><br><span class="line">    TRACE_EVENT1(<span class="string">&quot;flutter&quot;</span>, <span class="string">&quot;RuntimeController::DispatchPlatformMessage&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;mode&quot;</span>, <span class="string">&quot;basic&quot;</span>);</span><br><span class="line">    <span class="comment">// 见 [7.7]             </span></span><br><span class="line">    platform_configuration-&gt;DispatchPlatformMessage(<span class="built_in">std</span>::move(message));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-7-PlatformConfiguration-DispatchPlatformMessage"><a href="#7-7-PlatformConfiguration-DispatchPlatformMessage" class="headerlink" title="7.7 PlatformConfiguration::DispatchPlatformMessage"></a>7.7 PlatformConfiguration::DispatchPlatformMessage</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PlatformConfiguration::DispatchPlatformMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    fml::RefPtr&lt;PlatformMessage&gt; message)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;tonic::DartState&gt; dart_state = library_.dart_state().lock();</span><br><span class="line">  <span class="keyword">if</span> (!dart_state) &#123;</span><br><span class="line">    FML_DLOG(WARNING)</span><br><span class="line">        &lt;&lt; <span class="string">&quot;Dropping platform message for lack of DartState on channel: &quot;</span></span><br><span class="line">        &lt;&lt; message-&gt;channel();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  tonic::<span class="function">DartState::Scope <span class="title">scope</span><span class="params">(dart_state)</span></span>;</span><br><span class="line">  <span class="comment">// message-&gt;hasData() 是前面 [7.1] 中的 FlutterMethodCall 对象</span></span><br><span class="line">  Dart_Handle data_handle =</span><br><span class="line">      (message-&gt;hasData()) ? ToByteData(message-&gt;data()) : Dart_Null();</span><br><span class="line">  <span class="keyword">if</span> (Dart_IsError(data_handle)) &#123;</span><br><span class="line">    FML_DLOG(WARNING)</span><br><span class="line">        &lt;&lt; <span class="string">&quot;Dropping platform message because of a Dart error on channel: &quot;</span></span><br><span class="line">        &lt;&lt; message-&gt;channel();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> response_id = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 跟 response_id 和 response 关联起来，由前面 [7.2.2] 可知这里 message-&gt;response() 为空</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> response = message-&gt;response()) &#123;</span><br><span class="line">    response_id = next_response_id_++;</span><br><span class="line">    pending_responses_[response_id] = response;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// native -&gt; dart, 见 [7.8]  </span></span><br><span class="line">  tonic::LogIfError(</span><br><span class="line">      tonic::DartInvokeField(library_.value(), <span class="string">&quot;_dispatchPlatformMessage&quot;</span>,</span><br><span class="line">                             &#123;tonic::ToDart(message-&gt;channel()), data_handle,</span><br><span class="line">                              tonic::ToDart(response_id)&#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-8-dispatchPlatformMessage"><a href="#7-8-dispatchPlatformMessage" class="headerlink" title="7.8 _dispatchPlatformMessage"></a>7.8 _dispatchPlatformMessage</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hooks.dart -L144</span></span><br><span class="line"><span class="meta">@pragma</span>(<span class="string">&#x27;vm:entry-point&#x27;</span>)</span><br><span class="line"><span class="comment">// ignore: unused_element</span></span><br><span class="line"><span class="keyword">void</span> _dispatchPlatformMessage(<span class="built_in">String</span> name, ByteData? data, <span class="built_in">int</span> responseId) &#123;</span><br><span class="line">  <span class="keyword">if</span> (name == ChannelBuffers.kControlChannelName) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      channelBuffers.handleMessage(data!);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">      _printDebug(<span class="string">&#x27;Message to &quot;<span class="subst">$name</span>&quot; caused exception <span class="subst">$ex</span>&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="built_in">window</span>._respondToPlatformMessage(responseId, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.onPlatformMessage != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 见 [7.8.1]</span></span><br><span class="line">    _invoke3&lt;<span class="built_in">String</span>, ByteData?, PlatformMessageResponseCallback&gt;(</span><br><span class="line">      <span class="built_in">window</span>.onPlatformMessage,</span><br><span class="line">      <span class="built_in">window</span>._onPlatformMessageZone,</span><br><span class="line">      name,</span><br><span class="line">      data,</span><br><span class="line">      (ByteData? responseData) &#123;</span><br><span class="line">        <span class="built_in">window</span>._respondToPlatformMessage(responseId, responseData);</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    channelBuffers.push(name, data, (ByteData? responseData) &#123;</span><br><span class="line">      <span class="built_in">window</span>._respondToPlatformMessage(responseId, responseData);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-8-1"><a href="#7-8-1" class="headerlink" title="7.8.1"></a>7.8.1</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hooks.dart -L270</span></span><br><span class="line"><span class="comment">/// <span class="markdown">Invokes [callback] inside the given [zone] passing it [arg1], [arg2], and [arg3].</span></span></span><br><span class="line"><span class="keyword">void</span> _invoke3&lt;A1, A2, A3&gt;(<span class="keyword">void</span> callback(A1 a1, A2 a2, A3 a3)?, Zone zone, A1 arg1, A2 arg2, A3 arg3) &#123;</span><br><span class="line">  <span class="keyword">if</span> (callback == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">assert</span>(zone != <span class="keyword">null</span>); <span class="comment">// ignore: unnecessary_null_comparison</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (identical(zone, Zone.current)) &#123;</span><br><span class="line">    callback(arg1, arg2, arg3);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    zone.runGuarded(() &#123;</span><br><span class="line">      callback(arg1, arg2, arg3);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在给定的 Zone 里面，根据参数回调 callback.</p><ul><li>callback: window.onPlatformMessage, 见 [7.9]</li><li>zone: window._onPlatformMessageZone</li><li>arg1: name // channel 名</li><li>arg2: data // FlutterMethodCall 对象，见 [7.7]</li><li>arg3: window._respondToPlatformMessage, 见 [7.10]</li></ul><h2 id="7-9-onPlatformMessage"><a href="#7-9-onPlatformMessage" class="headerlink" title="7.9 onPlatformMessage"></a>7.9 onPlatformMessage</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listens for platform messages and directs them to the [defaultBinaryMessenger].</span></span><br><span class="line"><span class="keyword">mixin</span> ServicesBinding <span class="keyword">on</span> BindingBase, SchedulerBinding &#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initInstances();</span><br><span class="line">    _instance = <span class="keyword">this</span>;</span><br><span class="line">    _defaultBinaryMessenger = createBinaryMessenger();</span><br><span class="line">    _restorationManager = createRestorationManager();</span><br><span class="line">    <span class="comment">// 见 [7.9.1]</span></span><br><span class="line">    <span class="built_in">window</span>.onPlatformMessage = defaultBinaryMessenger.handlePlatformMessage;</span><br><span class="line">    initLicenses();</span><br><span class="line">    SystemChannels.system.setMessageHandler((<span class="built_in">dynamic</span> message) =&gt; handleSystemMessage(message <span class="keyword">as</span> <span class="built_in">Object</span>));</span><br><span class="line">    SystemChannels.lifecycle.setMessageHandler(_handleLifecycleMessage);</span><br><span class="line">    readInitialLifecycleStateFromNativeWindow();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="7-9-1-handlePlatformMessage"><a href="#7-9-1-handlePlatformMessage" class="headerlink" title="7.9.1 handlePlatformMessage"></a>7.9.1 handlePlatformMessage</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="keyword">void</span>&gt; handlePlatformMessage(</span><br><span class="line">    <span class="built_in">String</span> channel,</span><br><span class="line">    ByteData? data,</span><br><span class="line">    ui.PlatformMessageResponseCallback? callback,</span><br><span class="line">  ) <span class="keyword">async</span> &#123;</span><br><span class="line">    ByteData? response;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 获取 handler, 跟 [3.6] 类似，现在的问题是在哪里设置的 _handlers 呢？见 [7.13]</span></span><br><span class="line">      <span class="keyword">final</span> MessageHandler? handler = _handlers[channel];</span><br><span class="line">      <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 执行 handler </span></span><br><span class="line">        response = <span class="keyword">await</span> handler(data);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ui.channelBuffers.push(channel, data, callback!);</span><br><span class="line">        callback = <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (exception, stack) &#123;</span><br><span class="line">      FlutterError.reportError(FlutterErrorDetails(</span><br><span class="line">        exception: exception,</span><br><span class="line">        stack: stack,</span><br><span class="line">        <span class="keyword">library</span>: <span class="string">&#x27;services library&#x27;</span>,</span><br><span class="line">        context: ErrorDescription(<span class="string">&#x27;during a platform message callback&#x27;</span>),</span><br><span class="line">      ));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 回调 response, 见 [7.10]</span></span><br><span class="line">        callback(response);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="7-10-respondToPlatformMessage"><a href="#7-10-respondToPlatformMessage" class="headerlink" title="7.10 _respondToPlatformMessage"></a>7.10 _respondToPlatformMessage</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// window -L1216, 见 [7.11]</span></span><br><span class="line"><span class="comment">/// <span class="markdown">Called by [<span class="emphasis">_dispatchPlatformMessage].</span></span></span></span><br><span class="line">  <span class="keyword">void</span> _respondToPlatformMessage(<span class="built_in">int</span> responseId, ByteData? data)</span><br><span class="line">      native <span class="string">&#x27;PlatformConfiguration_respondToPlatformMessage&#x27;</span>;</span><br></pre></td></tr></table></figure><p><code>_dispatchPlatformMessage</code> 会调用 <code>_respondToPlatformMessage</code> 方法，而 <code>_respondToPlatformMessage</code> 又是一个 native 方法。</p><h2 id="7-11-RespondToPlatformMessage"><a href="#7-11-RespondToPlatformMessage" class="headerlink" title="7.11 _RespondToPlatformMessage"></a>7.11 _RespondToPlatformMessage</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// platform_configuration.cc -L159</span></span><br><span class="line"><span class="keyword">void</span> _RespondToPlatformMessage(Dart_NativeArguments args) &#123;</span><br><span class="line">  tonic::DartCallStatic(&amp;RespondToPlatformMessage, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// platform_configuration.cc -L141</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RespondToPlatformMessage</span><span class="params">(Dart_Handle window,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> response_id,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">const</span> tonic::DartByteData&amp; data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Dart_IsNull(data.dart_handle())) &#123;</span><br><span class="line">    UIDartState::Current()</span><br><span class="line">        -&gt;platform_configuration()</span><br><span class="line">        -&gt;CompletePlatformMessageEmptyResponse(response_id);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// TODO(engine): Avoid this copy.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span>* buffer = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(data.data());</span><br><span class="line">    <span class="comment">// 见 [7.11.1]</span></span><br><span class="line">    UIDartState::Current()</span><br><span class="line">        -&gt;platform_configuration()</span><br><span class="line">        -&gt;CompletePlatformMessageResponse(</span><br><span class="line">            response_id,</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint8_t</span>&gt;(buffer, buffer + data.length_in_bytes()));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-11-1-PlatformConfiguration-CompletePlatformMessageResponse"><a href="#7-11-1-PlatformConfiguration-CompletePlatformMessageResponse" class="headerlink" title="7.11.1 PlatformConfiguration::CompletePlatformMessageResponse"></a>7.11.1 PlatformConfiguration::CompletePlatformMessageResponse</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PlatformConfiguration::CompletePlatformMessageResponse</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> response_id,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint8_t</span>&gt; data)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这 response_id 为 0, 对应着 [7.1] result 入参为 nil 的情况</span></span><br><span class="line">  <span class="keyword">if</span> (!response_id) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> it = pending_responses_.find(response_id);</span><br><span class="line">  <span class="comment">// 根据 response_id 没找到内容</span></span><br><span class="line">  <span class="keyword">if</span> (it == pending_responses_.end()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取 [7.7] 的 message-&gt;response(), 对应 [7.2.2] 的 response 对象</span></span><br><span class="line">  <span class="keyword">auto</span> response = <span class="built_in">std</span>::move(it-&gt;second);</span><br><span class="line">  <span class="comment">// 移除该回调</span></span><br><span class="line">  pending_responses_.erase(it);</span><br><span class="line">  <span class="comment">// 见 [7.3.4]</span></span><br><span class="line">  response-&gt;Complete(<span class="built_in">std</span>::make_unique&lt;fml::DataMapping&gt;(<span class="built_in">std</span>::move(data)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-12-setMethodCallHandler"><a href="#7-12-setMethodCallHandler" class="headerlink" title="7.12 setMethodCallHandler"></a>7.12 setMethodCallHandler</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// paltform_channel.dart -L377</span></span><br><span class="line"><span class="keyword">void</span> setMethodCallHandler(Future&lt;<span class="built_in">dynamic</span>&gt; <span class="built_in">Function</span>(MethodCall call)? handler) &#123;</span><br><span class="line">    <span class="comment">// 见 MethodChannel(this) 和 handler 关联起来 </span></span><br><span class="line">    _methodChannelHandlers[<span class="keyword">this</span>] = handler;</span><br><span class="line">    <span class="comment">// 见 [7.13]</span></span><br><span class="line">    binaryMessenger.setMessageHandler(</span><br><span class="line">      name,</span><br><span class="line">      handler == <span class="keyword">null</span></span><br><span class="line">        ? <span class="keyword">null</span></span><br><span class="line">        : (ByteData? message) =&gt; _handleAsMethodCall(message, handler),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="7-13-setMessageHandler"><a href="#7-13-setMessageHandler" class="headerlink" title="7.13 setMessageHandler"></a>7.13 setMessageHandler</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binding.dart -L311</span></span><br><span class="line"><span class="keyword">void</span> setMessageHandler(<span class="built_in">String</span> channel, MessageHandler? handler) &#123;</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>)</span><br><span class="line">      _handlers.remove(channel);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      _handlers[channel] = handler;</span><br><span class="line">      ui.channelBuffers.drain(channel, (ByteData? data, ui.PlatformMessageResponseCallback callback) <span class="keyword">async</span> &#123;</span><br><span class="line">       <span class="keyword">await</span> handlePlatformMessage(channel, data, callback);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里跟前面 [7.9.1] 串联起来了，对 <code>_handlers</code> 进行赋值。</p><h1 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h1><h2 id="8-1-调用链路"><a href="#8-1-调用链路" class="headerlink" title="8.1 调用链路"></a>8.1 调用链路</h2><h3 id="8-1-1-dart-gt-native"><a href="#8-1-1-dart-gt-native" class="headerlink" title="8.1.1 dart -&gt; native"></a>8.1.1 dart -&gt; native</h3><p>调用流程如下：</p><p><img src="https://sat02pap001files.storage.live.com/y4mUGGI2r5i-neno2THQeatT_9IYs5sjV5WBa3nWViDRBvGyKMW4bb7YCEwaZ0301WYHyushCicJOcKu__8oWsEYxJYuvnyKNiWYno_Dc-ahUlx8DoQFNmbi1dJYSNDF2UQocAp9kI6gczqy1xeP092Zq059i_o8kiNDkUA2fbVtqFqo3si12taxoHuocX89LSZ?width=1853&height=653&cropmode=none"></p><p>赋值 handler 流程图如下：<br><img src="https://sat02pap001files.storage.live.com/y4m-rYn8D1lzoPq_wbVvKy3EG6enZmedcNaBygocaNLZcdhSZeNYKXmP680OXlMqRjy7gHBixIXWcDiG9M3HusQuoTt8tRZP8l332NODfLERsK4nqIuhb8-x6ZySt9NsU3-NL3Sdd43joTTZ1rZ0AqR4djHPQzMPZbS2-g6xR8siN8pEl1pengn-_ghou21p20K?width=843&height=483&cropmode=none"></p><p>method channel 的执行涉及到主线程和UI线程的交互，代码调用从 dart -&gt; shell -&gt; native(ios), 执行完成后再原路返回 native(ios) -&gt; shell -&gt; dart.</p><ul><li>3.4 Shell::OnEngineHandlePlatformMessage, 在 UI 线程(io.flutter.1.ui), 将任务派发给主线程</li><li>6.1 PlatformMessageResponseDart::Complete, 在主线程(platform), 将任务派发给 UI 线程</li></ul><h3 id="8-1-2-native-gt-dart"><a href="#8-1-2-native-gt-dart" class="headerlink" title="8.1.2 native -&gt; dart"></a>8.1.2 native -&gt; dart</h3><p>调用流程如下：</p><p><img src="https://sat02pap001files.storage.live.com/y4mYWALpdQzLwOseOw8dbeMIzvvFQHdZzr8fEblvx10FYnSauMk-KRCNCVxgYPcZi_ooUOOGJ69jnQVjA-nKBpq-fdPzXuc2Ihwydb02HooyXOBIuUeXQGDFI2swtmsmgSFtaGVO_qHp6cQriPABQCkVdUDa83T_4F72eeaHOMvJyarXiwZ0kaSiNIcwsrjBMfi?width=2223&height=923&cropmode=none"></p><p>同 [8.1.1],  method channel 的执行涉及到主线程和UI线程的交互，代码调用从 native(ios) -&gt; shell -&gt; dart, 执行完成后再原路返回 dart -&gt; shell -&gt; native(ios).</p><ul><li>7.3.4 PlatformMessageResponseDarwin::Complete, 在 UI 线程(io.flutter.1.ui), 将任务派发给主线程</li><li>7.4 Shell::OnPlatformViewDispatchPlatformMessage,  在主线程(platform), 将任务派发给 UI 线程</li></ul><h2 id="8-2-相关概念"><a href="#8-2-相关概念" class="headerlink" title="8.2 相关概念"></a>8.2 相关概念</h2><ol><li>shell </li><li>isolate(和线程的关系)</li><li>ui platform 等线程，flutter 中有多少线程？</li><li>future Complete 异步调用</li><li>dart 和 native(ios) 中的相关编解码类</li></ol><h2 id="8-3-问题"><a href="#8-3-问题" class="headerlink" title="8.3 问题"></a>8.3 问题</h2><ol><li>dart 层和 native 层数据通信的本质是什么？</li><li>怎么监控 platform channel 的执行过程，方便调试？</li></ol><p>answer</p><ol><li>看源码可知，双方交互都是传递二进制数据，然后通过双方的编解码类来转成当前层所需要的对象，所以是二进制数据流；</li><li>可以自定义一个 <code>BinaryMessenger</code> 类，然后替换系统的 <code>ServicesBinding.defaultBinaryMessenger</code>，从而达到监控的目的；</li></ol><h1 id="10-参考链接"><a href="#10-参考链接" class="headerlink" title="10. 参考链接"></a>10. 参考链接</h1><ul><li><a href="https://flutter.dev/docs/development/platform-integration/platform-channels">Writing custom platform-specific code</a></li><li><a href="http://gityuan.com/2019/08/10/flutter_channel/">深入理解Flutter的Platform Channel机制</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文基于 flutter 1.22.2 源码，在 ios_debug_unopt 产物下调试。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.
      
    
    </summary>
    
      <category term="flutter" scheme="http://example.com/categories/flutter/"/>
    
    
      <category term="flutter" scheme="http://example.com/tags/flutter/"/>
    
      <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>矩阵翻转</title>
    <link href="http://example.com/2021/02/24/matrix-flip/"/>
    <id>http://example.com/2021/02/24/matrix-flip/</id>
    <published>2021-02-24T14:16:56.000Z</published>
    <updated>2021-02-24T15:01:37.201Z</updated>
    
    <content type="html"><![CDATA[<p>在做今天的每日一题：<a href="https://leetcode-cn.com/problems/flipping-an-image/">832. 翻转图像</a>时，看到了之前的笔记，里面提到了一道类似的题目<a href="https://leetcode-cn.com/problems/rotate-image/">48. 旋转图像</a>，如果没记错的话，它应该是去年的一道每日一题。当时还想着要把沿对角线翻转的代码给记住的，但是现在也不记得了，为了完成去年前的任务，晚上花了点时间把相关翻转代码记录一下。</p><h1 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h1><p>给定一个 <code>n × n</code> 的二维矩阵 <code>matrix</code>(eg: <code>[[1,2,3],[4,5,6],[7,8,9]]</code>)，在遍历中分别输出行下标(i)和列表(j)的值。<br>以下的代码，记住画个图再来推理一篇，记忆效果会更好。</p><h2 id="水平上下翻转"><a href="#水平上下翻转" class="headerlink" title="水平上下翻转"></a>水平上下翻转</h2><p>行和是 n-1, 遍历一半；列正常处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n/<span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        swap(matrix[i][j], matrix[n-i<span class="number">-1</span>][j]);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;[&#x27;</span> &lt;&lt; i &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27;]&#x27;</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[0,0]</span></span><br><span class="line"><span class="comment">[0,1]</span></span><br><span class="line"><span class="comment">[0,2]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="垂直左右翻转"><a href="#垂直左右翻转" class="headerlink" title="垂直左右翻转"></a>垂直左右翻转</h2><p>行正常处理；列和是 n-1, 遍历一半。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n/<span class="number">2</span>; j++) &#123;</span><br><span class="line">        swap(matrix[i][j], matrix[i][n-j<span class="number">-1</span>]);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;[&#x27;</span> &lt;&lt; i &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27;]&#x27;</span>&lt;&lt; <span class="built_in">endl</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[0,0]</span></span><br><span class="line"><span class="comment">[1,0]</span></span><br><span class="line"><span class="comment">[2,0]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="主对角线（左上-右下）翻转"><a href="#主对角线（左上-右下）翻转" class="headerlink" title="主对角线（左上-右下）翻转"></a>主对角线（左上-右下）翻转</h2><p>交换i, j.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">        swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;[&#x27;</span> &lt;&lt; i &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27;]&#x27;</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[1,0]</span></span><br><span class="line"><span class="comment">[2,0]</span></span><br><span class="line"><span class="comment">[2,1]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="副对角线（右上-左下）翻转"><a href="#副对角线（右上-左下）翻转" class="headerlink" title="副对角线（右上-左下）翻转"></a>副对角线（右上-左下）翻转</h2><p>交换i, j.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n-i<span class="number">-1</span>; j++) &#123;</span><br><span class="line">        swap(matrix[i][j], matrix[n-j<span class="number">-1</span>][n-i<span class="number">-1</span>]);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[0,0]</span></span><br><span class="line"><span class="comment">[0,1]</span></span><br><span class="line"><span class="comment">[1,0]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="套路"><a href="#套路" class="headerlink" title="套路"></a>套路</h1><ol><li>顺时针90度：主对角线（左上-右下）翻转，再垂直左右翻转</li><li>逆时针90度：主对角线（左上-右下）翻转，再水平上下翻转</li><li>顺时针180度：主对角线（左上-右下）翻转，再副对角线（右上-左下）翻转</li><li>逆时针180度：主对角线（左上-右下）翻转，再副对角线（右上-左下）翻转</li></ol><h2 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a>48. 旋转图像</h2><blockquote><p>顺时针旋转 90 度。</p></blockquote><p>用套路1.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size();</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 主对角线翻转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                myswap(matrix[i][j], matrix[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 垂直左右翻转</span></span><br><span class="line">        <span class="keyword">int</span> mid = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; j++) &#123;</span><br><span class="line">                myswap(matrix[i][j], matrix[i][n-j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">myswap</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">        a = a ^ b;</span><br><span class="line">        b = a ^ b;</span><br><span class="line">        a = a ^ b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在做今天的每日一题：&lt;a href=&quot;https://leetcode-cn.com/problems/flipping-an-image/&quot;&gt;832. 翻转图像&lt;/a&gt;时，看到了之前的笔记，里面提到了一道类似的题目&lt;a href=&quot;https://leetcode-cn.
      
    
    </summary>
    
    
      <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="经验" scheme="http://example.com/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="http://example.com/2021/01/23/binary-search/"/>
    <id>http://example.com/2021/01/23/binary-search/</id>
    <published>2021-01-22T23:34:04.000Z</published>
    <updated>2021-01-25T15:07:50.354Z</updated>
    
    <content type="html"><![CDATA[<p>二分查找，就是在一个区间内查找某个值(eg: target)的时候，每次把区间一分为二，然后选择满足性质的区间(即包含 target)继续一分为二，直到区间长度为一。</p><a id="more"></a><p>最开始刷二分题的时候，比较慢，可能自己没整理好的一个通用的思路，自从用了 <code>y总</code> 的<a href="https://www.acwing.com/activity/content/introduction/11/">模板</a>后，就离不开了，真的很爽。</p><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/blog/content/277/</span></span><br></pre></td></tr></table></figure><p>其实，上面模板的代码分别对应两种情况</p><ul><li>bsearch_1: 找左边界，不断的向左逼近，比如：求 &gt;=x 的最小值</li><li>bsearch_2: 找右边界，不断的向右逼近，比如：求 &lt;=x 的最大值</li></ul><p>画个图，来加深下理解；</p><p><img src="https://sat02pap001files.storage.live.com/y4mm9IE6dO1rua4myJIoyNT1t8_hVGQaUBQBHG6YB5B7yzoWYKdyavWhk_Dr-DfvKWsS4qvgTubCyuhq2C0Rc1MChrZVIZ6UEAxbgqulbIBT5AH6jTHOBpH3-FFfJSKGoe4dULaybBJ_pRMlI5ttQv6xooTGlVTydUHFCX8mP1e8rDXd6UA5wzSHDgmHgfWR6TT?width=2650&height=648&cropmode=none"></p><p>上图中，红色的区间是满足性质的，反之绿色的则不满足性质，而模板中的 <code>check(mid)</code> 函数就是用来判断是否满足性质，从而将区间一分为二。</p><ul><li>bsearch_1<ul><li>true: 满足性质，区间变成：[l, mid], 不断的向左逼近，找左边界</li><li>false: 不足，区间变成：[mid+1, r]</li></ul></li><li>bsearch_2<ul><li>true: [mid, r], 不断的向右逼近，找右边界</li><li>false: [l, mid-1]</li></ul></li></ul><p>注意点</p><ol><li>循环退出条件是 <code>while(l &lt; r)</code>, 不是 <code>while(l &lt;= r)</code>；因为当 <code>while(l &lt; r)</code> 时，当条件是 <code>l &gt;= r</code> 就会退出，而这里则是 <code>l == r</code>； </li><li><code>check(mid)</code> 是用来判断 <code>mid</code> 是否满足某种性质的，并且 <code>mid</code> 是在所满足性质区间内的；</li><li><code>bsearch_2</code> 里面的 <code>mid = l + r + 1 &gt;&gt; 1;</code>，对比 <code>bsearch_1</code> 为什么要加 <code>+1</code> 呢？因为 <code>C++</code> 是下取整的，当 <code>l = r-1</code> 时，<code>mid = l+r&gt;&gt;1 = r+r-1&gt;&gt;1 = r-1=l</code>，当满足性质时，<code>l = mid = l</code>，此时 <code>l</code> 的值没发生变化，这样就发生死循环了</li></ol><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>解题思路总结</strong>：</p><ol><li>先画图，确定二分的边界(找左边界还是右边界)</li><li>根据边界来设计一个<code>check</code> 函数（满足某种性质）</li><li>判断区间怎么更新，决定是 <code>l = mid</code> 还是 <code>r = mid</code></li></ol><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p>刷几道 lc 来找下感觉，巩固下模板知识。</p><h2 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a>704. 二分查找</h2><p><a href="https://leetcode-cn.com/problems/binary-search/">704. 二分查找</a>.</p><p>一道很基础的题目，在升序数组里面找一个数，这里即可以找左边界，也可以找右边界，按上面的<strong>解题思路总结</strong>来考虑一下这道题。</p><ol><li>左边界(bsearch_1)<ol><li>check 函数：<code>nums[mid] &gt;= target</code>，则不断的向左逼近</li><li>因为是找左边界，所以是 <code>r = mid</code>；</li></ol></li><li>右边界(bsearch_2)<ol><li>check 函数：<code>nums[mid] &lt;= target</code>，则不断的向左逼近（跟左边界的代码是相对的）</li><li>因为是找右边界，所以是 <code>l = mid</code>；</li></ol></li></ol><h3 id="bsearch-1"><a href="#bsearch-1" class="headerlink" title="bsearch_1"></a>bsearch_1</h3><p><strong>找左边界，不断的向左逼近，找 <code>&gt;= target</code> 的最小值。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[l] != target) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="bsearch-2"><a href="#bsearch-2" class="headerlink" title="bsearch_2"></a>bsearch_2</h3><p><strong>找右边界，不断的向右逼近，找 <code>&lt;= target</code> 的最大值。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r+<span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[l] != target) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h2><p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></p><p>这题跟上题是一样的思路，套用模板直接求第一个位置和最后一个位置的数即可。</p><ul><li>第一个位置：见 704. 二分查找 - bsearch_1;</li><li>最后一个位置：见 704. 二分查找 - bsearch_2;</li></ul><h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a>33. 搜索旋转排序数组</h2><p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></p><p>这道题目的数据并不是单调的，但也是可以用二分的，我们需要发现其中的性质。</p><p><img src="https://sat02pap001files.storage.live.com/y4mqOQEcq3hX3_xryQqB9yFCrJa1zvw4xGLkV_nS61wxy0XsvKbymPAkARAWomghQHWezSymg4inF_9r9zlb1vSOwuYEzPCo1IjqkJuPVmaAJRMeggpCs2rvRS9YK4aZn5tJbFIb1WPI7DdDtxP7PNm-9O4nIG0KUr4o7kCGk6dWlIKrmjY-_5M7e4wPoWf7X-e?width=1256&height=824&cropmode=none"></p><p>发现上面的数据是有二段性的，即两个区间是有序的，如果我们能确定 <code>target</code> 在某一个区间，那么就可以在这个区间里面用二分了。<br>那怎么确定 <code>target</code> 在哪一个区间呢？这个简单，由于数组没有重复元素，第一段的最小值肯定大于第二段的最大值，我们只需要用 <code>target</code> 跟第二段的最大值（即数组最后一个元素）作比较即可。<br>那我们怎么判断找到这两个区间呢？也就是找到一个位置，把数组分成两个区间，可以遍历一次，如果 <code>nums[i+1]</code> 小于 <code>nums[i]</code>，则说明 <code>[0, i]</code> 属于第一段，而 <code>[i+1, n-1]</code> 属于第二段，是否能用二分找到这个区间呢？也就是找到这个区间的最大值或者最小值，然后根据这里两个极值把数组分成两个区间。<br>我们先以求最大值为例。</p><h3 id="最大值"><a href="#最大值" class="headerlink" title="最大值"></a>最大值</h3><p>按上面的<strong>解题思路总结</strong>来考虑一下这道题。</p><ol><li>边界在哪？求最大值，有因为是递增的，肯定在右边</li><li><code>check</code> 函数？<code>&gt;= nums[0]</code> 就行，不断向右逼近</li><li>区间更新？向右逼近，肯定是 <code>l = mid;</code></li></ol><p>好，开干。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= nums[<span class="number">0</span>]) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// l 和 r 就是最大值的下标</span></span><br><span class="line">        <span class="keyword">if</span> (target &lt;= nums.back()) &#123; <span class="comment">// 在第二个区间</span></span><br><span class="line">            l++, r = nums.size()<span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">        防止某种 case: [1], 0 的情况，导致</span></span><br><span class="line"><span class="comment">        l = 1, r = 0 的情况。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">            l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// bsearch_2, 这里用 bsearch_1 也是 OK 的，同 704</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[r] != target) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最小值"><a href="#最小值" class="headerlink" title="最小值"></a>最小值</h3><p>解题思路同上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= nums.back()) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// l 和 r 就是最大值的下标</span></span><br><span class="line">        <span class="keyword">if</span> (target &lt;= nums.back()) &#123; <span class="comment">// 在第二区间</span></span><br><span class="line">            r = nums.size()<span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = <span class="number">0</span>, r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// bsearch_1, 这里用 bsearch_2 也是 OK 的，同 704</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[l] != target) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用这里找最小值的思路就能解决 <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a> 了。</p><h2 id="81-搜索旋转排序数组-II"><a href="#81-搜索旋转排序数组-II" class="headerlink" title="81. 搜索旋转排序数组 II"></a>81. 搜索旋转排序数组 II</h2><p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/">81. 搜索旋转排序数组 II</a></p><p>跟 33 的区别在于：这道题有重复数，那这个思路还行的同吗？</p><p>通过 33 的图，并结合这里的题意可知，只有第一个区间前面的数和第二个区间后面的数会重复，而这里题意是 <code>编写一个函数来判断给定的目标值是否存在于数组中。</code>，所以我们把重复数给移除掉的话，是不影响结果的，这样就能用 33 的思路来解决了，具体思路见代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> R = r;</span><br><span class="line">        <span class="keyword">while</span> (R &gt;= <span class="number">0</span> &amp;&amp; nums[<span class="number">0</span>] == nums[R]) R--;</span><br><span class="line">        <span class="comment">// 数组元素全相同</span></span><br><span class="line">        <span class="keyword">if</span> (R &lt; <span class="number">0</span>) <span class="keyword">return</span> nums[<span class="number">0</span>] == target;</span><br><span class="line">        </span><br><span class="line">        l = <span class="number">0</span>, r = R;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= nums[<span class="number">0</span>]) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (target &gt;= nums[<span class="number">0</span>]) &#123;</span><br><span class="line">            l = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l++, r = R;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前面 l++ 可能会导致 l &gt; r</span></span><br><span class="line">        <span class="keyword">return</span> nums[r] == target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用这种去重的思路，同样能解决 <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">154. 寻找旋转排序数组中的最小值 II</a>。</p><h2 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title="69. x 的平方根"></a>69. x 的平方根</h2><p><a href="https://leetcode-cn.com/problems/sqrtx/">69. x 的平方根</a></p><ol><li>确定边界？这里需要返回一个数开平方根后的整数，如果一个数开平方根后的值 <code>result</code> 恰好是整数，那就直接返回 <code>result</code> ；如果是小数呢？结合题目的 <code>示例 2</code> 可知，应该返回 <code>&lt;= result</code> 的最大整数，所以这里是找右边界；</li><li><code>check</code> 函数？ <code>mid &lt;= x/mid</code></li><li>区间更新？向右逼近，肯定是 <code>l = mid;</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = x;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="comment">// +1ll, 防止 int 数据溢出</span></span><br><span class="line">            <span class="keyword">int</span> mid = (l+r+<span class="number">1ll</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (mid &lt;= x/mid) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>Q: 找左边界可以吗？<br>A: 当然是可以的，不过逻辑稍微会复杂点，因为 C++ 里除法是下取整，所以划分的区间是 <code>[0, [mid][下取整]]</code> 和 <code>[[mid][下取整]+1, x]</code>，所以最后得到答案是 <code>[mid][下取整]+1</code>，所以需要做 -1 操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 防止 case: 1 时，后面出现 mid 为 0 的情况</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = x;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="comment">// +1ll, 防止 int 数据溢出</span></span><br><span class="line">            <span class="keyword">int</span> mid = (l+(<span class="keyword">long</span> <span class="keyword">long</span>)r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (mid &gt;= x/mid) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l == x/l) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">return</span> l<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还是上一个做法比较简单，符合常规思考逻辑。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>按照 <strong>解题思路</strong> 多做题目，熟能生巧；</li><li>有些题目二分性质不是那么明显，不能套用模板，但是思路还是通用的（后面再讲）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二分查找，就是在一个区间内查找某个值(eg: target)的时候，每次把区间一分为二，然后选择满足性质的区间(即包含 target)继续一分为二，直到区间长度为一。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二分查找" scheme="http://example.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>用 Xcode 编译 Flutter Engine 源码</title>
    <link href="http://example.com/2021/01/21/compile-flutter-engine-using-Xcode/"/>
    <id>http://example.com/2021/01/21/compile-flutter-engine-using-Xcode/</id>
    <published>2021-01-20T23:57:18.000Z</published>
    <updated>2021-04-09T15:03:37.109Z</updated>
    
    <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>参考官方 wiki <a href="https://github.com/flutter/flutter/wiki/Setting-up-the-Engine-development-environment">Setting up the Engine development environment</a> 和 <a href="http://gityuan.com/2019/08/03/flutter_engine_setup/">搭建Flutter Engine源码编译环境</a>，设置好环境。</p><a id="more"></a><h2 id="安装-depot-tools"><a href="#安装-depot-tools" class="headerlink" title="安装 depot_tools"></a>安装 depot_tools</h2><ol><li>clone depot_tools 以获取 gclient 命令；<ol><li><code>git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git</code></li></ol></li><li>在 <code>.bashrc</code> 或者 <code>~/.zshrc</code> 设置环境变量 <ol><li><code>export PATH=&quot;$PATH:$HOME/Documents/engine/depot_tools&quot;</code></li><li>如果后面拉取源码提示 <code>zsh: command not found: gclient</code> 的话，那就在这两个文件里都设置一下</li><li>最好的办法是根据 <code>echo $SHELL</code> 命令 来获取当前是用的哪个 shell 终端，摘自 <a href="https://flutter.dev/docs/get-started/install/macos">flutter/macOS install/Update your path</a></li></ol></li></ol><h2 id="Homebrew-安装-ant-和-ninja"><a href="#Homebrew-安装-ant-和-ninja" class="headerlink" title="Homebrew 安装 ant 和 ninja"></a>Homebrew 安装 ant 和 ninja</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br><span class="line">brew install ant</span><br><span class="line">brew install ninja</span><br></pre></td></tr></table></figure><h1 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h1><p>I. fork flutter/engine repo</p><p>II. github ssl 处理</p><p>III. 创建 <code>engine</code> 文件夹，添加 <code>.gclient</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">solutions = [</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;managed&quot;: False,</span><br><span class="line">    &quot;name&quot;: &quot;src/flutter&quot;,</span><br><span class="line">    &quot;url&quot;: &quot;git@github.com:JoakimLiu/engine.git&quot;,</span><br><span class="line">    &quot;custom_deps&quot;: &#123;&#125;,</span><br><span class="line">    &quot;deps_file&quot;: &quot;DEPS&quot;,</span><br><span class="line">    &quot;safesync_url&quot;: &quot;&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这一步耗时有点久，大概 3h, <code>engine</code>文件夹内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── depot_tools</span><br><span class="line">└── src</span><br></pre></td></tr></table></figure><p>21.3.2 遇到的问题，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Activated generate_package_config 0.0.0 at path &quot;/Users/joakim.liu/Documents/engine/src/flutter/tools/generate_package_config&quot;.</span><br><span class="line">Unable to spawn isolate: src/flutter/tools/generate_package_config/bin/generate_from_legacy.dart:10:8: Error: Error when reading &#x27;../../.pub-cache/hosted/pub.flutter-io.cn/package_config-2.0.0/lib/packages_file.dart&#x27;: No such file or directory</span><br><span class="line">import &#x27;package:package_config/packages_file.dart&#x27;; // ignore: deprecated_member_use</span><br><span class="line">       ^</span><br><span class="line">src/flutter/tools/generate_package_config/bin/generate_from_legacy.dart:28:20: Error: Method not found: &#x27;parse&#x27;.</span><br><span class="line">  var packageMap = parse(await packagesFile.readAsBytes(), packagesFile.uri);</span><br><span class="line">                   ^^^^^</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;src/flutter/tools/run_third_party_dart.py&quot;, line 14, in &lt;module&gt;</span><br><span class="line">    subprocess.check_call([os.path.join(leading, pub), &quot;global&quot;, &quot;run&quot;, &quot;generate_package_config:generate_from_legacy&quot;, &quot;src/flutter/flutter_frontend_server/.packages&quot;])</span><br><span class="line">  File &quot;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/subprocess.py&quot;, line 190, in check_call</span><br><span class="line">    raise CalledProcessError(retcode, cmd)</span><br><span class="line">subprocess.CalledProcessError: Command &#x27;[&#x27;src/third_party/dart/tools/sdks/dart-sdk/bin/pub&#x27;, &#x27;global&#x27;, &#x27;run&#x27;, &#x27;generate_package_config:generate_from_legacy&#x27;, &#x27;src/flutter/flutter_frontend_server/.packages&#x27;]&#x27; returned non-zero exit status 1</span><br><span class="line">Error: Command &#x27;vpython src/flutter/tools/run_third_party_dart.py&#x27; returned non-zero exit status 1 in /Users/joakim.liu/Documents/engine</span><br></pre></td></tr></table></figure><p>搜了一波关键字都没找到方案，只能从源码文件找解决方案了</p><ol><li><code>/Users/joakim.liu/.pub-cache/hosted/pub.flutter-io.cn/package_config-2.0.0/lib</code>，从 <a href="https://pub.dev/packages/package_config/versions">pub.dev</a> 发现 <code>package_config-2.0.0</code> 是预览版，于是将 <code>package_config-2.0.0</code> 强制替换成 <code>package_config-1.9.3</code>，不行；</li><li>根据经验猜测应该是在某个 <code>yaml</code> 文件里面指定的版本，于是在 <code>/Users/joakim.liu/Documents/engine/src/flutter/tools/generate_package_config</code> 找到了 <code>pubspec.yaml</code>，将 <code>package_config: any</code> 改成 <code>package_config: 1.9.3</code>； </li></ol><p>Ⅴ. 将 engine(path:src/flutter) 和本地 flutter sdk 版本匹配上。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜ flutter git:(c2311c7c0) flutter --version</span><br><span class="line">Flutter 1.22.2 • channel stable • https://github.com/flutter/flutter.git</span><br><span class="line">Framework • revision 84f3d28555 (3 months ago) • 2020-10-15 16:26:19 -0700</span><br><span class="line">Engine • revision b8752bbfff</span><br><span class="line">Tools • Dart 2.10.2</span><br><span class="line">➜ flutter git:(c2311c7c0) git reset --hard b8752bbfff</span><br><span class="line">HEAD is now at b8752bbff [flutter_releases] Flutter 1.22.2 engine cherrypicks (#21841)</span><br><span class="line">➜ flutter git:(b8752bbff) gclient sync --with_branch_heads --with_tags</span><br></pre></td></tr></table></figure><p>参考自 <a href="https://blog.csdn.net/aha_jasper/article/details/108565406">Flutter(7) — Flutter Engine初始化(上)</a> 这一步非常重要，否则后面用编译后生成的 simulator debug 产物，来运行 flutter demo 是会报错，大致信息如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ +783 ms] Crash report sent (report ID: bbed038d6c5d852a)</span><br><span class="line">[        ] Oops; flutter has exited unexpectedly: &quot;NoSuchMethodError: The method &#x27;matchAsPrefix&#x27; was called on null.</span><br><span class="line">           Receiver: null</span><br><span class="line">           Tried calling: matchAsPrefix(&quot;ERROR: FormatException: Could not find an option named \&quot;bytecode-options\&quot;.&quot;, 0)&quot;.</span><br></pre></td></tr></table></figure><h1 id="编译源码"><a href="#编译源码" class="headerlink" title="编译源码"></a>编译源码</h1><p>参考官方 wiki 和 <a href="https://www.yuque.com/xytech/flutter/osg73p">怎样的Flutter Engine定制流程，才能实现真正“开箱即用”？</a>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cd src</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译 iOS 模拟器产物</span></span><br><span class="line">./flutter/tools/gn --ios --simulator --unoptimized  </span><br><span class="line">./flutter/tools/gn --unoptimized</span><br><span class="line">ninja -C out/ios_debug_sim_unopt &amp;&amp; ninja -C out/host_debug_unopt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译 arm64 产物</span></span><br><span class="line">joakim.liu@joakimdeiMac src % ./flutter/tools/gn --runtime-mode=debug --ios --ios-cpu=arm64 --unoptimized</span><br><span class="line">Generating GN files in: out/ios_debug_unopt</span><br><span class="line">Generating Xcode projects took 108ms</span><br><span class="line">Done. Made 418 targets from 190 files in 4849ms</span><br><span class="line">joakim.liu@joakimdeiMac src % ninja -C out/ios_debug_unopt                                      </span><br><span class="line">ninja: Entering directory `out/ios_debug_unopt&#x27;</span><br><span class="line">[3819/3819] STAMP obj/default.stamp</span><br></pre></td></tr></table></figure><p>这一步耗时比较久，大概 40min.<br>编译后的内容如下图，</p><p><img src="https://sat02pap001files.storage.live.com/y4mvEO9H4mg3kr_u9nsrYa3-9OUq82o08Zlm8VuNEXYklZOV8TbVA0DUN_uBu7Iq2NniZtx-5ZdCL8GZd2C1ES-yRznkKptuPQAQLVlbwGLcVpbCjohVp5l92xc2W4i80YTUEHgQCPTQb_ixitM34aW3VUVWVjvGe20NSkoLAzyX23rXAfjhZc2pCppiojEzHiV?width=1024&height=544&cropmode=none"></p><p>此时打开 <code>all.xcodeproj</code> 就能看源码了。</p><h1 id="调试源码"><a href="#调试源码" class="headerlink" title="调试源码"></a>调试源码</h1><p>I. 创建并运行项目，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜ Demo flutter create my_app    </span><br><span class="line">➜ my_app flutter run --local-engine-src-path=/Users/joakim.liu/Documents/engine/src --local-engine=ios_debug_sim_unopt --verbose</span><br></pre></td></tr></table></figure><p>如果上一步没将 engine 和本地 flutter sdk 匹配上的话，这里会运行失败的，用 Xcode 运行的话，会报以下错误</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ios_debug_sim_unopt No `Podfile&#x27; found in the project directory.</span><br></pre></td></tr></table></figure><p>其实 <a href="https://www.yuque.com/xytech/flutter/osg73p">怎样的Flutter Engine定制流程，才能实现真正“开箱即用”？</a> 里面有提到，当时没注意：</p><blockquote><p>第一次gclient sync 执行完成了，engine/src/flutter为Flutter Engine源码的位置，我们需要手动切换到对应的版本分支，然后再次执行gclinet sync对此版本的依赖重新同步下，此次执行会比首次执行快很多。</p></blockquote><p>参考自 <a href="https://github.com/flutter/flutter/issues/16114">Compiling flutter/engine on OSX fails. #16114</a>，总结下重要的点</p><ol><li>gclient sync 的时候要 <code>git rev-parse HEAD</code></li><li>模拟器运行 flutter run -d”iPhone 8”</li><li>pubspec.yaml 的 dependency_overrides // 适用于 <code>当引擎中修改了Dart源代码</code>，摘自 <a href="http://gityuan.com/2019/08/03/flutter_engine_setup/">搭建Flutter Engine源码编译环境</a></li><li>手动修改 <code>manually edit an Xcode config file</code></li><li>同上 `the engine path should be “ FLUTTER_ROOT/engine/src “ because the compile script would compare the engine path with “FLUTTER_ROOT/engine/src” .</li><li>engine 版本要和 flutter sdk 版本相对应，<code>The building engine version may not same as FLUTTER_ROOT version. Try to change the engine src version.</code> // 也就是 “Flutter SDK依赖的Engine的commit id的值”</li></ol><p>II. 如果终端运行失败的话，那就用 Android Studio 运行，然后查看 <code>/Users/joakim.liu/Documents/Demo/my_app/ios/Flutter</code> 下的 <code>Generated.xcconfig</code> 内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// This is a generated file; do not edit or check into version control.</span><br><span class="line">FLUTTER_ROOT=/Users/joakim.liu/development/flutter-1.22.2</span><br><span class="line">FLUTTER_APPLICATION_PATH=/Users/joakim.liu/Documents/Demo/my_app</span><br><span class="line">FLUTTER_TARGET=/Users/joakim.liu/Documents/Demo/my_app/lib/main.dart</span><br><span class="line">FLUTTER_BUILD_DIR=build</span><br><span class="line">SYMROOT=$&#123;SOURCE_ROOT&#125;/../build/ios</span><br><span class="line">OTHER_LDFLAGS=$(inherited) -framework Flutter</span><br><span class="line">FLUTTER_FRAMEWORK_DIR=/Users/joakim.liu/Documents/engine/src/out/ios_debug_sim_unopt</span><br><span class="line">FLUTTER_BUILD_NAME=1.0.0</span><br><span class="line">FLUTTER_BUILD_NUMBER=1</span><br><span class="line">FLUTTER_ENGINE=/Users/joakim.liu/Documents/engine/src</span><br><span class="line">LOCAL_ENGINE=ios_debug_sim_unopt</span><br><span class="line">ARCHS=arm64</span><br><span class="line">DART_OBFUSCATION=false</span><br><span class="line">TRACK_WIDGET_CREATION=true</span><br><span class="line">TREE_SHAKE_ICONS=false</span><br><span class="line">PACKAGE_CONFIG=.packages</span><br></pre></td></tr></table></figure><p>III.<br>想用 Xcode 调试 engine 源码的话，那就把 engine 源码导入去，把编译后的 <code>ios_debug_sim_unopt/all.xcodeproj</code> 工程拖进 demo <code>Runner.xcworkspace</code> 中，注意：此时不能打开 <code>all.xcodeproj</code> 工程。</p><p>但用 Xcode12 打开工程后，不会出现模拟器选项，用 Android Studio 才能运行后就会出现模拟器选项，很怪异，可是 Android Studio 运行后 <code>Generated.xcconfig</code> 会发生变化。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// This is a generated file; do not edit or check into version control.</span><br><span class="line">FLUTTER_ROOT=/Users/joakim.liu/development/flutter-1.22.2</span><br><span class="line">FLUTTER_APPLICATION_PATH=/Users/joakim.liu/Documents/Demo/my_app</span><br><span class="line">FLUTTER_TARGET=/Users/joakim.liu/Documents/Demo/my_app/lib/main.dart</span><br><span class="line">FLUTTER_BUILD_DIR=build</span><br><span class="line">SYMROOT=$&#123;SOURCE_ROOT&#125;/../build/ios</span><br><span class="line">OTHER_LDFLAGS=$(inherited) -framework Flutter</span><br><span class="line">FLUTTER_FRAMEWORK_DIR=/Users/joakim.liu/development/flutter-1.22.2/bin/cache/artifacts/engine/ios</span><br><span class="line">FLUTTER_BUILD_NAME=1.0.0</span><br><span class="line">FLUTTER_BUILD_NUMBER=1</span><br><span class="line">DART_DEFINES=flutter.inspector.structuredErrors%3Dtrue</span><br><span class="line">DART_OBFUSCATION=false</span><br><span class="line">TRACK_WIDGET_CREATION=true</span><br><span class="line">TREE_SHAKE_ICONS=false</span><br><span class="line">PACKAGE_CONFIG=.packages</span><br></pre></td></tr></table></figure><p>如果将 <code>Generated.xcconfig</code> 改成终端运行后的内容，会报错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Package generate_package_config is currently active at path &quot;/Users/joakim.liu/Documents/engine/src/flutter/tools/generate_package_config&quot;.</span><br><span class="line">Activated generate_package_config 0.0.0 at path &quot;/Users/joakim.liu/Documents/engine/src/flutter/tools/generate_package_config&quot;.</span><br></pre></td></tr></table></figure><p>在 <code>Generated.xcconfig</code> 后面添加 <code>FLUTTER_ENGINE</code> 和 <code>LOCAL_ENGINE</code> 即可，最终内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// This is a generated file; do not edit or check into version control.</span><br><span class="line">FLUTTER_ROOT=/Users/joakim.liu/development/flutter-1.22.2</span><br><span class="line">FLUTTER_APPLICATION_PATH=/Users/joakim.liu/Documents/Demo/my_app</span><br><span class="line">FLUTTER_TARGET=/Users/joakim.liu/Documents/Demo/my_app/lib/main.dart</span><br><span class="line">FLUTTER_BUILD_DIR=build</span><br><span class="line">SYMROOT=$&#123;SOURCE_ROOT&#125;/../build/ios</span><br><span class="line">OTHER_LDFLAGS=$(inherited) -framework Flutter</span><br><span class="line">FLUTTER_FRAMEWORK_DIR=/Users/joakim.liu/development/flutter-1.22.2/bin/cache/artifacts/engine/ios</span><br><span class="line">FLUTTER_BUILD_NAME=1.0.0</span><br><span class="line">FLUTTER_BUILD_NUMBER=1</span><br><span class="line">DART_DEFINES=flutter.inspector.structuredErrors%3Dtrue</span><br><span class="line">DART_OBFUSCATION=false</span><br><span class="line">TRACK_WIDGET_CREATION=true</span><br><span class="line">TREE_SHAKE_ICONS=false</span><br><span class="line">PACKAGE_CONFIG=.packages</span><br><span class="line">FLUTTER_ENGINE=/Users/joakim.liu/Documents/engine/src</span><br><span class="line">LOCAL_ENGINE=ios_debug_sim_unopt</span><br></pre></td></tr></table></figure><p>嗯，终于能用 Xcode 把 demo 给跑起来在模拟器运行了，并且也能在 engine 源码里面下断点了。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://github.com/flutter/flutter/wiki/Setting-up-the-Engine-development-environment">Setting up the Engine development environment</a></li><li><a href="http://gityuan.com/2019/08/03/flutter_engine_setup/">搭建Flutter Engine源码编译环境</a></li><li><a href="https://blog.csdn.net/aha_jasper/article/details/108565406">Flutter(7) — Flutter Engine初始化(上)</a></li><li><a href="https://github.com/flutter/flutter/issues/16114">Compiling flutter/engine on OSX fails. #16114</a></li><li><a href="https://www.yuque.com/xytech/flutter/osg73p">怎样的Flutter Engine定制流程，才能实现真正“开箱即用”？</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h1&gt;&lt;p&gt;参考官方 wiki &lt;a href=&quot;https://github.com/flutter/flutter/wiki/Setting-up-the-Engine-development-environment&quot;&gt;Setting up the Engine development environment&lt;/a&gt; 和 &lt;a href=&quot;http://gityuan.com/2019/08/03/flutter_engine_setup/&quot;&gt;搭建Flutter Engine源码编译环境&lt;/a&gt;，设置好环境。&lt;/p&gt;
    
    </summary>
    
      <category term="flutter" scheme="http://example.com/categories/flutter/"/>
    
    
      <category term="源码编译" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"/>
    
      <category term="flutter" scheme="http://example.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>Runloop 基础</title>
    <link href="http://example.com/2019/03/09/runloop-note/"/>
    <id>http://example.com/2019/03/09/runloop-note/</id>
    <published>2019-03-09T05:02:34.000Z</published>
    <updated>2021-01-22T14:55:23.852Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1">Threading Programming Guide - Run Loops</a> 文档的一个学习(其中参考了 <a href="https://opensource.apple.com/source/CF/CF-1153.18/CFRunLoop.c.auto.html">CFRunLoop</a> 源码)，其他例子在后期系统了解某个技术有涉及时再说。 其他高质量文章可见</p><ul><li><a href="https://blog.ibireme.com/2015/05/18/runloop/">深入理解RunLoop</a></li><li><a href="http://mrpeak.cn/blog/ios-runloop/">解密 Runloop</a></li></ul><a id="more"></a><h1 id="啥是-Run-Loop"><a href="#啥是-Run-Loop" class="headerlink" title="啥是 Run Loop"></a>啥是 Run Loop</h1><p>run loop 是与线程相关的基础架构的一部分。 它是<strong>一个事件处理循环，用于计划工作并协调传入事件的接收</strong>。 它的<strong>目的是</strong>在有工作时保持线程忙，并在没有工作时让线程进入休眠状态。 我们开发者的代码提供了用于实现 run loop 的实际循环部分的控制语句 - 换句话说，代码提供了驱动 run loop 的 while 或 for 循环。 在循环中，使用 run loop 对象<strong>运行接收</strong>事件处理代码，并调用已安装的处理程序。</p><p>run loop 从<strong>两种不同类型的源接收事件</strong>。 输入源(input sources)提供异步事件，通常是来自另一个线程或来自不同应用程序的消息。 定时器源(timer sources)提供同步事件，发生在预定时间或重复间隔。 两种类型的源都使用特定于应用程序的处理程序程序来<strong>处理</strong>到达事件。</p><p>下图显示了 run loop 和各种源的概念结构。 输入源将异步事件传递给相应的处理程序，并调用 <code>runUntilDate:</code> 方法（在线程的关联 NSRunLoop 对象上调用）退出。 计时器源将事件传递给其处理程序，但不会导致 run loop 退出。</p><p><img src="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/Art/runloop.jpg" alt="Structure of a run loop and its sources"></p><p>除了处理输入源之外， run loop 还会生成有关 run loop 行为的通知。 可以使用 Core Foundation 在线程上安装 run loop 观察器。</p><h2 id="Input-Sources"><a href="#Input-Sources" class="headerlink" title="Input Sources"></a>Input Sources</h2><p>通常分两类，它们都是以异步方式向线程传递事件，唯一区别是<strong>它们如何发出信号</strong>。</p><ul><li>Port-based input sources: 基于的端口的输入源，监听应用程序的 Mach 端口（由内核自动发出信号，源码中被称为 source1 ）。</li><li>Custom input sources: 自定义输入源，监听自定义事件源（必须从另一个线程手动发信号通知自定义源，源码中被称为 source0 ）。</li></ul><p>如果输入源未处于当前监听模式，则它生成的任何事件会被 hold 住，直到 run loop 以正确模式运行。</p><h3 id="Port-Based-Sources"><a href="#Port-Based-Sources" class="headerlink" title="Port-Based Sources"></a>Port-Based Sources</h3><p>Cocoa 和 Core Foundation 提供 使用与端口相关的对象和函数<strong>创建基于端口的输入源 的内置支持</strong>。 例如，在 Cocoa 中，根本不必直接创建输入源，只需创建一个端口对象，并使用 NSPort 的方法将该端口添加到 run loop 中。 port 对象处理所需输入源的创建和配置。</p><p>在 Core Foundation 中，必须手动创建端口及其 run loop 源。 在这两种情况下，都使用与端口 opaque 类型(CFMachPortRef CFMessagePortRef 或 CFSocketRef)相关联的函数来创建适当的对象。</p><h3 id="Custom-Input-Sources"><a href="#Custom-Input-Sources" class="headerlink" title="Custom Input Sources"></a>Custom Input Sources</h3><p>要创建自定义输入源，必须在 Core Foundation 中使用与 CFRunLoopSourceRef opaque 类型关联的函数。 可以使用多个回调函数配置<strong>自定义输入源</strong>。 Core Foundation 在不同的点调用这些函数来配置源，处理传入事件，并在从 run loop 中删除源时拆除源。</p><p>除了在事件到达时，定义自定义源的行为，还必须定义事件<strong>传递机制</strong>。 源的这一部分在一个单独的线程上运行，负责为输入源提供数据，并在数据准备好进行处理时发出信号。 事件传递机制取决于我们开发者，但不必过于复杂。</p><h3 id="Cocoa-Perform-Selector-Sources"><a href="#Cocoa-Perform-Selector-Sources" class="headerlink" title="Cocoa Perform Selector Sources"></a>Cocoa Perform Selector Sources</h3><p>除了基于端口的源之外， Cocoa 还定义了一个自定义输入源，允许在任何线程上执行选择器(selector)。与基于端口的源类似，在目标线程上<strong>依次执行</strong>选择器请求，从而减轻了在一个线程上运行多个方法时可能发生的许多<strong>同步问题</strong>。与基于端口的源不同，选择器源在执行后<strong>将其自身从 run loop 中移除</strong>。</p><p>在另一个线程上执行选择器时，目标线程<strong>必须具有</strong> active run loop 。对于自定义创建的线程，这意味着要等到代码显式启动 run loop 。但是，因为主线程启动了自己的 run loop ，所以只要应用程序调用应用程序委托的 <code>applicationDidFinishLaunching:</code> 方法，就可以开始在该线程上发出调用。 run loop 每次通过循环处理<strong>所有排队</strong>的执行选择器调用，而不是在每次循环迭代期间<strong>处理一个</strong>。</p><p>下表列出了在 NSObject 上定义的可用于在其他线程上执行选择器的方法。因为这些方法是在 NSObject 上声明的，所以可以在<strong>任何</strong>可以访问 Objective-C 对象的线程中使用它们，包括 POSIX 线程。这些方法实际上<strong>并不创建新线程来执行选择器</strong>。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>performSelectorOnMainThread:withObject:waitUntilDone:</code>, <code>performSelectorOnMainThread:withObject:waitUntilDone:modes:</code></td><td>在主线程的<strong>下一个 run loop 周期</strong>中，执行指定的选择器。 提供了阻止当前线程直到执行选择器的选项。</td></tr><tr><td><code>performSelector:onThread:withObject:waitUntilDone:</code>, <code>performSelector:onThread:withObject:waitUntilDone:modes:</code></td><td>在<strong>具有 NSThread 对象</strong>的线程上执行指定的选择器 。 也提供了阻止当前线程直到执行选择器的选项。</td></tr><tr><td><code>performSelector:withObject:afterDelay:</code>, <code>performSelector:withObject:afterDelay:inModes:</code></td><td>在当前线程上的下一个 run loop 周期和可选的延迟后，执行指定的选择器。</td></tr><tr><td><code>cancelPreviousPerformRequestsWithTarget:</code>, <code>cancelPreviousPerformRequestsWithTarget:selector:object:</code></td><td>给使用 <code>performSelector:withObject:afterDelay:</code> 或<code>performSelector:withObject:afterDelay:inModes:</code> 方法的当前线程发送取消消息。</td></tr></tbody></table><h2 id="Timer-Sources"><a href="#Timer-Sources" class="headerlink" title="Timer Sources"></a>Timer Sources</h2><p>计时器源在将来的预设时间将事件同步传递给线程。定时器是<strong>线程通知自己做某事的一种方式</strong>。</p><p>虽然它生成基于时间的通知，但计时器<strong>不是实时的</strong> （它有一个属性 tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差，目的就是为了节省资源）。 与输入源类似，定时器与 run loop 的<strong>特定模式相关联</strong>。 如果计时器未处于 run loop 当前正在监听的模式，则在使用其中一个计时器支持的模式运行 run loop 之前，它不会触发。 类似地，如果计时器在 run loop <strong>处于执行处理程序的过程中触发，则计时器将等待直到下一次</strong>通过 run loop 来调用其处理程序。 如果 run loop 根本没有运行，则计时器永远不会触发。</p><p>可以将计时器配置为仅生成一次或重复生成事件。 重复计时器根据<strong>计划的触发(fire)时间自动重新安排自己，而不是实际触发时间</strong>。 如果触发时间延迟太多以至于错过了一个或多个预定发射时间，则计时器仅在错过的时间段内<strong>触发一次</strong>。 在为错过的时段触发之后，计时器被重新安排用于下一个预定的触发时间。</p><h2 id="Run-Loop-Observers"><a href="#Run-Loop-Observers" class="headerlink" title="Run Loop Observers"></a>Run Loop Observers</h2><p>与在发生<strong>适当的</strong>异步或同步事件时触发的源相反， observer 在执行 run loop 期间在特殊位置触发。 特殊的位置如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1UL</span> &lt;&lt; <span class="number">0</span>), <span class="comment">// 进入 run loop</span></span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1UL</span> &lt;&lt; <span class="number">1</span>), <span class="comment">// run loop 即将处理 timer</span></span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1UL</span> &lt;&lt; <span class="number">2</span>), <span class="comment">// run loop 即将处理 input source</span></span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1UL</span> &lt;&lt; <span class="number">5</span>), <span class="comment">// run loop 即将进入休眠状态时</span></span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1UL</span> &lt;&lt; <span class="number">6</span>), <span class="comment">// run loop 已经被唤醒，在处理唤醒它的事件之前</span></span><br><span class="line">    kCFRunLoopExit = (<span class="number">1UL</span> &lt;&lt; <span class="number">7</span>),  <span class="comment">// 从 run loop 退出</span></span><br><span class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以使用 Core Foundation 将 observer 添加到应用程序。要创建 observer ，请创建 CFRunLoopObserverRef opaque 类型的新实例。 此类型会跟踪自定义回调函数及其感兴趣的活动。</p><p>与定时器类似， <strong>observer 可以使用一次或重复使用</strong>。一次性 observer 在触发后将其自身从 run loop 中移除，而重复的 observer 仍然存在。</p><h2 id="The-Run-Loop-Sequence-of-Events"><a href="#The-Run-Loop-Sequence-of-Events" class="headerlink" title="The Run Loop Sequence of Events"></a>The Run Loop Sequence of Events</h2><p>线程的 run loop 每次运行时，都会处理挂起(pending)的事件，并为所有附加的 observer 生成通知。它的执行顺序如下：</p><ol><li>通知 observer 进入 run loop</li><li>通知 observer 准备好的 timer 即将触发</li><li>通知 observer source0 即将触发 </li><li>触发准备好的 source0</li><li>如果 source1 已经准备好并且等待触发，立即处理事件，并跳到第 9 步</li><li>通知 observer 线程即将进入休眠状态</li><li>让线程置于休眠状态，直到被以下条件唤醒：<ul><li>source1 事件到达</li><li>timer 触发</li><li>为 run loop 设置的超时值到了</li><li>run loop 被手动唤醒</li></ul></li><li>通知 observer 线程刚被唤醒</li><li>处理挂起的事件<ul><li>如果用户定义 timer 被触发了，处理 timer 事件并重启 run loop 。并跳到第 2 步</li><li>如果 input source 被触发了，分发事件</li><li>如果 run loop 被手动唤醒但是还没超时，重启 run loop 。并跳到第 2 步</li></ul></li><li>通知 observer 已经退出 run loop </li></ol><p>核心代码主要在下面两个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SInt32 <span class="title">CFRunLoopRunSpecific</span><span class="params">(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int32_t</span> __<span class="title">CFRunLoopRun</span><span class="params">(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode)</span> </span></span><br></pre></td></tr></table></figure><p>相关核心代码(摘取了包含前缀<code>__CFRunLoop</code> 的代码)如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 通知 observer 进入 run loop</span></span><br><span class="line"><span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry); <span class="comment">// 最终走 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 2. 通知 observer 准备好的 timer 即将触发</span></span><br><span class="line">    <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">    <span class="comment">// 3. 通知 observer source0 即将触发 </span></span><br><span class="line">    <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行 Block</span></span><br><span class="line">    __CFRunLoopDoBlocks(rl, rlm);  <span class="comment">// 最终走 __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 触发准备好的 source0</span></span><br><span class="line">    Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle); <span class="comment">// 最终走 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__</span></span><br><span class="line">    <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 如果 source1 已经准备好并且等待触发，立即处理事件，并跳到第 9 步 （读取和 mainQueue 相关的消息，这里不会导致睡眠(入参 timeout = 0)，保证 dispatch 到 mainQueue 代码有较高的机会运行）</span></span><br><span class="line">    Boolean poll = sourceHandledThisLoop || (<span class="number">0ULL</span> == timeout_context-&gt;termTSR);</span><br><span class="line">    <span class="keyword">if</span> (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123;</span><br><span class="line">        msg = (<span class="keyword">mach_msg_header_t</span> *)msg_buffer;</span><br><span class="line">        <span class="keyword">if</span> (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, <span class="number">0</span>, &amp;voucherState, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            <span class="keyword">goto</span> handle_msg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 通知 observer 线程即将进入休眠状态</span></span><br><span class="line">    <span class="keyword">if</span> (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__CFRunLoopSetSleeping(rl);</span><br><span class="line">    __CFPortSetInsert(dispatchPort, waitSet);</span><br><span class="line">__CFRunLoopModeUnlock(rlm);</span><br><span class="line">__CFRunLoopUnlock(rl);</span><br><span class="line">    <span class="keyword">if</span> (kCFUseCollectableAllocator) &#123;</span><br><span class="line">        <span class="comment">// objc_clear_stack(0);</span></span><br><span class="line">       <span class="comment">// &lt;rdar://problem/16393959&gt;</span></span><br><span class="line">       <span class="built_in">memset</span>(msg_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg_buffer));</span><br><span class="line">    &#125;</span><br><span class="line">    msg = (<span class="keyword">mach_msg_header_t</span> *)msg_buffer;</span><br><span class="line">    <span class="comment">// 7. 让线程置于休眠状态，直到被以下条件唤醒 (注意入参poll 的值，是否睡眠)</span></span><br><span class="line">    __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, poll ? <span class="number">0</span> : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line"></span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    __CFRunLoopModeLock(rlm);</span><br><span class="line">    __CFPortSetRemove(dispatchPort, waitSet);</span><br><span class="line">    __CFRunLoopSetIgnoreWakeUps(rl);</span><br><span class="line">__CFRunLoopUnsetSleeping(rl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8. 通知 observer 线程刚被唤醒</span></span><br><span class="line"><span class="keyword">if</span> (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 9. 处理挂起的事件</span></span><br><span class="line">    handle_msg:;</span><br><span class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (MACH_PORT_NULL == livePort) &#123; <span class="comment">// 没事情</span></span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_NOTHING();</span><br><span class="line">            <span class="comment">// handle nothing</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (livePort == rl-&gt;_wakeUpPort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_WAKEUP();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123; <span class="comment">// (或者 livePort == rlm-&gt;_timerPort) 处理 timer</span></span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</span><br><span class="line">            <span class="keyword">if</span> (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123; <span class="comment">// 最终走 __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__</span></span><br><span class="line">                <span class="comment">// Re-arm the next timer, because we apparently fired early</span></span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (livePort == dispatchPort) &#123; <span class="comment">// dispatch mainQueue 事件</span></span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_DISPATCH();</span><br><span class="line">            __CFRunLoopModeUnlock(rlm);</span><br><span class="line">            __CFRunLoopUnlock(rl);</span><br><span class="line"></span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg); </span><br><span class="line"></span><br><span class="line">            __CFRunLoopLock(rl);</span><br><span class="line">            __CFRunLoopModeLock(rlm);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// source1</span></span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_SOURCE();</span><br><span class="line"></span><br><span class="line">            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</span><br><span class="line">            <span class="keyword">if</span> (rls) &#123;</span><br><span class="line">    <span class="keyword">mach_msg_header_t</span> *reply = <span class="literal">NULL</span>;</span><br><span class="line">    sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop; <span class="comment">// 最终走 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != reply) &#123;</span><br><span class="line">        (<span class="keyword">void</span>)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, <span class="number">0</span>, MACH_PORT_NULL, <span class="number">0</span>, MACH_PORT_NULL);</span><br><span class="line">     CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);</span><br><span class="line">    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行 Block</span></span><br><span class="line">    __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 判断循环条件</span></span><br><span class="line"><span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">    retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">            __CFRunLoopUnsetStopped(rl);</span><br><span class="line">    retVal = kCFRunLoopRunStopped;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped) &#123;</span><br><span class="line">    rlm-&gt;_stopped = <span class="literal">false</span>;</span><br><span class="line">    retVal = kCFRunLoopRunStopped;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class="line">    retVal = kCFRunLoopRunFinished;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span> == retVal);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 10. 通知 observer 已经退出 run loop </span></span><br><span class="line"><span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br></pre></td></tr></table></figure><p>可以参考高峰大佬的<a href="http://mrpeak.cn/blog/ios-runloop/">解密 Runloop</a> 里面的流程图</p><p><img src="https://github.com/JoakimLiu/BlogPhoto/blob/master/runloop/runloop-sequence-mrpeak.png?raw=true" alt="run loop sequence"></p><p>由于 timer 和 input sources 的 observer 通知是在这些事件<strong>实际发生之前传递的</strong>，因此通知时间与实际事件的时间之间可能存在差距。 如果这些事件之间的时间关系很重要，可以使用<strong>休眠和唤醒休眠通知来帮助关联</strong>实际事件之间的时间。</p><p>可以使用 run loop 对象手动唤醒它，其他事件也可能导致 run loop 被唤醒。例如，添加另一个非基于端口的输入源会唤醒 run loop ，以便可以立即处理输入源，而不是等到其他事件发生。</p><h2 id="Run-Loop-Modes"><a href="#Run-Loop-Modes" class="headerlink" title="Run Loop Modes"></a>Run Loop Modes</h2><p>这个概念很重要， run loop mode(模式) 是要监听的输入源(input sources)和计时器(timers)<strong>的集合</strong>，以及要通知的 run loop observers <strong>的集合</strong>。每次运行 run loop 时，都指定（显式或隐式）运行的特定模式。在 run loop 的传递过程中，<strong>仅监听与该模式关联的源并允许其传递事件</strong>。 类似地，只有与该模式相关联的 observers 被通知 run loop 的进度。 与其他模式相关联的源保持新事件，直到后续以适当模式通过循环。</p><p>在代码中，可以按名称识别模式。 Cocoa 和 Core Foundation 都定义了默认模式和几种常用模式(见下表)，以及用于在代码中指定这些模式的字符串。 只需为模式名称指定自定义字符串<strong>即可定义自定义模式</strong>。 虽然为自定义模式指定的名称是任意的，但<strong>这些模式的内容不是</strong>。 必须确保将一个或多个输入源，计时器或 run loop 观察器<strong>添加到为其创建的任何模式中</strong>才有用。 (ps: 模式中要有相关源和观察器才有用)</p><table><thead><tr><th>Mode</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>Default</td><td>NSDefaultRunLoopMode (Cocoa), kCFRunLoopDefaultMode (Core Foundation)</td><td>用于大多数操作的模式，大多数情况，应该使用它启动 run loop 并配置输入源。</td></tr><tr><td>Connection</td><td>NSConnectionReplyMode (Cocoa)</td><td>与 NSConnection 对象结合使用去监听回复，很少用到。</td></tr><tr><td>Modal</td><td>NSModalPanelRunLoopMode (Cocoa)</td><td>识别用于模态面板(modal panels)的事件。</td></tr><tr><td>Event tracking</td><td>NSEventTrackingRunLoopMode (Cocoa)</td><td>限制 在鼠标拖动循环和其他用户界面跟踪循环期间 的传入事件。</td></tr><tr><td>Common modes</td><td>NSRunLoopCommonModes (Cocoa), kCFRunLoopCommonModes (Core Foundation)</td><td>可配置的常用模式。 将输入源与此模式相关联，也会将其与组中的<strong>每个模式相关联</strong>。 对于 Cocoa 应用程序，此集合默认包括 Default ，Modal 和 Event tracking 模式。 Core Foundation 最初只包含 Default 模式，可以使用 CFRunLoopAddCommonMode 函数将自定义模式添加到集合中。</td></tr></tbody></table><p>可以使用模式在特定的运行循环期间过<strong>滤掉不需要的</strong>来源中的事件。 大多数情况下，需要在系统定义的“默认”模式下运行运行循环。 但是，模态面板可能以“模态”模式运行，在此模式下，只有与模态面板相关的源才会将事件传递给线程。对于次级线程，可以使用自定义模式来<strong>防止低优先级源在时间关键操作期间传递事件</strong>。</p><p>注意：<strong>模式根据事件的来源而不是事件的类型进行区分</strong>。 </p><p>run loop mode 结构体定义如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopMode</span> &#123;</span></span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> _lock;<span class="comment">/* must have the run loop locked before locking this */</span></span><br><span class="line">    CFStringRef _name;</span><br><span class="line">    Boolean _stopped;</span><br><span class="line">    <span class="keyword">char</span> _padding[<span class="number">3</span>];</span><br><span class="line">    CFMutableSetRef _sources0; </span><br><span class="line">    CFMutableSetRef _sources1;</span><br><span class="line">    CFMutableArrayRef _observers;</span><br><span class="line">    CFMutableArrayRef _timers;</span><br><span class="line">    CFMutableDictionaryRef _portToV1SourceMap;</span><br><span class="line">    __CFPortSet _portSet;</span><br><span class="line">    CFIndex _observerMask;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span></span><br><span class="line">    <span class="keyword">dispatch_source_t</span> _timerSource;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> _queue;</span><br><span class="line">    Boolean _timerFired; <span class="comment">// set to true by the source when a timer has fired</span></span><br><span class="line">    Boolean _dispatchTimerArmed;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_MK_TIMER_TOO</span></span><br><span class="line">    <span class="keyword">mach_port_t</span> _timerPort;</span><br><span class="line">    Boolean _mkTimerArmed;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEPLOYMENT_TARGET_WINDOWS</span></span><br><span class="line">    DWORD _msgQMask;</span><br><span class="line">    <span class="keyword">void</span> (*_msgPump)(<span class="keyword">void</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">uint64_t</span> _timerSoftDeadline; <span class="comment">/* TSR */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> _timerHardDeadline; <span class="comment">/* TSR */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以看到结构体里面有定义 _sources0 _sources1 _observers _timers ，唯独没有定义 mainQueue ，因为 mainQueue 的执行与 mode 没关系。 前面 run loop 执行的流程代码，在调用 <code>__CFRunLoopDoObservers XXXXXX</code> 方法通知 observers 回调之前，都会用 <code>(currentMode-&gt;_observerMask &amp; CFRunLoopActivity)</code> 做判断，只有 _observerMask 里面有相关类型值，才会回调 observers 。 用下面方法添加 observers 的时候， _observerMask 都会更新</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CFRunLoopAddObserver</span><span class="params">(CFRunLoopRef rl, CFRunLoopObserverRef rlo, CFStringRef modeName)</span> </span></span><br></pre></td></tr></table></figure><h1 id="什么时候需要-Run-Loop"><a href="#什么时候需要-Run-Loop" class="headerlink" title="什么时候需要 Run Loop?"></a>什么时候需要 Run Loop?</h1><p>手动运行 run loop 的<strong>唯一时间是为应用程序创建次级线程</strong>。 应用程序主线程的 run loop 是一个至关重要的基础架构，在启动程序的时候，主循环就已经创建好了。</p><p>对于次级线程，需要确定是否需要 run loop ，如果是，<strong>请自行配置并启动它</strong>。 如果使用线程执行某些长时间运行且预定义的任务，则可以<strong>不需要启动</strong> run loop 。<strong>run loop 适用于希望与线程进行更多交互的情况</strong>。 例如：</p><ul><li>使用端口或自定义 input source 与其他线程通信</li><li>在线程上使用 timer</li><li>在 Cocoa 应用程序中使用任何 <code>performSelector...</code> 方法</li><li>保持线程以执行定期任务</li></ul><p>如果确实选择使用 run loop ，则配置和设置非常简单。与所有线程编程一样，应该在适当情况下退出次级线程，而不是强行退出。</p><h1 id="使用-Run-Loop-对象"><a href="#使用-Run-Loop-对象" class="headerlink" title="使用 Run Loop 对象"></a>使用 Run Loop 对象</h1><p>run loop 对象提供了主要接口，用于将 input sources ，timers 和 observers <strong>添加到</strong> run loop  ，然后运行它。 <strong>每个线程都有一个与之关联的 run loop 对象</strong>。 在 Cocoa 中，是 <a href="https://developer.apple.com/library/archive/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSRunLoop/Description.html#//apple_ref/occ/cl/NSRunLoop">NSRunLoop</a> 类的实例。 在低级应用程序中，它是指向 <a href="https://developer.apple.com/documentation/corefoundation/cfrunloopref">CFRunLoopRef</a> opaque 类型的指针。</p><h2 id="Getting-a-Run-Loop-Object"><a href="#Getting-a-Run-Loop-Object" class="headerlink" title="Getting a Run Loop Object"></a>Getting a Run Loop Object</h2><p>获取当前线程的 run loop ，可以使用下面的其中一个方法</p><ul><li>在 Cocoa App 中，调用 NSRunLoop 的 <code>currentRunLoop</code> 类方法，获取 NSRunLoop 对象</li><li>使用 <code>CFRunLoopGetCurrent</code> 函数</li></ul><p>虽然它们<strong>不是</strong> toll-free bridged 类型，但可以在需要时从 NSRunLoop 对象获取 CFRunLoopRef opaque 类型。<br>因为两者<strong>都引用相同的</strong> run loop 对象，所以可以混合使用。</p><h2 id="Configuring-the-Run-Loop"><a href="#Configuring-the-Run-Loop" class="headerlink" title="Configuring the Run Loop"></a>Configuring the Run Loop</h2><p>在次级线程上运行 run loop 之前，<strong>必须至少添加一个输入源或计时器</strong>。如果 run loop 没有要监听的任何源，则在尝试运行它时<strong>会立即退出</strong>。</p><p>除了安装源之外，还可以安装运行 observer 并使用它们来检测 run loop 的不同执行阶段。下面的代码展示了一个将 observer 附加到其 run loop 的线程的主程序。如何创建 observer ，以及用它来监听 run loop 的所有活动，没有显示监听回调函数 <code>myRunLoopObserver</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-1 Creating a run loop observer</span><br><span class="line">- (void)threadMain</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; The application uses garbage collection, so no autorelease pool is needed.</span><br><span class="line">    NSRunLoop* myRunLoop &#x3D; [NSRunLoop currentRunLoop];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Create a run loop observer and attach it to the run loop.</span><br><span class="line">    CFRunLoopObserverContext  context &#x3D; &#123;0, self, NULL, NULL, NULL&#125;;</span><br><span class="line">    CFRunLoopObserverRef    observer &#x3D; CFRunLoopObserverCreate(kCFAllocatorDefault,</span><br><span class="line">            kCFRunLoopAllActivities, YES, 0, &amp;myRunLoopObserver, &amp;context);</span><br><span class="line"> </span><br><span class="line">    if (observer)</span><br><span class="line">    &#123;</span><br><span class="line">        CFRunLoopRef    cfLoop &#x3D; [myRunLoop getCFRunLoop];</span><br><span class="line">        CFRunLoopAddObserver(cfLoop, observer, kCFRunLoopDefaultMode);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Create and schedule the timer.</span><br><span class="line">    [NSTimer scheduledTimerWithTimeInterval:0.1 target:self</span><br><span class="line">                selector:@selector(doFireTimer:) userInfo:nil repeats:YES];</span><br><span class="line"> </span><br><span class="line">    NSInteger    loopCount &#x3D; 10;</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; Run the run loop 10 times to let the timer fire.</span><br><span class="line">        [myRunLoop runUntilDate:[NSDate dateWithTimeIntervalSinceNow:1]];</span><br><span class="line">        loopCount--;</span><br><span class="line">    &#125;</span><br><span class="line">    while (loopCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为长期存在的线程配置 run loop 时，最好添加<strong>至少一个输入源来接收消息</strong>。 <strong>虽然可以连接一个定时器</strong>进入 run loop ，但一旦定时器触发，它通常会失效，这会导致运行循环退出。 重复计时器可以使 run loop 运行更长的时间，但是会涉及<strong>定期触发计时器以唤醒线程，这实际上是另一种形式的轮询</strong>。 相比之下，<strong>输入源会等待事件发生，让线程保持睡眠状态</strong>。</p><h2 id="Starting-the-Run-Loop"><a href="#Starting-the-Run-Loop" class="headerlink" title="Starting the Run Loop"></a>Starting the Run Loop</h2><p>只用次级线程才需要启动 run loop 。 run loop 必须至少有一个输入源或者计时器才能进行监听，如果没有，则<strong>会立即退出</strong>。有以下几种方法可以启动 run loop</p><ul><li>无条件 (<code>run</code>)</li><li>设置时限 (<code>runUntilDate:</code>)</li><li>在特定模式下 (<code>runMode:beforeDate:</code>)</li></ul><p>无条件是最简单的，但也是最不可取的。它让 run loop 置于永久循环中，使得我们开发者<strong>无法控制它</strong>。我们可以添加和删除输入源或者计时器，但是<strong>停止它的唯一方法是杀掉他</strong>。并且它<strong>也没法在自定义模式下运行</strong>。</p><p>最好设置时限运行 run loop ，它<strong>将一直运行，直到事件到达或分配的时间到期</strong>。如果事件到达，则将该事件分派给处理程序进行处理，然后退出 run loop 。可以重新启动它以处理下一个事件。如果指定的时间到期了，只需重新启动它或使用时间进行任何所需的内务(housekeeping)处理。</p><p>可以使用特定模式运行 run loop 。它与设置时限不是互斥的，模式<strong>限制将事件传递到 run loop 的源类型</strong>。</p><p>下面的代码展示了线程主入口程序的框架，显示了 run loop 的基本结构。 实质上，将输入源和计时器添加到 run loop 中，然后重复调用其中一个程序以启动 run loop 。 每次 run loop 程序返回时，都会检查是否出现了可能需要退出该线程的任何条件。 该示例使用 Core Foundation 运行 run loop ，以便它可以检查返回结果并确定运行循环退出的原因。 如果使用 Cocoa 并且<strong>不需要检查返回值</strong>，也可以使用 NSRunLoop 类的方法以类似的方式运行 run loop (后面 Listing 3-14 有代码)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-2 Running a run loop</span><br><span class="line">- (void)skeletonThreadMain</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Set up an autorelease pool here if not using garbage collection.</span><br><span class="line">    BOOL done &#x3D; NO;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Add your sources or timers to the run loop and do any other setup.</span><br><span class="line"> </span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; Start the run loop but return after each source is handled.</span><br><span class="line">        SInt32    result &#x3D; CFRunLoopRunInMode(kCFRunLoopDefaultMode, 10, YES);</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; If a source explicitly stopped the run loop, or if there are no</span><br><span class="line">        &#x2F;&#x2F; sources or timers, go ahead and exit.</span><br><span class="line">        if ((result &#x3D;&#x3D; kCFRunLoopRunStopped) || (result &#x3D;&#x3D; kCFRunLoopRunFinished))</span><br><span class="line">            done &#x3D; YES;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; Check for any other exit conditions here and set the</span><br><span class="line">        &#x2F;&#x2F; done variable as needed.</span><br><span class="line">    &#125;</span><br><span class="line">    while (!done);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Clean up code here. Be sure to release any allocated autorelease pools.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以<strong>递归地运行</strong> run loop 。 换句话说，可以调用 CFRunLoopRun ， CFRunLoopRunInMode 或任何 NSRunLoop 方法，以便从输入源或计时器的<strong>处理程序程序中启动 run loop</strong> 。 执行此操作时，可以使用任何要运行嵌套 run loop 的模式，包括外部 run loop 使用的模式。</p><h2 id="Exiting-the-Run-Loop"><a href="#Exiting-the-Run-Loop" class="headerlink" title="Exiting the Run Loop"></a>Exiting the Run Loop</h2><p>在处理事件之前，有两种方法可以使 run loop 退出：</p><ul><li>使用超时值</li><li>告诉 run loop 停止</li></ul><p>推荐使用超时值，因为我们可以管理 run loop 。它能让 run loop <strong>完成所有的正常处理</strong>，包括给 observer 发送通知。</p><p>使用 <code>CFRunLoopStop</code> 函数可以手动停止 run loop。 run loop 发出剩下的通知后退出。用这个方法可以停止无条件启动的 run loop 。</p><p>虽然删除 run loop 的输入源和定时器也可能导致运行循环退出，但这不是停止 run loop 的可靠方法。一些系统程序将输入源添加到 run loop 以处理所需的事件。我们<strong>可能不知道它们</strong>，所以删除的时候就会漏掉它们。</p><h2 id="Thread-Safety-and-Run-Loop-Objects"><a href="#Thread-Safety-and-Run-Loop-Objects" class="headerlink" title="Thread Safety and Run Loop Objects"></a>Thread Safety and Run Loop Objects</h2><p>Core Foundation 中的函数通常是线程安全的，可以从任何线程调用。但是，如果要执行更改 run loop 配置的操作，<strong>尽可能从拥有 run loop 的线程执行此操作</strong>。</p><p>Cocoa NSRunLoop 类不像 Core Foundation 对应的那样具有内在的线程安全性。 如果使用 NSRunLoop 类来修改 run loop ，<strong>必须在拥有该 run loop 的同一线程执行此操作</strong>。 将输入源或计时器添加到属于不同线程的 run loop 可能会导致代码崩溃或以意外方式运行。<br>(ps: 在拥有 run loop 的线程中做相关更改 run loop 的操作。)</p><h1 id="Configuring-Run-Loop-Sources"><a href="#Configuring-Run-Loop-Sources" class="headerlink" title="Configuring Run Loop Sources"></a>Configuring Run Loop Sources</h1><h2 id="Defining-a-Custom-Input-Source"><a href="#Defining-a-Custom-Input-Source" class="headerlink" title="Defining a Custom Input Source"></a>Defining a Custom Input Source</h2><p>创建自定义输入源涉及到以下定义：</p><ul><li>The information you want your input source to process. (希望输入源处理的信息)</li><li>A scheduler routine to let interested clients know how to contact your input source. (让感兴趣的客户端知道如何联系输入源的 scheduler 程序)</li><li>A handler routine to perform requests sent by any clients. (执行 客户端发送的请求的 处理程序)</li><li>A cancellation routine to invalidate your input source. (使输入源无效的取消程序)</li></ul><p>由于是自定义创建输入源，所以实际配置的设计非常灵活。 scheduler handler cancellation 这些程序的实现<strong>是关键</strong>。 但是，大多数输入源行为的其余部分都发生在这些处理程序之外，可以定义 将数据传递到输入源以及将输入源传递给其他线程的 机制。</p><p>下图显示了自定义输入源的示例配置。主线程维护对输入源的引用，以及该输入源的自定义命令缓冲区(custom command buffer)以及安装输入源的 run loop 。当主线程有一个任务，想要传递给工作线程时，它会向命令缓冲区发布一个命令以及工作线程启动任务所需的任何信息。 （因为主线程和工作线程的输入源都可以访问命令缓冲区，所以必须同步该访问。） 一旦命令发布，主线程就会发出信号输入源并唤醒工作线程的 run loop 。收到唤醒命令后， run loop 调用输入源的处理程序，该处理程序处理命令缓冲区中的命令。</p><p><img src="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/Art/custominputsource.jpg" alt="Operating a custom input source"></p><p>以下部分介绍了上图中自定义输入源的实现，并显示了需要实现的关键代码。(ps: 具体 demo 见 <a href="https://github.com/JoakimLiu/RunLoopDemo">RunLoopDemo</a>)</p><h3 id="Defining-the-Input-Source"><a href="#Defining-the-Input-Source" class="headerlink" title="Defining the Input Source"></a>Defining the Input Source</h3><p>定义自定义输入源需要使用 Core Foundation 程序来配置 run loop 源并将其附加到 run loop 。 虽然基本处理程序是基于 C 的函数，但这并不妨碍为这些函数编写包装器并使用 Objective-C 或 C++ 来实现。 </p><p>下面的代码中， RunLoopSource 对象管理命令缓冲区并使用该缓冲区从其他线程接收消息。 RunLoopContext 是一个容器对象，用于传递 RunLoopSource 对象和对应用程序主线程的 run loop 引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-3  The custom input source object definition</span><br><span class="line">@interface RunLoopSource : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    CFRunLoopSourceRef runLoopSource;</span><br><span class="line">    NSMutableArray* commands;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (id)init;</span><br><span class="line">- (void)addToCurrentRunLoop;</span><br><span class="line">- (void)invalidate;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Handler method</span><br><span class="line">- (void)sourceFired;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Client interface for registering commands to process</span><br><span class="line">- (void)addCommand:(NSInteger)command withData:(id)data;</span><br><span class="line">- (void)fireAllCommandsOnRunLoop:(CFRunLoopRef)runloop;</span><br><span class="line"> </span><br><span class="line">@end</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; These are the CFRunLoopSourceRef callback functions.</span><br><span class="line">void RunLoopSourceScheduleRoutine (void *info, CFRunLoopRef rl, CFStringRef mode);</span><br><span class="line">void RunLoopSourcePerformRoutine (void *info);</span><br><span class="line">void RunLoopSourceCancelRoutine (void *info, CFRunLoopRef rl, CFStringRef mode);</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; RunLoopContext is a container object used during registration of the input source.</span><br><span class="line">@interface RunLoopContext : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    CFRunLoopRef        runLoop;</span><br><span class="line">    RunLoopSource*        source;</span><br><span class="line">&#125;</span><br><span class="line">@property (readonly) CFRunLoopRef runLoop;</span><br><span class="line">@property (readonly) RunLoopSource* source;</span><br><span class="line"> </span><br><span class="line">- (id)initWithSource:(RunLoopSource*)src andLoop:(CFRunLoopRef)loop;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>当将 run loop 源添加到 run loop 时，就调用 <code>RunLoopSourceScheduleRoutine</code> 函数。之前有说过，输入源只有一个客户端，那就是主线程，所以将 RunLoopContext 传递过去，方便 delegate 和输入源通信。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-4 Scheduling a run loop source</span><br><span class="line">void RunLoopSourceScheduleRoutine (void *info, CFRunLoopRef rl, CFStringRef mode)</span><br><span class="line">&#123;</span><br><span class="line">    RunLoopSource* obj &#x3D; (RunLoopSource*)info;</span><br><span class="line">    AppDelegate*   del &#x3D; [AppDelegate sharedAppDelegate];</span><br><span class="line">    RunLoopContext* theContext &#x3D; [[RunLoopContext alloc] initWithSource:obj andLoop:rl];</span><br><span class="line"> </span><br><span class="line">    [del performSelectorOnMainThread:@selector(registerSource:)</span><br><span class="line">                                withObject:theContext waitUntilDone:NO];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当输入源被发出信号时，调用 <code>RunLoopSourcePerformRoutine</code> 处理数据，它是最重要的回调函数。 这里只是简单的调用 RunLoopSource 的 <code>sourceFired</code> 方法，后面会讲到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-5  Performing work in the input source</span><br><span class="line">void RunLoopSourcePerformRoutine (void *info)</span><br><span class="line">&#123;</span><br><span class="line">    RunLoopSource*  obj &#x3D; (RunLoopSource*)info;</span><br><span class="line">    [obj sourceFired];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用 <code>CFRunLoopSourceInvalidate</code> 函数从 run loop 中删除输入源，系统将调用输入源的取消程序 <code>RunLoopSourceCancelRoutine</code> 。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-6  Invalidating an input source</span><br><span class="line">void RunLoopSourceCancelRoutine (void *info, CFRunLoopRef rl, CFStringRef mode)</span><br><span class="line">&#123;</span><br><span class="line">    RunLoopSource* obj &#x3D; (RunLoopSource*)info;</span><br><span class="line">    AppDelegate* del &#x3D; [AppDelegate sharedAppDelegate];</span><br><span class="line">    RunLoopContext* theContext &#x3D; [[RunLoopContext alloc] initWithSource:obj andLoop:rl];</span><br><span class="line"> </span><br><span class="line">    [del performSelectorOnMainThread:@selector(removeSource:)</span><br><span class="line">                                withObject:theContext waitUntilDone:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Installing-the-Input-Source-on-the-Run-Loop"><a href="#Installing-the-Input-Source-on-the-Run-Loop" class="headerlink" title="Installing the Input Source on the Run Loop"></a>Installing the Input Source on the Run Loop</h3><p>下面显示了 RunLoopSource 类的 <code>init</code> 和 <code>addToCurrentRunLoop</code> 方法。 <code>init</code> 方法创建 CFRunLoopSourceRef opaque 类型，<strong>该类型必须附加到 run loop</strong> 。 它将 RunLoopSource 对象本身作为上下文信息传递，以便回调程序具有指向该对象的指针。 在工作线程调用 <code>addToCurrentRunLoop</code> 方法时才会安装输入源，此时将调用 <code>RunLoopSourceScheduleRoutine</code> 回调函数。 一旦输入源被添加到 run loop 中，线程就可以运行其 run loop 来等待它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-7  Installing the run loop source</span><br><span class="line">- (id)init</span><br><span class="line">&#123;</span><br><span class="line">    CFRunLoopSourceContext    context &#x3D; &#123;0, self, NULL, NULL, NULL, NULL, NULL,</span><br><span class="line">                                        &amp;RunLoopSourceScheduleRoutine,</span><br><span class="line">                                        RunLoopSourceCancelRoutine,</span><br><span class="line">                                        RunLoopSourcePerformRoutine&#125;;</span><br><span class="line"> </span><br><span class="line">    runLoopSource &#x3D; CFRunLoopSourceCreate(NULL, 0, &amp;context);</span><br><span class="line">    commands &#x3D; [[NSMutableArray alloc] init];</span><br><span class="line"> </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)addToCurrentRunLoop</span><br><span class="line">&#123;</span><br><span class="line">    CFRunLoopRef runLoop &#x3D; CFRunLoopGetCurrent();</span><br><span class="line">    CFRunLoopAddSource(runLoop, runLoopSource, kCFRunLoopDefaultMode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Coordinating-with-Clients-of-the-Input-Source"><a href="#Coordinating-with-Clients-of-the-Input-Source" class="headerlink" title="Coordinating with Clients of the Input Source"></a>Coordinating with Clients of the Input Source</h3><p>要使输入源有用，需要对其进行操作，并从另一个线程发出信号。输入源的<strong>重点是</strong>将其关联的线程置于休眠状态，直到有事情要做才唤醒。所以，需要让应用程序中的<strong>其他线程知道输入源</strong>，并有办法与之通信。</p><p>通知客户端输入源的一种方法是，在输入源首次安装在其 run loop 上时<strong>发出注册请求</strong>。 可以使用任意数量的客户端注册输入源，或者只需将其注册到某个中央代理商，然后将输入源发送给感兴趣的客户。下面代码显示了应用程序委托定义的注册方法，并在调用 RunLoopSource 对象的调度程序函数时调用。 此方法接收 RunLoopSource 对象提供的 RunLoopContext 对象，并将其添加到其源列表中。 还显示了从 run loop 中删除输入源时用于取消注册的程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-8  Registering and removing an input source with the application delegate</span><br><span class="line">- (void)registerSource:(RunLoopContext*)sourceInfo;</span><br><span class="line">&#123;</span><br><span class="line">    [sourcesToPing addObject:sourceInfo];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)removeSource:(RunLoopContext*)sourceInfo</span><br><span class="line">&#123;</span><br><span class="line">    id    objToRemove &#x3D; nil;</span><br><span class="line"> </span><br><span class="line">    for (RunLoopContext* context in sourcesToPing)</span><br><span class="line">    &#123;</span><br><span class="line">        if ([context isEqual:sourceInfo])</span><br><span class="line">        &#123;</span><br><span class="line">            objToRemove &#x3D; context;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (objToRemove)</span><br><span class="line">        [sourcesToPing removeObject:objToRemove];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Signaling-the-Input-Source"><a href="#Signaling-the-Input-Source" class="headerlink" title="Signaling the Input Source"></a>Signaling the Input Source</h3><p>在将数据移交给输入源之后，<strong>客户端必须向源发信号并唤醒其 run loop</strong> 。 信号源使 run loop 知道源已准备好进行处理。 并且因为线程可能在信号发生时处于睡眠状态，所以手动唤醒 run loop 。 如果不这样做可能会导致处理输入源的延迟。</p><p>下面代码显示了 RunLoopSource 对象的 <code>fireCommandsOnRunLoop</code> 方法。 当客户端准备好处理他们添加到缓冲区的命令时，客户端会调用此方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-9  Waking up the run loop</span><br><span class="line">- (void)fireCommandsOnRunLoop:(CFRunLoopRef)runloop</span><br><span class="line">&#123;</span><br><span class="line">    CFRunLoopSourceSignal(runLoopSource);</span><br><span class="line">    CFRunLoopWakeUp(runloop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Configuring-Timer-Sources"><a href="#Configuring-Timer-Sources" class="headerlink" title="Configuring Timer Sources"></a>Configuring Timer Sources</h2><p>要创建计时器源，所要做的就是创建一个计时器对象并在 run loop 上安排(schedule)它。在 Cocoa 中，使用 NSTimer 创建计时器对象，在 Core Foundation 中使用 CFRunLoopTimerRef opaque 类型。在内部， NSTimer 类只是 Core Foundation 的扩展，它提供了一些便利功能。用以下方法可以创建</p><ul><li><code>cheduledTimerWithTimeInterval:target:selector:userInfo:repeats:</code></li><li><code>scheduledTimerWithTimeInterval:invocation:repeats:</code></li></ul><p>这些方法创建计时器并将其以默认模式（NSDefaultRunLoopMode）<strong>添加到当前线程</strong>的 run loop 中。如果需要，还可以手动调度计时器，方法是创建 NSTimer 对象，然后使用 NSRunLoop 的 <code>addTimer:forMode:</code> 方法将其添加到 run loop 中。这两种技术基本上都是一样的，但是可以对计时器的配置进行不同程度的控制。例如，如果创建计时器并手动将其添加到 run loop ，则可以使用默认模式以外的模式执行此操作。下面的代码显示了如何使用这两种技术创建计时器。第一个计时器的初始延迟为 1 秒，但之后每 0.1 秒定时触发一次。第二个计时器在最初的 0.2秒延迟后开始触发，然后每 0.2 秒触发一次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-10  Creating and scheduling timers using NSTimer</span><br><span class="line">NSRunLoop* myRunLoop &#x3D; [NSRunLoop currentRunLoop];</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Create and schedule the first timer.</span><br><span class="line">NSDate* futureDate &#x3D; [NSDate dateWithTimeIntervalSinceNow:1.0];</span><br><span class="line">NSTimer* myTimer &#x3D; [[NSTimer alloc] initWithFireDate:futureDate</span><br><span class="line">                        interval:0.1</span><br><span class="line">                        target:self</span><br><span class="line">                        selector:@selector(myDoFireTimer1:)</span><br><span class="line">                        userInfo:nil</span><br><span class="line">                        repeats:YES];</span><br><span class="line">[myRunLoop addTimer:myTimer forMode:NSDefaultRunLoopMode];</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Create and schedule the second timer.</span><br><span class="line">[NSTimer scheduledTimerWithTimeInterval:0.2</span><br><span class="line">                        target:self</span><br><span class="line">                        selector:@selector(myDoFireTimer2:)</span><br><span class="line">                        userInfo:nil</span><br><span class="line">                        repeats:YES];</span><br></pre></td></tr></table></figure><p>下面的代码展示了使用 Core Foundation 函数配置计时器所需的代码。 虽然此示例未在上下文结构中传递任何用户定义的信息，但可以使用此结构传递计时器所需的任何自定义数据。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-11  Creating and scheduling a timer using Core Foundation</span><br><span class="line">CFRunLoopRef runLoop &#x3D; CFRunLoopGetCurrent();</span><br><span class="line">CFRunLoopTimerContext context &#x3D; &#123;0, NULL, NULL, NULL, NULL&#125;;</span><br><span class="line">CFRunLoopTimerRef timer &#x3D; CFRunLoopTimerCreate(kCFAllocatorDefault, 0.1, 0.3, 0, 0,</span><br><span class="line">                                        &amp;myCFTimerCallback, &amp;context);</span><br><span class="line"> </span><br><span class="line">CFRunLoopAddTimer(runLoop, timer, kCFRunLoopCommonModes);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Configuring-a-Port-Based-Input-Source"><a href="#Configuring-a-Port-Based-Input-Source" class="headerlink" title="Configuring a Port-Based Input Source"></a>Configuring a Port-Based Input Source</h2><p>Cocoa 和 Core Foundation 都提供了基于端口的对象，<strong>用于线程之间或进程之间的通信</strong>。 以下部分介绍如何使用多种不同类型的端口设置端口通信。</p><h3 id="Configuring-an-NSMachPort-Object"><a href="#Configuring-an-NSMachPort-Object" class="headerlink" title="Configuring an NSMachPort Object"></a>Configuring an NSMachPort Object</h3><p>要与 NSMachPort 对象建立本地连接，请创建端口对象并将其添加到主线程的 run loop 中。 启动次级线程时，将同一对象传递给线程的入口函数。 次级线程可以使用相同的对象将消息发送回主线程。</p><h4 id="Implementing-the-Main-Thread-Code"><a href="#Implementing-the-Main-Thread-Code" class="headerlink" title="Implementing the Main Thread Code"></a>Implementing the Main Thread Code</h4><p>下面的代码展示了启动次级工作线程的主要代码。因为 Cocoa 框架执行许多配置端口和 run loop 的干预步骤，所以 <code>launchThread</code> 方法明显比其 Core Foundation 等效方法要短（见后面 Listing 3-17）; 然而，两者的行为几乎完全相同。 一个区别是，该方法不是直接向工作线程发送本地端口的名称，而是直接发送 NSPort 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-12  Main thread launch method</span><br><span class="line">- (void)launchThread</span><br><span class="line">&#123;</span><br><span class="line">    NSPort* myPort &#x3D; [NSMachPort port];</span><br><span class="line">    if (myPort)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; This class handles incoming port messages.</span><br><span class="line">        [myPort setDelegate:self];</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; Install the port as an input source on the current run loop.</span><br><span class="line">        [[NSRunLoop currentRunLoop] addPort:myPort forMode:NSDefaultRunLoopMode];</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; Detach the thread. Let the worker release the port.</span><br><span class="line">        [NSThread detachNewThreadSelector:@selector(LaunchThreadWithPort:)</span><br><span class="line">               toTarget:[MyWorkerClass class] withObject:myPort];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了在线程之间建立双向通信通道，可能希望让工作线程在 check-in 消息中将其自己的本地端口发送到主线程。 通过接收 check-in 消息，主线程可以知道在启动工作线程时一切顺利，并且还提供了向该线程发送更多消息的方法。</p><p>下面的代码显示了主线程的 <code>handlePortMessage:</code> 方法。 当数据到达线程自己的本地端口时，将调用此方法。 当 check-in 消息到达时，该方法直接从端口消息中检索次级线程的端口并保存以供以后使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-13  Handling Mach port messages</span><br><span class="line"></span><br><span class="line">#define kCheckinMessage 100</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Handle responses from the worker thread.</span><br><span class="line">- (void)handlePortMessage:(NSPortMessage *)portMessage</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int message &#x3D; [portMessage msgid];</span><br><span class="line">    NSPort* distantPort &#x3D; nil;</span><br><span class="line"> </span><br><span class="line">    if (message &#x3D;&#x3D; kCheckinMessage)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; Get the worker thread’s communications port.</span><br><span class="line">        distantPort &#x3D; [portMessage sendPort];</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; Retain and save the worker port for later use.</span><br><span class="line">        [self storeDistantPort:distantPort];</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; Handle other messages.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Implementing-the-Secondary-Thread-Code"><a href="#Implementing-the-Secondary-Thread-Code" class="headerlink" title="Implementing the Secondary Thread Code"></a>Implementing the Secondary Thread Code</h4><p>对于次级工作线程，必须配置线程并使用指定的端口将信息传递回主线程。</p><p>下面代码显示了设置工作线程的代码。 在为线程创建自动释放池之后，该方法创建一个工作对象来驱动线程执行。 worker 对象的 <code>sendCheckinMessage:</code> 方法（如后面 Listing 3-15 所示）为工作线程创建一个本地端口，并将一个 check-in 发送回主线程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-14  Launching the worker thread using Mach ports</span><br><span class="line"></span><br><span class="line">+(void)LaunchThreadWithPort:(id)inData</span><br><span class="line">&#123;</span><br><span class="line">    NSAutoreleasePool*  pool &#x3D; [[NSAutoreleasePool alloc] init];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Set up the connection between this thread and the main thread.</span><br><span class="line">    NSPort* distantPort &#x3D; (NSPort*)inData;</span><br><span class="line"> </span><br><span class="line">    MyWorkerClass*  workerObj &#x3D; [[self alloc] init];</span><br><span class="line">    [workerObj sendCheckinMessage:distantPort];</span><br><span class="line">    [distantPort release];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Let the run loop process things.</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">        [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode</span><br><span class="line">                            beforeDate:[NSDate distantFuture]];</span><br><span class="line">    &#125;</span><br><span class="line">    while (![workerObj shouldExit]);</span><br><span class="line"> </span><br><span class="line">    [workerObj release];</span><br><span class="line">    [pool release];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 NSMachPort 时，本地和远程线程可以使用相同的端口对象进行线程之间的单向通信。 换句话说，由一个线程创建的本地端口对象成为另一个线程的远程端口对象。</p><p>下面代码显示了次级线程的 check-in 程序。 此方法为将来的通信设置自己的本地端口，然后将 check-in 消息发送回主线程。 该方法使用 <code>LaunchThreadWithPort:</code> 方法中接收的端口对象作为消息的目标。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-15  Sending the check-in message using Mach ports</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Worker thread check-in method</span><br><span class="line">- (void)sendCheckinMessage:(NSPort*)outPort</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Retain and save the remote port for future use.</span><br><span class="line">    [self setRemotePort:outPort];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Create and configure the worker thread port.</span><br><span class="line">    NSPort* myPort &#x3D; [NSMachPort port];</span><br><span class="line">    [myPort setDelegate:self];</span><br><span class="line">    [[NSRunLoop currentRunLoop] addPort:myPort forMode:NSDefaultRunLoopMode];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Create the check-in message.</span><br><span class="line">    NSPortMessage* messageObj &#x3D; [[NSPortMessage alloc] initWithSendPort:outPort</span><br><span class="line">                                         receivePort:myPort components:nil];</span><br><span class="line"> </span><br><span class="line">    if (messageObj)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; Finish configuring the message and send it immediately.</span><br><span class="line">        [messageObj setMsgId:setMsgid:kCheckinMessage];</span><br><span class="line">        [messageObj sendBeforeDate:[NSDate date]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Configuring-an-NSMessagePort-Object"><a href="#Configuring-an-NSMessagePort-Object" class="headerlink" title="Configuring an NSMessagePort Object"></a>Configuring an NSMessagePort Object</h3><p>要与 NSMessagePort 对象建立本地连接，不能简单地在线程之间传递端口对象。 必须按名称获取远程消息端口。 在 Cocoa 中实现这一点需要使用特定名称注册本地端口，然后将该名称传递给远程线程，以便它可以获取适当的端口对象进行通信。 下面代码显示了在要使用消息端口的情况下的端口创建和注册过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-16  Registering a message port</span><br><span class="line"></span><br><span class="line">NSPort* localPort &#x3D; [[NSMessagePort alloc] init];</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Configure the object and add it to the current run loop.</span><br><span class="line">[localPort setDelegate:self];</span><br><span class="line">[[NSRunLoop currentRunLoop] addPort:localPort forMode:NSDefaultRunLoopMode];</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Register the port using a specific name. The name must be unique.</span><br><span class="line">NSString* localPortName &#x3D; [NSString stringWithFormat:@&quot;MyPortName&quot;];</span><br><span class="line">[[NSMessagePortNameServer sharedInstance] registerPort:localPort</span><br><span class="line">                     name:localPortName];</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Configuring-a-Port-Based-Input-Source-in-Core-Foundation"><a href="#Configuring-a-Port-Based-Input-Source-in-Core-Foundation" class="headerlink" title="Configuring a Port-Based Input Source in Core Foundation"></a>Configuring a Port-Based Input Source in Core Foundation</h3><p>本节介绍如何使用 Core Foundation 在应用程序的主线程和工作线程之间建立双向通信通道。</p><p>下面代码显示了应用程序主线程调用以启动工作线程的代码。 代码所做的第一件事就是设置一个 CFMessagePortRef opaque 类型来监听来自工作线程的消息。 工作线程需要端口的名称来建立连接，以便将字符串值传递给工作线程的入口函数。 端口名称在当前用户上下文中通常应该是唯一的； 否则，可能会遇到冲突。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-17  Attaching a Core Foundation message port to a new thread</span><br><span class="line"></span><br><span class="line">#define kThreadStackSize        (8 *4096)</span><br><span class="line"> </span><br><span class="line">OSStatus MySpawnThread()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Create a local port for receiving responses.</span><br><span class="line">    CFStringRef myPortName;</span><br><span class="line">    CFMessagePortRef myPort;</span><br><span class="line">    CFRunLoopSourceRef rlSource;</span><br><span class="line">    CFMessagePortContext context &#x3D; &#123;0, NULL, NULL, NULL, NULL&#125;;</span><br><span class="line">    Boolean shouldFreeInfo;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Create a string with the port name.</span><br><span class="line">    myPortName &#x3D; CFStringCreateWithFormat(NULL, NULL, CFSTR(&quot;com.myapp.MainThread&quot;));</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Create the port.</span><br><span class="line">    myPort &#x3D; CFMessagePortCreateLocal(NULL,</span><br><span class="line">                myPortName,</span><br><span class="line">                &amp;MainThreadResponseHandler,</span><br><span class="line">                &amp;context,</span><br><span class="line">                &amp;shouldFreeInfo);</span><br><span class="line"> </span><br><span class="line">    if (myPort !&#x3D; NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; The port was successfully created.</span><br><span class="line">        &#x2F;&#x2F; Now create a run loop source for it.</span><br><span class="line">        rlSource &#x3D; CFMessagePortCreateRunLoopSource(NULL, myPort, 0);</span><br><span class="line"> </span><br><span class="line">        if (rlSource)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; Add the source to the current run loop.</span><br><span class="line">            CFRunLoopAddSource(CFRunLoopGetCurrent(), rlSource, kCFRunLoopDefaultMode);</span><br><span class="line"> </span><br><span class="line">            &#x2F;&#x2F; Once installed, these can be freed.</span><br><span class="line">            CFRelease(myPort);</span><br><span class="line">            CFRelease(rlSource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Create the thread and continue processing.</span><br><span class="line">    MPTaskID        taskID;</span><br><span class="line">    return(MPCreateTask(&amp;ServerThreadEntryPoint,</span><br><span class="line">                    (void*)myPortName,</span><br><span class="line">                    kThreadStackSize,</span><br><span class="line">                    NULL,</span><br><span class="line">                    NULL,</span><br><span class="line">                    NULL,</span><br><span class="line">                    0,</span><br><span class="line">                    &amp;taskID));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安装端口并启动线程后，主线程可以在等待线程 check in 时继续其常规执行。当 check-in 消息到达时，它将被分派到主线程的 <code>MainThreadResponseHandler </code>函数，如下面代码所示，此函数提取工作线程的端口名称，并为将来的通信创建管道。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-18  Receiving the checkin message</span><br><span class="line"></span><br><span class="line">#define kCheckinMessage 100</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Main thread port message handler</span><br><span class="line">CFDataRef MainThreadResponseHandler(CFMessagePortRef local,</span><br><span class="line">                    SInt32 msgid,</span><br><span class="line">                    CFDataRef data,</span><br><span class="line">                    void* info)</span><br><span class="line">&#123;</span><br><span class="line">    if (msgid &#x3D;&#x3D; kCheckinMessage)</span><br><span class="line">    &#123;</span><br><span class="line">        CFMessagePortRef messagePort;</span><br><span class="line">        CFStringRef threadPortName;</span><br><span class="line">        CFIndex bufferLength &#x3D; CFDataGetLength(data);</span><br><span class="line">        UInt8* buffer &#x3D; CFAllocatorAllocate(NULL, bufferLength, 0);</span><br><span class="line"> </span><br><span class="line">        CFDataGetBytes(data, CFRangeMake(0, bufferLength), buffer);</span><br><span class="line">        threadPortName &#x3D; CFStringCreateWithBytes (NULL, buffer, bufferLength, kCFStringEncodingASCII, FALSE);</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; You must obtain a remote message port by name.</span><br><span class="line">        messagePort &#x3D; CFMessagePortCreateRemote(NULL, (CFStringRef)threadPortName);</span><br><span class="line"> </span><br><span class="line">        if (messagePort)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; Retain and save the thread’s comm port for future reference.</span><br><span class="line">            AddPortToListOfActiveThreads(messagePort);</span><br><span class="line"> </span><br><span class="line">            &#x2F;&#x2F; Since the port is retained by the previous function, release</span><br><span class="line">            &#x2F;&#x2F; it here.</span><br><span class="line">            CFRelease(messagePort);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; Clean up.</span><br><span class="line">        CFRelease(threadPortName);</span><br><span class="line">        CFAllocatorDeallocate(NULL, buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; Process other messages.</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置主线程后，剩下的唯一事情就是新创建的工作线程创建自己的端口并 check in 。下面代码展示了工作线程的入口函数。 该函数提取主线程的端口名称，并使用它创建一个返回主线程的远程连接。 然后，该函数为自己创建一个本地端口，在该线程的 run loop 上安装该端口，并向包含本地端口名称的主线程发送一个 check-in 消息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-19  Setting up the thread structures</span><br><span class="line"></span><br><span class="line">OSStatus ServerThreadEntryPoint(void* param)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Create the remote port to the main thread.</span><br><span class="line">    CFMessagePortRef mainThreadPort;</span><br><span class="line">    CFStringRef portName &#x3D; (CFStringRef)param;</span><br><span class="line"> </span><br><span class="line">    mainThreadPort &#x3D; CFMessagePortCreateRemote(NULL, portName);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Free the string that was passed in param.</span><br><span class="line">    CFRelease(portName);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Create a port for the worker thread.</span><br><span class="line">    CFStringRef myPortName &#x3D; CFStringCreateWithFormat(NULL, NULL, CFSTR(&quot;com.MyApp.Thread-%d&quot;), MPCurrentTaskID());</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Store the port in this thread’s context info for later reference.</span><br><span class="line">    CFMessagePortContext context &#x3D; &#123;0, mainThreadPort, NULL, NULL, NULL&#125;;</span><br><span class="line">    Boolean shouldFreeInfo;</span><br><span class="line">    Boolean shouldAbort &#x3D; TRUE;</span><br><span class="line"> </span><br><span class="line">    CFMessagePortRef myPort &#x3D; CFMessagePortCreateLocal(NULL,</span><br><span class="line">                myPortName,</span><br><span class="line">                &amp;ProcessClientRequest,</span><br><span class="line">                &amp;context,</span><br><span class="line">                &amp;shouldFreeInfo);</span><br><span class="line"> </span><br><span class="line">    if (shouldFreeInfo)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; Couldn&#39;t create a local port, so kill the thread.</span><br><span class="line">        MPExit(0);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    CFRunLoopSourceRef rlSource &#x3D; CFMessagePortCreateRunLoopSource(NULL, myPort, 0);</span><br><span class="line">    if (!rlSource)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; Couldn&#39;t create a local port, so kill the thread.</span><br><span class="line">        MPExit(0);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Add the source to the current run loop.</span><br><span class="line">    CFRunLoopAddSource(CFRunLoopGetCurrent(), rlSource, kCFRunLoopDefaultMode);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Once installed, these can be freed.</span><br><span class="line">    CFRelease(myPort);</span><br><span class="line">    CFRelease(rlSource);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Package up the port name and send the check-in message.</span><br><span class="line">    CFDataRef returnData &#x3D; nil;</span><br><span class="line">    CFDataRef outData;</span><br><span class="line">    CFIndex stringLength &#x3D; CFStringGetLength(myPortName);</span><br><span class="line">    UInt8* buffer &#x3D; CFAllocatorAllocate(NULL, stringLength, 0);</span><br><span class="line"> </span><br><span class="line">    CFStringGetBytes(myPortName,</span><br><span class="line">                CFRangeMake(0,stringLength),</span><br><span class="line">                kCFStringEncodingASCII,</span><br><span class="line">                0,</span><br><span class="line">                FALSE,</span><br><span class="line">                buffer,</span><br><span class="line">                stringLength,</span><br><span class="line">                NULL);</span><br><span class="line"> </span><br><span class="line">    outData &#x3D; CFDataCreate(NULL, buffer, stringLength);</span><br><span class="line"> </span><br><span class="line">    CFMessagePortSendRequest(mainThreadPort, kCheckinMessage, outData, 0.1, 0.0, NULL, NULL);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Clean up thread data structures.</span><br><span class="line">    CFRelease(outData);</span><br><span class="line">    CFAllocatorDeallocate(NULL, buffer);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Enter the run loop.</span><br><span class="line">    CFRunLoopRun();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦进入其 run loop，发送到该线程端口的所有未来事件都由 <code>ProcessClientRequest</code> 函数处理。 该函数的实现取决于线程的工作类型，这里没有显示。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对 &lt;a href=&quot;https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1&quot;&gt;Threading Programming Guide - Run Loops&lt;/a&gt; 文档的一个学习(其中参考了 &lt;a href=&quot;https://opensource.apple.com/source/CF/CF-1153.18/CFRunLoop.c.auto.html&quot;&gt;CFRunLoop&lt;/a&gt; 源码)，其他例子在后期系统了解某个技术有涉及时再说。 其他高质量文章可见&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.ibireme.com/2015/05/18/runloop/&quot;&gt;深入理解RunLoop&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://mrpeak.cn/blog/ios-runloop/&quot;&gt;解密 Runloop&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="runloop" scheme="http://example.com/tags/runloop/"/>
    
  </entry>
  
  <entry>
    <title>Image and Graphics Best Practices</title>
    <link href="http://example.com/2019/03/02/wwdc-2018-219/"/>
    <id>http://example.com/2019/03/02/wwdc-2018-219/</id>
    <published>2019-03-02T07:38:31.000Z</published>
    <updated>2021-05-20T15:34:25.624Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对 <a href="https://developer.apple.com/videos/play/wwdc2018/219/">Image and Graphics Best Practices</a> 的一个学习记录文章，主要讲了图像加载的过程，要怎么优化内存和 CPU ，构建更流畅的应用程序。</p><a id="more"></a><h1 id="Memory-and-CPU"><a href="#Memory-and-CPU" class="headerlink" title="Memory and CPU"></a>Memory and CPU</h1><p>它们是最重要的资源，它们都有各自独立的检测工具，它们是错综复杂联系在一起的。当 app 使用更多的 CPU 时，对电池寿命和响应有负面影响。不那么明显的是，当你的 App 和系统上其他 App 消耗更多的内存时，也会导致更多的 CPU 使用率，对电池寿命和性能有一定的不利影响。所以要减少内存和 CPU 的使用。</p><p>内存和CPU分别对性能的影响。</p><h1 id="UIImage-and-UIImageView"><a href="#UIImage-and-UIImageView" class="headerlink" title="UIImage and UIImageView"></a>UIImage and UIImageView</h1><p>在 MVC 风格上， UIImage 是一个 model, UIImageView 则是 view 。它们的责任就是， UIImage 负责加载图像内容， UIImageView 负责显示渲染它，如下图所示</p><p><img src="https://github.com/JoakimLiu/BlogPhoto/blob/master/wwdc/2018/219/mvc.png?raw=true" alt="UIImage UIImageView MVC"></p><p>其实它们的关系不像上图那样单一，实际上会更加复杂一点，如下图所示，中间还有一个隐藏的阶段：解码(decoding)，当然渲染是一个持续的过程。</p><p><img src="https://github.com/JoakimLiu/BlogPhoto/blob/master/wwdc/2018/219/image-rendering-pipeline.png?raw=true" alt="Image Rendering Pipeline"></p><p>为了讨论解码，我们先讨论一个叫做缓冲区(buffer)的概念，它是一段连续的内存区域。习惯用缓冲区来表示由<strong>一系列元素组成的内存</strong>，这些元素具有相同尺寸，并通常具有相同的内部结构。</p><p><img src="https://github.com/JoakimLiu/BlogPhoto/blob/master/wwdc/2018/219/buffers.png?raw=true" alt="Buffers"></p><h2 id="Image-Buffers"><a href="#Image-Buffers" class="headerlink" title="Image Buffers"></a>Image Buffers</h2><p>图像缓冲区(Image Buffers)是一种特殊缓冲区。</p><ul><li>在内存中以图像的形式展现</li><li>每个元素描述了图像中每个像素的颜色和透明度</li><li>此缓冲区的内存大小与它包含图像的大小成正比</li></ul><p><img src="https://github.com/JoakimLiu/BlogPhoto/blob/master/wwdc/2018/219/image-buffers.png?raw=true" alt="Image Buffers"></p><h3 id="The-frame-buffer"><a href="#The-frame-buffer" class="headerlink" title="The frame buffer"></a>The frame buffer</h3><p>帧缓冲区(frame buffer)负责在 App 中保存实际渲染后的输出。因此，当你的 App 更新其视图层级结构时， UIKit 将重新渲染 App 的窗口及其所有子视图到帧缓冲区。该帧缓冲区提供每个像素的<strong>颜色信息</strong>，显示硬件将读取这些信息，以便点亮显示器上对应的像素。 最后一部分（即显示器读取）以固定的时间间隔发生， 60Hz(每 1/60s(约 16.67hm) 一次) ，在配备 ProMotion Display 的 iPad 上是 120Hz 。如果 App 没有任何改变，则显示硬件会将它上次看到的相同数据从帧缓冲区取出。当改变时，例如改变 image , UIKit 会重新渲染，走之前的流程。流程图如下：</p><p><img src="https://github.com/JoakimLiu/BlogPhoto/blob/master/wwdc/2018/219/frame-buffer.png?raw=true" alt="frame buffer"></p><h2 id="Data-Buffers"><a href="#Data-Buffers" class="headerlink" title="Data Buffers"></a>Data Buffers</h2><p>数据缓冲区(data buffer)，一种包含一系列字节的缓冲区。 包含图像文件的数据缓冲区通常以某些元数据开头，这些元数据描述了存储在数据缓冲区中的图像大小。(ps:有一个无需下载图像就能知道图像大小的第三方库 <a href="https://github.com/malcommac/ImageSizeFetcher">ImageSizeFetcher</a>)</p><h2 id="Pipeline-in-Action"><a href="#Pipeline-in-Action" class="headerlink" title="Pipeline in Action"></a>Pipeline in Action</h2><p>下图讲了显示图像设置管道。</p><p><img src="https://github.com/JoakimLiu/BlogPhoto/blob/master/wwdc/2018/219/pipeline-in-action.png?raw=true" alt="Pipeline in Action"></p><p>有一个图像视图(UIImageView) ，右边白色实线标记是它的帧缓冲区区域（该区域将由图像进行渲染填充，在此图中，已被帧缓冲区填满），我们为图像视图设置了一个图像(UIImage 从磁盘读取或者网络请求得到的)，它有一个表示图像的数据缓冲区。但是我们需要用像素数据来填充帧缓冲区，所以图像将分配一个图像缓冲区（其大小等于包含在数据缓冲区中的图像的大小，图像的内存大小怎么算呢？见下面的 ps），并执行解码操作（将 JEPG 或者 PNG 或者其他编码的图像数据转换为每个像素的图像信息）。然后取决于我们的图像视图的内容模式，当 UIKit 要求图像视图进行渲染时，它将复制并缩放图像缓冲区中的图像数据，同时将其复制到帧缓冲区中。</p><p>(ps: <a href="http://joakimliu.github.io/2019/02/24/wwdc-2011-129/">Practical Drawing for iOS Developers(Quartz 2D Programming Guide)</a> 里面 <code>MyCreateBitmapContext</code> 有讲到，<code>pixelsWide*4*pixelsHigh</code>(像素宽 * 4 * 像素高，因为位图中的每个像素由4个字节(byte)表示; 红色，绿色，蓝色和 alpha 各 8 位(bit))，用代码就是 <code>CGImageGetHeight(thumbImage.CGImage) * CGImageGetBytesPerRow(thumbImage.CGImage)</code>) 3000*2000 pixel</p><p><img src="https://github.com/JoakimLiu/BlogPhoto/blob/master/wwdc/2018/219/decoding-concerns.png?raw=true" alt="Decoding Concerns"></p><p>在解码阶段是 CPU 密集型的，特别是对于大型图像。因此，不是每次 UIKit 要求图像视图渲染时都执行一次这个过程，图像绑定在该图像缓冲区上，因此它<strong>只能执行一次这个过程</strong>。 因此，对于每个被解码的图像， App 可能会持续存在大量的内存分配。这种内存分配<strong>与输入图像的大小成正比</strong>，而与帧缓冲区中实际渲染的<strong>图像视图的大小没有必然联系</strong>。    所以对性能会产生一些负面影响。 App 地址空间中的大块内存分配可能会迫使其他相关内容远离它想要引用的内容，这种情况被称为碎片，滥用内存的后果。 最终，如果 App 开始占用越来越多的内存，操作系统将会介入，并开始透明的压缩物理内存(physical memory)的内容。CPU 需要参与到这个操作中，因此除了你自己 App 对 CPU 的使用外，你可能会增加<strong>无法控制的</strong>全局 CPU 使用率。最终，你的 App 可能会消耗更多的物理内存，以至于操作系统需要启动终止进程，它将从低优先级的后台进程开始。如果你的 App 消耗了达到特定数量的内存，你的 App 可能会被终止。而其中被终止的后台进程可能正执行某些重要的工作，因此，它们可能一终止就立即重新启动。所以，即使你的 App 可能只会在短时间内消耗内存，它可能对 CPU 使用率产生深远的影响。所以，我们希望减少 App 的内存使用量，可以用一种称为向下采样(downsampling)的技术来实现这一目标。</p><p><img src="https://github.com/JoakimLiu/BlogPhoto/blob/master/wwdc/2018/219/downsampling.png?raw=true" alt="downsampling"></p><p>我们要显示图像的图像视图实际上比要显示的图像小。 Core animation 在渲染阶段将负责缩小该图像，但我们可以节省一些内存（因为我们将有一个较小的图像缓冲区）。就是上图所示的 Thumbnail 处理。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">downsample</span><span class="params">(imageAt imageURL: URL, to pointSize: CGSize, scale: CGFloat)</span></span> -&gt; <span class="type">UIImage</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> imageSourceOptions <span class="operator">=</span> [kCGImageSourceShouldCache: <span class="literal">false</span>] <span class="keyword">as</span> <span class="type">CFDictionary</span></span><br><span class="line">    <span class="keyword">let</span> imageSource <span class="operator">=</span> <span class="type">CGImageSourceCreateWithURL</span>(imageURL <span class="keyword">as</span> <span class="type">CFURL</span>, imageSourceOptions)<span class="operator">!</span></span><br><span class="line">    <span class="keyword">let</span> maxDimensionInPixels <span class="operator">=</span> <span class="built_in">max</span>(pointSize.width, pointSize.height) <span class="operator">*</span> scale</span><br><span class="line">    <span class="keyword">let</span> downsampleOptions <span class="operator">=</span></span><br><span class="line">    [kCGImageSourceCreateThumbnailFromImageAlways: <span class="literal">true</span>,</span><br><span class="line">             kCGImageSourceShouldCacheImmediately: <span class="literal">true</span>,</span><br><span class="line">       kCGImageSourceCreateThumbnailWithTransform: <span class="literal">true</span>,</span><br><span class="line">              kCGImageSourceThumbnailMaxPixelSize: maxDimensionInPixels] <span class="keyword">as</span> <span class="type">CFDictionary</span></span><br><span class="line">    <span class="keyword">let</span> downsampledImage <span class="operator">=</span></span><br><span class="line">    <span class="type">CGImageSourceCreateThumbnailAtIndex</span>(imageSource, <span class="number">0</span>, downsampleOptions)<span class="operator">!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">UIImage</span>(cgImage: downsampledImage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>kCGImageSourceShouldCache = false</code> 这就告诉了 Core Graphics ，我们只是在创建一个对象，来表示存储在该 URL 的文件中的信息。不要立即解码这个图像，只需创建一个表示它的对象，我们将需要来自此 URL 中的信息。<br><code>kCGImageSourceShouldCacheImmediately = true</code> 告诉 Core Graphics ，当我要求你创建缩略图时，这就是你应该为我创建解码图像缓冲区的确切时刻，因此，我们可以确切的控制何时调用 CPU 来进行解码。</p><p><img src="https://github.com/JoakimLiu/BlogPhoto/blob/master/wwdc/2018/219/decoding-in-scrollable-views.png?raw=true" alt="Decodin in Scrollable Views"></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="keyword">_</span> collectionView: UICollectionView, cellForItemAt indexPath: IndexPath)</span></span></span><br><span class="line">-&gt; <span class="type">UICollectionViewCell</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> cell <span class="operator">=</span> collectionView.dequeueReusableCell(withReuseIdentifier: <span class="string">&quot;Cell&quot;</span>,</span><br><span class="line">                                                  <span class="keyword">for</span>: indexPath) <span class="keyword">as!</span> <span class="type">MyCollectionViewCell</span></span><br><span class="line">    cell.layoutIfNeeded() <span class="comment">// Ensure imageView is its final size.</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> imageViewSize <span class="operator">=</span> cell.imageView.bounds.size</span><br><span class="line">    <span class="keyword">let</span> scale <span class="operator">=</span> collectionView.traitCollection.displayScale</span><br><span class="line">    cell.imageView.image <span class="operator">=</span> downsample(imageAt: imageURLs[indexPath.item],</span><br><span class="line">                                      to: imageViewSize, scale: scale)</span><br><span class="line">    <span class="keyword">return</span> cell</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上图和上述代码所示，在列表滚动的时候进行解码，当我们滚动页面时， CPU 相对比较空闲，或者它所做的工作可以在显示硬件需要帧缓冲区的下一个副本之前完成。所以当帧缓冲区被更新时，我们能够看到流动的效果，并且显示硬件能够及时获取到新帧。     当我们滑动的时候，即将显示另一行图像，在将单元格交回给 UICollectionView 之前，我们要求 Core Graphics 解码这些图像。这将会使用大量的 CPU 时间，以至于我们不得不重新渲染帧缓冲区，但显示器硬件按固定的时间间隔运行（下一帧获取的时候，还没渲染好）。因此，从用户的角度来看 App 好像卡住(stuttered)了一样，影响很慢，并且对电池寿命也有影响。 </p><p>我们可以使用两种技术来平滑我们的 CPU 使用率。</p><ul><li>Prefetching: 基本思想是它允许 CollectionView 告知我们的数据源，它当前不需要一个单元格，但它在不久的将来需要。所以，如果你有任何工作要做，也许现在就可以提前开始，这允许我们<strong>随时间推移分摊 CPU 使用率，因此我们减少了 CPU 使用的峰值大小</strong>。</li><li>Background: 既然随着时间分散了工作量，我们也可以将这些工作分散到可用的 CPU 上，代码如下。</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="keyword">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                    prefetchItemsAt indexPaths: [IndexPath])</span></span> &#123;</span><br><span class="line">    <span class="comment">// Asynchronously decode and downsample every image we are about to show</span></span><br><span class="line">    <span class="keyword">for</span> indexPath <span class="keyword">in</span> indexPaths &#123;</span><br><span class="line">        <span class="type">DispatchQueue</span>.global(qos: .userInitiated).async &#123;</span><br><span class="line">            <span class="keyword">let</span> downsampledImage <span class="operator">=</span> downsample(images[indexPath.row])</span><br><span class="line">            <span class="type">DispatchQueue</span>.main.async &#123; <span class="keyword">self</span>.update(at: indexPath, with: downsampledImage) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码会有一个问题，<strong>线程爆炸</strong>。当我们要求系统去做比 CPU 能够做的工作 更多的工作时就会发生这种情况。如果我们要显示一定数量的图像，比如同时显示 6 张或者 8 张图片，但是我们在只有两个 CPU 的设备上运行，我们不能一次完成所有的工作，因为我们无法在不存在的 CPU 上进行并行处理。 避免向一个全局队列中异步的分配任务时发生死锁， GCD 将创建新线程来捕捉我们要求它所做的工作，然后 CPU 将花费大量时间在这些线程之间进行切换，尝试在所有工作上取得 我们要求操作系统为我们做的 渐进式进展。来回切换，实际上是相当大的开销（要减少）。如果一个或者多个 CPU 有机会能一次处理完图片，效果会更好。 所以，我们现在创建串行队列，异步将工作分派给该队列。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> serialQueue <span class="operator">=</span> <span class="type">DispatchQueue</span>(label: <span class="string">&quot;Decode queue&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="keyword">_</span> collectionView: UICollectionView,</span></span></span><br><span class="line"><span class="function"><span class="params">                    prefetchItemsAt indexPaths: [IndexPath])</span></span> &#123;</span><br><span class="line">    <span class="comment">// Asynchronously decode and downsample every image we are about to show</span></span><br><span class="line">    <span class="keyword">for</span> indexPath <span class="keyword">in</span> indexPaths &#123;</span><br><span class="line">        serialQueue.async &#123;</span><br><span class="line">            <span class="keyword">let</span> downsampledImage <span class="operator">=</span> downsample(images[indexPath.row])</span><br><span class="line">            <span class="type">DispatchQueue</span>.main.async &#123; <span class="keyword">self</span>.update(at: indexPath, with: downsampledImage) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/JoakimLiu/BlogPhoto/blob/master/wwdc/2018/219/image-sources.png?raw=true" alt="Image Sources"><br>图片来源有很多种，如下图所示，但是推荐用 <code>Image assets</code> ，有以下优点</p><ul><li>Optimized name- and trait-based lookup</li><li>Smarter buffer caching</li><li>Per-device thinning</li><li>Vector artwork</li></ul><h3 id="Vector-Artwork"><a href="#Vector-Artwork" class="headerlink" title="Vector Artwork"></a>Vector Artwork</h3><p>从 iOS 11 开始， <code>image assets</code> 支持保存向量数据(Vecotr Data)，它能在绘制比他本身大小不相等的情况下，避免模糊和抗锯齿。 向量数据的工作方式与我们之前看到的管道非常相似(看下图)，只是这里不是一个解码阶段，而是一个栅格化(rasterize)阶段，它负责获取矢量数据，并将其转换为可复制到帧缓冲区的位图数据。 </p><p><img src="https://github.com/JoakimLiu/BlogPhoto/blob/master/wwdc/2018/219/vector-artwork-pipeline.png?raw=true" alt="Vector Artwork Pipeline"></p><p>如果需要不同尺寸时，建议在 <code>image assets</code> 中放置不同尺寸的矢量数据，如果不这样处理的处理的话，会消耗更多的 CPU 资源。</p><h1 id="Custom-drawing-with-UIKit"><a href="#Custom-drawing-with-UIKit" class="headerlink" title="Custom drawing with UIKit"></a>Custom drawing with UIKit</h1><p>不建议重写 <code>draw</code> 方法来实现自定义视图，因为会造成额外的内存开销。先看两者的绘制过程，如下图所示</p><p><img src="https://github.com/JoakimLiu/BlogPhoto/blob/master/wwdc/2018/219/drawing.png?raw=true" alt="Custom Drawing Versus UIImageView"></p><p>每个视图实际上都是依赖 Core animation 运行时的 CALayer 实现的，真正渲染的是 CALayer ，我们可以将渲染好的位图赋值给它的 contents 属性。</p><p>对于我们的 UIImageView 创建时，要求<strong>图像创建解码图像缓冲区</strong>，然后，将解码后的图像交给 CALayer ，用作其所在图层上内容。<br>对于我们重写 <code>draw</code> 得到的自定义视图，它们的过程很相似，但略有不同。 layer 负责创建 <code>Backing Store</code> (即连接到 CALayer 的图像缓冲区)，来保存我们 draw 方法的内容， view 执行 draw 函数并填充该图像缓冲区的内容，这些内容接着根据显示硬件的需要，被复制到帧缓冲区中。</p><p>开销大原因是， 我们这里使用的 <code>Backing Store</code> ，其大小与我们正在显示的<strong>视图大小成正比</strong>， 计算方法是<code>view.size*view.contentsScale</code>。</p><p>我们在 iOS12 中引入了一项新功能和优化，即 Backing Store 中元素的大小，实际上会动态增长，取决于你是否绘制任何有颜色的内容，以及该颜色的内容是否在标准色彩范围之内或之外。因此如果你使用扩展的 SRGB 颜色绘制广色域内容(wide color content)， Backing Store 实际上会比 仅适用 0-1 范围内的颜色的 Backing Store 大。在之前的 iOS 版本中，你可以通过设置 CALayer 的内容格式属性(contents format property)来作为对 Core Animation 的一个提示，即“我知道我需要(或者不需要)在这个视图中支持广色域内容”。如果你这样做，实际将将会禁用 iOS12 中引入的优化。所以，得检查 layerWillDraw 的实现。但我们可以做的比仅仅<strong>提示</strong>除了是否需要一个支持广色域的 Backing Store <strong>更好</strong>，我们实际上可以<strong>减少</strong> App 所需的 Backing Store 总量。</p><h2 id="Reducing-Backing-Store-Use"><a href="#Reducing-Backing-Store-Use" class="headerlink" title="Reducing Backing Store Use"></a>Reducing Backing Store Use</h2><p>减少 Backing Store 使用的方法有以下几个：</p><ul><li>Refactor larger views into subview hierarchies </li><li>Reduce or eliminate overrides of draw(_:) </li><li>Eliminate duplicate copies of image data</li><li>Use optimized view properties and subclasses</li></ul><p>说第一条和第二条减少了 Backing Store 的总量，可以帮助我们实现第三和第四条。</p><h3 id="Alternatives-to-custom-drawing"><a href="#Alternatives-to-custom-drawing" class="headerlink" title="Alternatives to custom drawing"></a>Alternatives to custom drawing</h3><ul><li>Overriding draw(_:) opts into backing store</li><li>UIView.backgroundColor can render directly to frame buffer without a backing store<ul><li>…except for pattern colors</li><li>Use UIImageView with tiling image instead</li></ul></li></ul><p>第一条，因为重写 draw 方法将需要创建一个 Backing Store 以与 CALayer 一起使用。但是 View 的一些属性，即使你不重写 draw 方法，仍然可以工作，比如 backgroundColor ，除了 pattern color 。所以，建议不要在 UIView 中使用 pattern color 作为 backgroundColor 。相反，用 UIImageView with tiling image 替代。</p><h3 id="Masking-versus-corner-radius"><a href="#Masking-versus-corner-radius" class="headerlink" title="Masking versus corner radius"></a>Masking versus corner radius</h3><ul><li>UIView.maskView and CALayer.maskLayer render view hierarchy into temporary image buffer</li><li>CALayer.cornerRadius does not require any image buffer</li><li>Consider UIImageView with resizable image instead of masking for transparent backgrounds</li></ul><p>corner 建议用 CALayer.cornerRadius 。因为 Core Animation 能够渲染圆角，而不需要额外的内存分配。用 maskView 或者 maskLayer ，需要额外分配内存来存储它们。 如果有更加复杂透明区域的背景，不能用 cornerRadius 完成，应该考虑用 UIImageView ，将这些信息存储在 asset catalog 中或者运行时渲染它，然后作为图像提供给 UIImageView ，而不是用 maskView 或者 maskLayer 。</p><h3 id="Eliminating-duplicate-image-data"><a href="#Eliminating-duplicate-image-data" class="headerlink" title="Eliminating duplicate image data"></a>Eliminating duplicate image data</h3><ul><li>UIImageView can colorize monochrome images while rendering directly into frame buffer</li><li>UIImage.withRenderingMode(_:) or Rendering Mode popup in asset inspector</li><li>Set tintColor of image view to any solid color</li></ul><p>UIImageView 能够对单色图稿(monochrome artwork)着色，而不需要额外的内存分配。 在 asset 中设置渲染模式属性为 always template 或者代码 <code>UIImage.withRenderingMode</code> 方法实现。 然后将 Image 赋值给 UIImageView ，再设置 UIImageView 的 tintColor 为你想要的颜色。    在 UIImage 将图像渲染到帧缓冲区的过程中，它会在复制操作中使用纯色，而不需要持有一个有纯色图像的<strong>单独副本</strong>。</p><h3 id="UILabel-optimizations-for-rendering-text"><a href="#UILabel-optimizations-for-rendering-text" class="headerlink" title="UILabel optimizations for rendering text"></a>UILabel optimizations for rendering text</h3><ul><li>UILabel is optimized for monochrome strings </li><li>Uses 75% smaller backing store when possible</li><li>Automatically upgrades to larger backing store for multicolor strings, emoji</li></ul><p>推荐用 UILabel 。</p><h2 id="Drawing-Off-Screen"><a href="#Drawing-Off-Screen" class="headerlink" title="Drawing Off-Screen"></a>Drawing Off-Screen</h2><p>当我们为了离屏渲染，要创建 image buffer 时，我们通常会使用 <code>UIGraphicsBeginImageContext</code>，但是最好还是用 <code>UIGraphicsImageRenderer </code>，它的性能更好、更高效，并且支持广色域。自动支持广色域的方式跟前面说的 Vector Artwork 相似，这里有一个中间地带，如果你主要将图像渲染到图形图像渲染器(graphic image render)中，该图像可能使用超出 SRGB 色域的色彩空间值，但实际上<strong>并不需要更大</strong>的元素来存储这些信息。所以 UIImage 有一个可以用来获取预构建的 <code>UIGraphicsImageRendererFormat</code> 对象的 image renderer format 属性，该对象用于重新渲染图像时进行最优化存储。</p><h1 id="Advanced-CPU-and-GPU-techniques"><a href="#Advanced-CPU-and-GPU-techniques" class="headerlink" title="Advanced CPU and GPU techniques"></a>Advanced CPU and GPU techniques</h1><h2 id="Advanced-Image-Effects"><a href="#Advanced-Image-Effects" class="headerlink" title="Advanced Image Effects"></a>Advanced Image Effects</h2><p>图片效果推荐用 <code>Core Image</code> 。</p><ul><li>Consider Core Image for realtime effects</li><li>Executes on GPU, freeing up CPU</li><li>UIImageView renders CIImages efficiently UIImage.init(ciImage:)</li></ul><h2 id="Advanced-Image-Processing"><a href="#Advanced-Image-Processing" class="headerlink" title="Advanced Image Processing"></a>Advanced Image Processing</h2><ul><li>Use CVPixelBuffer to move data to frameworks like Metal, Vision, and Accelerate </li><li>Use the best initializer—don’t unwind work that’s already been done</li><li>Guard against moving work between GPU and CPU</li><li>Ensure buffers are correct format for Accelerate</li></ul><p>CVPixelBuffer 是 Metal Vision Accelerate 这些框架中常见的数据类型之一，它用来表示在 CPU 或 GPU 上正在使用或者尚未使用的 缓冲区。</p><p>不要展开任何解码操作，这些工作已经由现有的 UIImage 或者 CGImage 实现完成。</p><h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><ul><li>Implement prefetching to prepare asynchronously</li><li>Reduce backing store usage by using UIImageView and UILabel </li><li>Don’t accidentally disable new optimizations for custom drawing (这是 iOS12 引入的新特性)</li><li>Prefer image assets for bundled artwork</li><li>Avoid over-reliance on Preserve Vector Data (提供不同尺寸的矢量数据，而不要让一个矢量数据支撑多个尺寸)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对 &lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2018/219/&quot;&gt;Image and Graphics Best Practices&lt;/a&gt; 的一个学习记录文章，主要讲了图像加载的过程，要怎么优化内存和 CPU ，构建更流畅的应用程序。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="WWDC" scheme="http://example.com/tags/WWDC/"/>
    
  </entry>
  
  <entry>
    <title>Advanced Graphics and Animations for iOS Apps</title>
    <link href="http://example.com/2019/03/02/wwdc-2014-419/"/>
    <id>http://example.com/2019/03/02/wwdc-2014-419/</id>
    <published>2019-03-02T01:07:01.000Z</published>
    <updated>2021-05-20T15:11:03.590Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对 <a href="https://developer.apple.com/videos/play/wwdc2014/419/">Advanced Graphics and Animations for iOS Apps</a> 的一个学习记录文章，字幕在 <a href="https://asciiwwdc.com/2014/sessions/419">transcripts</a> ，当然也可以下载 <a href="https://wwdc.io/">WWDC</a> 在桌面上看带有字幕的视频。这篇挺实用的，讲解了渲染的基本流程，以及怎么发现并解决渲染性能的问题。(ps: 20中旬发现这个视频下架了，可以在 <a href="http://devstreaming.apple.com/videos/wwdc/2014/419xxli6f60a6bs/419/419_hd_advanced_graphics_and_animation_performance.mov?dl=1">419_hd_advanced_graphics_and_animation_performance.mov</a> 下载)。</p><a id="more"></a><h1 id="Core-Animation-Pipeline"><a href="#Core-Animation-Pipeline" class="headerlink" title="Core Animation Pipeline"></a>Core Animation Pipeline</h1><p>我们知道 Core Animation 是 iOS 上可用的图形渲染和动画基础结构，它将大部分实际绘图工作交给图形硬件以加速渲染(摘自官方文档<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004514">Core Animation Programming Guide</a>)。 我们先来看看 Core Animation 的管道图：</p><p><img src="https://github.com/JoakimLiu/BlogPhoto/blob/master/wwdc/2014/419/pipeline1.png?raw=true" alt="Animation Pipeline1"></p><p>我们看到在应用程序(Application)和渲染服务器(Render Server)中都有 Core Animation ，但是渲染工作并不是在应用程序里(尽管它有 Core Animation)完成的。它只是将视图层级(view hierarchy)打包(encode)提交给渲染服务器(一个单独的进程，也有 Core Animation)， 视图层级才会被渲染。(“The view hierarchy is then rendered with Core Animation with OpenGL or metal, that’s the GPU.”) 大致流程如下：</p><ul><li>Handle Events: 它代表 touch, 即一切要更新视图层级的事情；</li><li>Commit Transaction: 编码打包视图层级，发送给渲染服务器；</li><li>Decode: 渲染服务器第一件事就是解码这些视图层级；</li><li>Draw Calls: 渲染服务器必须等待下一次重新同步，以便等待缓冲区从 它们实现渲染的显示器 返回，然后最终开始为 GPU 绘制，这里就是 OpenGL or metal 。</li><li>Render: 一旦视图资源可用， GPU 就开始它的渲染工作，希望在下个重新同步完成，因为要交换缓冲区给用户。</li><li>Display: 显示给用户看。</li></ul><p>在上述情况下，这些不同的步骤总共跨越三帧。在最后一个步骤 display 后，是可以平行操作的，在 Draw call 的时候可以处理下一个 handler event 和 Commit Transaction 。如下图所示</p><p><img src="https://github.com/JoakimLiu/BlogPhoto/blob/master/wwdc/2014/419/pipeline2.png?raw=true" alt="Animation Pipeline2"></p><h2 id="Commit-Transaction"><a href="#Commit-Transaction" class="headerlink" title="Commit Transaction"></a>Commit Transaction</h2><p>先聚焦 Commit transaction 这个阶段，因为这是开发者接触最多的，主要有四个阶段，如下图所示</p><p><img src="https://github.com/JoakimLiu/BlogPhoto/blob/master/wwdc/2014/419/commit-transaction.png?raw=true" alt="Commit Transaction"></p><ul><li>Layout: Set up the views. (重载的 <code>layoutSubviews</code> 方法会在这个阶段被调用；视图的创建，被添加到视图层级上；计算内容，比如：字符串，用来布局 label ；这个阶段通常是 CPU 或者 I/O 限制，所以做的事情要轻量)</li><li>Display: Draw the views. (主要是 core graphics 用来绘制，调用重载的 <code>drawRect:</code> 方法来绘制，绘制字符串；这个阶段通常是 CPU 或者内存限制，所以减少 core graphics 的工作)</li><li>Prepare: Additional Core Animation work. (主要是图片解码和图片转换。所以，图片大小和格式都是被 GPU 支持的，不然转换是发生在 CPU 上的，最好是 index bitmap ，可以免去转换)</li><li>Commit: Package up the layers and send them to the render server. (视图层级不要太复杂，尽量扁平，因为这里的打包是循环处理的)</li></ul><h2 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h2><p>动画分为三个阶段，前面两个阶段在应用程序，最后一个在渲染服务器，如下图所示</p><p><img src="https://github.com/JoakimLiu/BlogPhoto/blob/master/wwdc/2014/419/animation-process.png?raw=true" alt="Animation Process"></p><p>跟<strong>视图的不同的</strong>是，这里提交的不是视图层级，而是动画。这是出于效率的原因，方便我们可以继续更新动画，因为如果提交视图层级的话，动画一更新，又得返回到应用程序提交新的视图层级，很耗时。</p><h1 id="Rendering-Concepts"><a href="#Rendering-Concepts" class="headerlink" title="Rendering Concepts"></a>Rendering Concepts</h1><p>来了解渲染的一些概念。</p><h2 id="Tile-Based-Rendering"><a href="#Tile-Based-Rendering" class="headerlink" title="Tile Based Rendering"></a>Tile Based Rendering</h2><p>“first tile based rendering is how all GPUs work.” 基于图块的渲染是 GPU 的工作方式。</p><p><img src="https://github.com/JoakimLiu/BlogPhoto/blob/master/wwdc/2014/419/tile-based-rendering.png?raw=true" alt="Tile Based Rendering"></p><ul><li>屏幕被分割成 N*N 个像素块，就像之前讲 <a href="http://joakimliu.github.io/2019/02/24/wwdc-2011-129/">Points vs Pixels</a> 中的例子一样；</li><li>每块都适应 Soc 缓存。(Soc: 苹果 A9 是一款由苹果公司设计的系统芯片(Soc)。可以理解为系统芯片。 维基百科上面写的，这个芯片是 2015.9.9 才首次发布)。</li><li>几何体被分割成瓷砖桶(tile buckets)，这一步发生在 tiler stage (后面有提到)。这里举了 iPhone icon 的例子，从上图中可以看到，这个 icon 被分割成多个很小的三角形，使得这些三角形块可以单独的渲染，分割这样做的思路可以决定哪一块显示，哪一块渲染。 因为每个像素只有一个像素着色器，所以混合的话还是有问题的，涉及到覆盖绘制。</li><li>几何体提交后，光栅化才开始。(所以光栅化能提升性能，因为几何体都提交了，下次渲染的时候就可以省略这一步。)</li></ul><h3 id="Rendering-pass"><a href="#Rendering-pass" class="headerlink" title="Rendering pass"></a>Rendering pass</h3><p><img src="https://github.com/JoakimLiu/BlogPhoto/blob/master/wwdc/2014/419/rendering-pass.png?raw=true" alt="Rendering pass"></p><p>如上图所示，我们假设视图层级已经被提交到渲染服务器，并且 Core Animation 已经解码它，现在需要用 OpenGL 或者 metal 去渲染了，文章讲师举例是用的 OpenGL (所以这里的 Slide 比前面讲 Core Animation Pipeline 的 Slide 在 Render Server 这一栏，多了 OpenGL 在里面)。具体流程如下：</p><ul><li>GPU 收到 Command Buffer ；</li><li>顶点着色器开始运行，思路就是先将所有的顶点转换到屏幕空间，然后平铺处理，平铺成**瓷砖桶(tile bucket)**的几何图形（这里分两步走，先顶点处理然后平铺，统称为 Tiler stage, 在 Instrument 的 OpenGL ES tiler utilization 能看到这一步。）这一步的产出被写入 Parameter Buffer, 下一阶段不会马上启动。相反，会等待，直到 a. 处理完所有的几何体，并且都位于 Parameter Buffer 中；或者 b. Parameter buffer 已满（满了的话，必须刷新它）。</li><li>像素着色器处理，这一步被称为 Renderer stage, 产出被写入 Render Buffer 。(在 Instrument 的 OpenGL ES renderer utilization 能看到这一步。)</li></ul><h3 id="Masking-Rendering-pass-Example"><a href="#Masking-Rendering-pass-Example" class="headerlink" title="Masking Rendering pass Example"></a>Masking Rendering pass Example</h3><p>举了一个渲染遮罩的例子，步骤如下图：</p><p><img src="https://github.com/JoakimLiu/BlogPhoto/blob/master/wwdc/2014/419/masking-rendering-pass.png?raw=true" alt="Masking Rendering Pass"></p><p>分三步走，两步渲染，一步合成。</p><ol><li>将遮罩层(相机 icon)渲染到纹理(texture)上；</li><li>将内容层渲染到纹理上；</li><li>将遮罩添加到内容纹理上。</li></ol><p>(texture: 材质贴图，又称纹理贴图，在计算机图形学中是把存储在内存里的位图包裹到 3D 渲染物体的表面。可以把它理解成图片。)</p><h1 id="UIBlurEffect"><a href="#UIBlurEffect" class="headerlink" title="UIBlurEffect"></a>UIBlurEffect</h1><p>UIBlurEffect 是 iOS8 新出的用来实现模糊效果的类。它的渲染过程如下：</p><p><img src="https://github.com/JoakimLiu/BlogPhoto/blob/master/wwdc/2014/419/blureffect-rendering-pass.png?raw=true" alt="UIBlurEffect Rendering Pass"></p><p>再看下图，聚焦在一帧，</p><p><img src="https://github.com/JoakimLiu/BlogPhoto/blob/master/wwdc/2014/419/blureffect1.png?raw=true" alt="UIBlurEffect1"></p><p>我们可以看到有三行，每一行代表一个事件</p><ul><li>tile activity</li><li>render activity</li><li>VBlank interrupt, “and the last row I put in the VBlank interrupt and we can actually see what our frame boundaries are.”  (我们实际上可以看到我们的帧边界是什么)</li></ul><p>然后我们看看每个渲染步骤所需的时间，每个渲染步骤都牵扯到了上面所提到的事件(tile/render/VBlank interrupt)。</p><ol><li>content pass, 在这种情况下，它只是一个简单的图像，因此如果我们涉及 UI ，可能需要更长的时间；</li><li>downscale, 它实际上相当快。这几乎是不变的成本；</li><li>horizontal blur, 也非常快，因为是小区域。</li><li>vertical blur, 同上</li><li>upscale and tint the blur</li></ol><p>我们注意到下图，每个步骤之间的间隙，用橘色标记了</p><p><img src="https://github.com/JoakimLiu/BlogPhoto/blob/master/wwdc/2014/419/blureffect2.png?raw=true" alt="UIBlurEffect2"></p><p>5 个步骤中间有 4 个间隙，之所以存在，是因为这是发生在 GPU 上切换所花的时间。在空闲时间，每个步骤所花费的时间大概在 0.1<del>0.2ms, 所以总共 0.4</del>0.8ms, 所以这个是 16.67ms 的一个重要组成部分。</p><p>还列举了不同设备间的耗时，有一种设备某个 Dark style 下的时间是 18.15ms, 超过 16.67ms, 所以不可能在 60 hert 渲染完成。所以 Apple 在这些设备上不支持 blur 。 </p><p>UIBlurEffect 有三种 style: Extra light, Light, Dark ，它们消耗的资源各不相同， Dark 最少， Extra light 最多。</p><h1 id="UIVibrancyEffect"><a href="#UIVibrancyEffect" class="headerlink" title="UIVibrancyEffect"></a>UIVibrancyEffect</h1><p>UIVibrancyEffect 是在模糊之上使用的效果，它可以<strong>确保内容突出，而不会被模糊</strong>。它的渲染过程如下：<br><img src="https://github.com/JoakimLiu/BlogPhoto/blob/master/wwdc/2014/419/vibrancyeffect-rendering-pass.png?raw=true" alt="UIBlurEffect Rendering Pass"></p><p>比 UIBlurEffect 多了两个步骤，最后一个步骤 filter 是最昂贵的，所以作用区域越小越好，千万别作用到全屏上。<br><img src="https://github.com/JoakimLiu/BlogPhoto/blob/master/wwdc/2014/419/vibrancyeffect1.png?raw=true" alt="UIVibrancyEffect1"></p><p>所以也会比 UIBlurEffect 多两个间隙，所以总共 0.6~1.2ms.<br><img src="https://github.com/JoakimLiu/BlogPhoto/blob/master/wwdc/2014/419/vibrancyeffect2.png?raw=true" alt="UIVibrancyEffect2"></p><h1 id="Profiling-tools"><a href="#Profiling-tools" class="headerlink" title="Profiling tools"></a>Profiling tools</h1><p>性能调查要考虑以下点</p><p><img src="https://github.com/JoakimLiu/BlogPhoto/blob/master/wwdc/2014/419/performance-inverstigation-mindset.png?raw=true" alt="Performance Investigation Mindset"></p><ul><li>What is the frame rate? Goal is always 60 fps.  // 检查工具： Core Animation template / OpenGL ES driver template</li><li>CPU or GPU bound? Lower utilization is desired and saves battery.   (更少的 CPU 或者 GPU 利用率，让电池更持久。) // 检查工具： OpenGL ES driver template</li><li>Any unnecessary CPU rendering? GPU is desirable but know when CPU makes sense.   (得知道渲染什么和怎么渲染， <code>drawRect</code> 方法尽量少用，减少让 CPU 的工作，让 GPU 做更多的渲染。) // 检查工具： Core Animation template / OpenGL ES driver template</li><li>Too many offscreen passes? Fewer is better.   (前面说 UIBlurEffect 的时候有说到，橘色的间隙就是用在 GPU 切换时间，每个间隙大概 0.1~0.2ms 。 离屏渲染也会出现这样的情况，因为它必须进行切换，所以得减少。因为前面有提到，我们减少 CPU 或者 GPU 的使用时间。) // 检查工具： Core Animation template</li><li>Too much blending? less is better. (GPU 处理 blending 合成的时候，操作昂贵，消耗性能) // 检查工具： Core Animation template</li><li>Any strange image formats or sizes? Avoida on-the-fly conversions or resizing.  (会转给 CPU 去处理，增加 CPU 的负担) // 检查工具： Core Animation template</li><li>Any expensive views or effects?  Understand the cost of what is in use.   (避免昂贵的效果，例如 Blur 和 Vibrancy ，得去考量。) // 检查工具： Xcode view debugging</li><li>Anything unexpected in the view hierarchy?   Know the actual view hierarchy.   (添加和移除要匹配。) // 检查工具： Xcode view debugging</li></ul><h2 id="检查工具"><a href="#检查工具" class="headerlink" title="检查工具"></a>检查工具</h2><p>上面每个例子后面都有提到一个检测工具，这里来讲讲相应检测工具的作用。请注意一点，在开始挖掘代码以试图找出正在发生的事情之前，这总是一个很好的起点(<strong>先看大概发生什么问题，再深入研究代码</strong>)。</p><h3 id="Core-Animation-template"><a href="#Core-Animation-template" class="headerlink" title="Core Animation template"></a>Core Animation template</h3><ul><li>看 fps </li><li>color blended layers, green 表示不透明， red 代表需要去 blend 混合。 增加 GPU 的工作。 绿多红少，是理想中的状态。</li><li>color hit screens and misses red,  展示如何使用或滥用 CALayer’rasterize 属性，没命中缓存就是红色。第一次启动会有很多红色，因为必须在它被缓存之前渲染一次，后面就没有了，因为缓存了。</li><li>color copied images, 如果是 GPU 不支持的图片就会让 CPU 去转换(在 commit phase)，增加了 CPU 的工作。 显示为蓝绿色(cyan)就表示让 CPU 去转换，影响滚动体验。 所以 size and color/image format 最好提前在后台处理好，不要阻塞主线程。</li><li>color misaligned images, 黄色表示需要缩放，紫色表示像素没对齐。</li><li>color offscreen-rendered yellow, 黄色代表离屏渲染。 nav bar 和 tool bar 是黄色，因为这些图层的模糊实际上模糊了它背后的内容(前面 blur 有讲过)。</li><li>color OpenGL fast path blue, 蓝色是好事，由显示硬件去 blend ，这样就会减少 GPU 的工作。</li><li>flash updated regions,  正在更新的部分为黄色。 理想状况下，黄色区域越少越好。它意味着 CPU 和 GPU 的工作都减少了。</li></ul><h3 id="OpenGL-ES-driver-template"><a href="#OpenGL-ES-driver-template" class="headerlink" title="OpenGL ES driver template"></a>OpenGL ES driver template</h3><ul><li>device utilization,  which will show you how much the GPU is in use during the trace. (使用率越少越好，这里举例的是 30% vs 70%(心中的理想值))</li><li>render and tiler utilization,  correspond to the renderer and tiler phases.</li><li>CoreAnimationFramesPerSecond,  what the actual frame rate is that we’re seeing.</li></ul><h3 id="Time-Profiler-template"><a href="#Time-Profiler-template" class="headerlink" title="Time Profiler template"></a>Time Profiler template</h3><ul><li>看调用栈耗时，看 CPU 在干什么；</li></ul><h1 id="Case-studies"><a href="#Case-studies" class="headerlink" title="Case studies"></a>Case studies</h1><p>讲了两个例子(Fictitious Photo/Contacts Application)，在旧设备上性能较差，都是 offscreen render 导致的，并且还是项目中常用的设置阴影和设置圆角。要在不同的设备上测试，尽管新设备没问题，可能旧设备就有问题。</p><h2 id="Shadow"><a href="#Shadow" class="headerlink" title="Shadow"></a>Shadow</h2><p>一般情况下是用以下代码，但是不要用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CALayer *imageViewLayer &#x3D; cell.imageView.layer;</span><br><span class="line">imageViewLayer.shadowColor &#x3D; [UIColor blackColor].CGColor;</span><br><span class="line">imageViewLayer.shadowOpacity &#x3D; 1.0;</span><br><span class="line">imageViewLayer.shadowRadius &#x3D; 2.0;</span><br><span class="line">imageViewLayer.shadowOffset &#x3D; CGSizeMake(1.0, 1.0);</span><br></pre></td></tr></table></figure><p>请用更高效的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imageViewLayer.shadowPath &#x3D; CGPathCreateWithRect(imageRect, NULL);</span><br></pre></td></tr></table></figure><p>因为 Core Animation 必须知道阴影的形状和位置，所以它用 offscreen pass 去渲染内容，在查看刚刚渲染的 alpha channel 来找出阴影的位置。</p><h2 id="Round"><a href="#Round" class="headerlink" title="Round"></a>Round</h2><p>一般情况下是用以下代码，但是不要用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CALayer *imageViewLayer &#x3D; cell.imageView.layer;</span><br><span class="line">imageViewLayer.cornerRadius &#x3D; imageHeight &#x2F; 2.0;</span><br><span class="line">imageViewLayer.masksToBounds &#x3D; YES;</span><br></pre></td></tr></table></figure><p>下面的方式可能会更高效：</p><ul><li>不要在渲染的时候使用 mask ，提前生成圆头像</li><li>如果上面的方式做不到，可以在头像上面盖一个中间透明的视图，尽管增加 GPU blend 的工作，但是还是会比离屏渲染快，所以还是可行的。</li></ul><p>优化后设备利用率(Device Utilization)是 30% ，之前有 80%，但是没有达到 100% ，这是因为当有离屏渲染时，GPU 必须得有来回切换的空闲时间，所以知道尽管受到 GPU 的限制，由于 offscreen passes 的存在，利用率都达不到 100% 。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对 &lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2014/419/&quot;&gt;Advanced Graphics and Animations for iOS Apps&lt;/a&gt; 的一个学习记录文章，字幕在 &lt;a href=&quot;https://asciiwwdc.com/2014/sessions/419&quot;&gt;transcripts&lt;/a&gt; ，当然也可以下载 &lt;a href=&quot;https://wwdc.io/&quot;&gt;WWDC&lt;/a&gt; 在桌面上看带有字幕的视频。这篇挺实用的，讲解了渲染的基本流程，以及怎么发现并解决渲染性能的问题。(ps: 20中旬发现这个视频下架了，可以在 &lt;a href=&quot;http://devstreaming.apple.com/videos/wwdc/2014/419xxli6f60a6bs/419/419_hd_advanced_graphics_and_animation_performance.mov?dl=1&quot;&gt;419_hd_advanced_graphics_and_animation_performance.mov&lt;/a&gt; 下载)。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="WWDC" scheme="http://example.com/tags/WWDC/"/>
    
  </entry>
  
  <entry>
    <title>Drawing and Printing Guide for iOS</title>
    <link href="http://example.com/2019/03/01/Drawing-and-Printing-Guide-for-iOS/"/>
    <id>http://example.com/2019/03/01/Drawing-and-Printing-Guide-for-iOS/</id>
    <published>2019-03-01T15:44:14.000Z</published>
    <updated>2021-01-22T14:55:23.846Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对官方文档<a href="https://developer.apple.com/library/archive/documentation/2DDrawing/Conceptual/DrawingPrintingiOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40010156-CH1-SW1">Drawing and Printing Guide for iOS</a>的一个翻译学习记录。</p><a id="more"></a><h1 id="About-Drawing-and-Printing-in-iOS"><a href="#About-Drawing-and-Printing-in-iOS" class="headerlink" title="About Drawing and Printing in iOS"></a>About Drawing and Printing in iOS</h1><p>本文档覆盖三个相关的部分：</p><ul><li>绘制自定义 UI 视图。 (自定义 UI 视图允许绘制无法使用标准UI元素轻松绘制的内容。 例如，绘图程序可能会为用户的绘图使用自定义视图，或者街机游戏可能会使用自定义视图来绘制精灵。)</li><li>绘制到屏幕外的位图和 PDF 内容。 (Drawing into offscreen bitmap and PDF content. ) 无论您是打算稍后显示图像，将它们导出到文件，还是将图像打印到启用 AirPrint 的打印机，屏幕外绘图都可以在不中断用户工作流程的情况下执行此操作。</li><li>为应用添加 AirPrint 支持。</li></ul><h2 id="At-a-Glance"><a href="#At-a-Glance" class="headerlink" title="At a Glance"></a>At a Glance</h2><p>iOS 原生图形系统结合了三种主要技术：UIKit ，Core Graphics 和 Core Animation 。 UIKit 在这些视图中提供视图和一些高级绘图功能， Core Graphics 在 UIKit 视图中提供额外的（低级）绘图支持， Core Animation 提供了将变换和动画应用于 UIKit 视图的功能。 Core Animation 还负责视图合成(view compositing)。</p><h3 id="Custom-UI-Views-Allow-Greater-Drawing-Flexibility"><a href="#Custom-UI-Views-Allow-Greater-Drawing-Flexibility" class="headerlink" title="Custom UI Views Allow Greater Drawing Flexibility"></a>Custom UI Views Allow Greater Drawing Flexibility</h3><p>本文档介绍如何使用原生绘图技术绘制自定义 UI 视图。 这些技术包括 Core Graphics 和 UIKit 框架，支持 2D 绘图。 </p><p>在考虑使用自定义 U I视图之前，应确保确实需要这样做。 原生绘图适用于处理更复杂的2D布局需求。 但是，由于自定义视图是处理器密集型(processor-intensive)的，因此应<strong>限制使用</strong>原生绘图技术执行的绘制量。</p><p>作为自定义绘图的替代方案，iOS应用程序可以通过其他几种方式在屏幕上绘制内容。</p><ul><li>Using standard (built-in) views. </li><li>Using Core Animation layers.</li><li>Using OpenGL ES in a GLKit view or a custom view.  </li><li>Using web content. </li></ul><p>根据创建的应用程序类型，可能会使用<strong>很少或不使用</strong>自定义绘图代码。 虽然沉浸式(immersive apps)应用程序通常广泛使用自定义绘图代码，但实用程序和生产力应用程序(utility and productivity apps)通常可以使用标准视图和控件来显示其内容。</p><p>分情况来选择是否用自定义视图，尤其是那些需要<strong>动态实时改变</strong>的，则用自定义视图，例如：绘图应用，街机风格的游戏等，它们都是需要实时不断更新屏幕的。</p><p>因为自定义视图通常是<strong>处理器密集型的（GPU的帮助较少）</strong>，如果可以使用标准视图执行所需操作，则应始终这样做。 此外，应该使自定义视图尽可能小，仅包含无法以任何其他方式绘制的内容，使用标准视图用于其他所有内容。 如果需要将标准 UI 元素与自定义绘图<strong>结合</strong>使用，请考虑使用 Core Animation 图层将自定义视图与标准视图叠加，以便<strong>尽可能少地</strong>绘制。(ps: 尽量减少自定义绘制，减轻 CPU 的工作)</p><h4 id="A-Few-Key-Concepts-Underpin-Drawing-With-the-Native-Technologies"><a href="#A-Few-Key-Concepts-Underpin-Drawing-With-the-Native-Technologies" class="headerlink" title="A Few Key Concepts Underpin Drawing With the Native Technologies"></a>A Few Key Concepts Underpin Drawing With the Native Technologies</h4><p>使用 UIKit 和 Core Graphics 绘制内容时，除了<strong>视图绘制周期外</strong>，还应该熟悉一些以下概念：</p><ul><li>对于 <strong>drawRect:</strong> 方法， UIKit 创建用于渲染到显示的图形上下文(graphics context)。 此图形上下文包含绘图系统执行绘图命令所需的信息，包括填充和描边颜色，字体，剪切区域和线宽等属性。 还可以为位图图像和 PDF 内容创建和绘制自定义图形上下文。</li><li>UIKit有一个默认坐标系(<strong>default coordinate system</strong>)，它绘图的原点位于视图的左上角; 正值向下延伸到该原点的右侧。 可以通过<strong>修改当前变换矩阵</strong>(the current transformation matrix)来更改默认坐标系相对于基础视图或窗口的大小，方向和位置，该矩阵将视图的坐标空间<strong>映射到</strong>设备屏幕。</li><li>在 iOS 中，测量点中距离的逻辑坐标空间(<strong>logical coordinate space</strong>)不等于以像素为单位测量的<strong>设备坐标空间</strong>(device coordinate space)。 为了获得更高的精度，点以浮点值表示。</li></ul><h4 id="UIKit-Core-Graphics-and-Core-Animation-Give-Your-App-Many-Tools-For-Drawing"><a href="#UIKit-Core-Graphics-and-Core-Animation-Give-Your-App-Many-Tools-For-Drawing" class="headerlink" title="UIKit, Core Graphics, and Core Animation Give Your App Many Tools For Drawing"></a>UIKit, Core Graphics, and Core Animation Give Your App Many Tools For Drawing</h4><p>UIKit 和 Core Graphics 具有许多<strong>互补</strong>的图形功能，包括图形上下文，贝塞尔曲线路径，图像，位图，透明层，颜色，字体， PDF 内容以及绘图矩形和剪切区域。 此外， Core Graphics 具有与线属性，颜色空间，图案颜色，渐变，阴影和图像蒙版相关的功能。 Core Animation 框架则可以通过操纵和显示使用其他技术创建的内容来创建流畅的动画。</p><h3 id="Apps-Can-Draw-Into-Offscreen-Bitmaps-or-PDFs"><a href="#Apps-Can-Draw-Into-Offscreen-Bitmaps-or-PDFs" class="headerlink" title="Apps Can Draw Into Offscreen Bitmaps or PDFs"></a>Apps Can Draw Into Offscreen Bitmaps or PDFs</h3><p>应用程序在离屏绘制内容通常很有用：</p><ul><li>在缩小照片以进行上传，将内容渲染到图像文件以用于存储目的时，或者使用 Core Graphics 生成用于显示的复杂图像时，通常使用屏幕外位图上下文。(ps: 用于存储)</li><li>在绘制用户生成的内容以进行打印时，通常会使用屏外 PDF 上下文。</li></ul><p>创建离屏上下文后，可以像在自定义视图的 drawRect: 方法中绘制一样绘制它。</p><h3 id="Apps-Have-a-Range-of-Options-for-Printing-Content"><a href="#Apps-Have-a-Range-of-Options-for-Printing-Content" class="headerlink" title="Apps Have a Range of Options for Printing Content"></a>Apps Have a Range of Options for Printing Content</h3><p>iOS 4.2 后支持的。</p><h3 id="It’s-Easy-to-Update-Your-App-for-High-Resolution-Screens"><a href="#It’s-Easy-to-Update-Your-App-for-High-Resolution-Screens" class="headerlink" title="It’s Easy to Update Your App for High-Resolution Screens"></a>It’s Easy to Update Your App for High-Resolution Screens</h3><p>某些 iOS 设备具有高分辨率屏幕，因此应用必须准备好在这些设备和具有较低分辨率屏幕的设备上运行。 iOS 处理不同分辨率所需的大部分工作，但应用必须完成<strong>其余的</strong>工作。 这些任务<strong>包括提供</strong>特别命名的高分辨率图像，并修改与图层和图像相关的代码，以考虑当前的比例因子(scale factor)。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>打印的完整例子，可以看以下源码</p><ul><li><a href="https://developer.apple.com/library/archive/samplecode/PrintPhoto/Introduction/Intro.html#//apple_ref/doc/uid/DTS40010366">PrintPhoto</a> </li><li><a href="https://developer.apple.com/library/archive/samplecode/Recipes_+_Printing/Introduction/Intro.html#//apple_ref/doc/uid/DTS40011098">Sample Print Page Renderer</a> </li><li><a href="https://developer.apple.com/library/archive/samplecode/PrintWebView/Introduction/Intro.html#//apple_ref/doc/uid/DTS40010311">UIKit Printing with UIPrintInteractionController and UIViewPrintFormatter</a></li></ul><h1 id="iOS-Drawing-Concepts"><a href="#iOS-Drawing-Concepts" class="headerlink" title="iOS Drawing Concepts"></a>iOS Drawing Concepts</h1><p>高质量的图形是应用程序用户界面的重要组成部分。 提供高质量的图形不仅使应用程序看起来很好，而且还使应用程序看起来像是系统其余部分的自然扩展。 iOS提供了两种在系统中创建高质量图形的主要途径：OpenGL 和使用 Quartz ，Core Animation 和 UIKit 的原生渲染。 本文档描述了原生渲染。 （要了解OpenGL绘图，请参阅<a href="https://developer.apple.com/library/archive/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008793">OpenGL ES Programming Guide</a>。）</p><p>Quartz 是主要的绘图界面，支持基于路径的绘制，消除锯齿渲染，渐变填充图案，图像，颜色，坐标空间转换以及 PDF 文档创建，显示和解析。 UIKit 为线条艺术，为 Quartz 图像和颜色处理提供 Objective-C 包装。 Core Animation 为许多 UIKit 视图属性中的更改动画提供了底层支持，还可用于实现自定义动画。</p><p>本章概述了 iOS 应用程序的绘图过程，以及每种支持的绘图技术的特定绘图技术。 还可以找到有关如何针对 iOS 平台优化绘图代码的提示和指导。</p><p>要点：<strong>并非所有UIKit类都是线程安全的</strong>。 在应用程序主线程以外的线程上执行与绘图相关的操作之前，请务必查看文档。</p><h2 id="The-UIKit-Graphics-System"><a href="#The-UIKit-Graphics-System" class="headerlink" title="The UIKit Graphics System"></a>The UIKit Graphics System</h2><p>在 iOS 中，无论是否涉及 OpenGL Quartz UIKit 或 Core Animation ，<strong>所有绘制到屏幕的内容都发生在   UIView 类的实例或其子类。 视图定义了发生绘图的屏幕部分</strong>。 如果使用系统提供的视图，则会自动处理此图形。 但是，如果定义自定义视图，则必须自己提供绘图代码。 如果使用 Quartz ， Core Animation 和 UIKit 进行绘制，则使用以下各节中描述的绘图概念。</p><p>除了直接绘制到屏幕外， UIKit 还允许绘制到屏幕外的位图和PDF图形上下文。 在非屏幕上下文中绘制时，没有在视图中绘制，这意味着<strong>视图绘制周期等概念不适用</strong>（除非获取该图像并在图像视图中绘制它或类似图像）。 (ps: 离屏幕渲染不会走绘制的流程。视图绘制就是屏幕上绘制)</p><h3 id="The-View-Drawing-Cycle"><a href="#The-View-Drawing-Cycle" class="headerlink" title="The View Drawing Cycle"></a>The View Drawing Cycle</h3><p>UIView 类的子类的基本绘图模型涉及<strong>按需更新内容</strong>。 UIView 类使更新过程更容易，更有效；不管怎样，<strong>通过收集你的更新请求，可以在最合适的时间将它们交付给绘图代码</strong>。</p><p>当<strong>视图首次显示或需要重绘视图的一部分</strong>时，iOS 会要求视图通过调用它的 <strong>drawRect:</strong> 方法来绘制其内容。<br>有几个操作可以触发视图更新：</p><ul><li>移动或删除部分遮挡视图的其他视图</li><li>通过将其 hidden 属性设置为 NO ，可以再次显示先前隐藏的视图</li><li>滚动到屏幕外的视图，然后返回到屏幕上</li><li>显式调用视图的 <code>setNeedsDisplay</code> 或 <code>setNeedsDisplayInRect:</code> 方法</li></ul><p>系统视图会自动重绘。 对于自定义视图，必须覆盖 <code>drawRect:</code> 方法并在其中执行所有绘制。 在 <code>drawRect:</code> 方法中，使用原生绘图技术绘制所需的形状，文本，图像，渐变或任何其他可视内容。 当自定义视图第一次显示时， iOS 会将一个矩形传递给视图的 <code>drawRect:</code> 方法，该方法包含<strong>视图的整个可见区域</strong>。 在后续调用期间，该矩形<strong>仅包含实际需要重绘的视图部分</strong>。 为获得<strong>最佳性能，应仅重绘受影响的内容</strong>。 (ps: 按需绘制)</p><p>调用 drawRect:方法后，视图将自身标记为<strong>已更新</strong>，并等待新操作到达并触发另一个更新周期。 如果视图显示静态内容，那么您需要做的就是响应视图因滚动和其他视图的存在而导致的可见性变化。(ps: 还是按需绘制)</p><p>但是，如果要更改视图的内容，则必须告诉视图重绘其内容。 为此，调用 <code>setNeedsDisplay</code> 或 <code>setNeedsDisplayInRect:</code> 方法以触发更新。 例如，如果每秒多次更新内容，则可能需要设置计时器以更新视图。 还可以更新视图以响应用户交互或在视图中创建新内容。</p><p>要点：不要自己调用视图的 <code>drawRect:</code> 方法。 <strong>只有在屏幕重绘期间内</strong>置于 iOS 中的代码才能调用该方法。 在其他时候，<strong>不存在图形上下文，因此无法绘图</strong>。 （图形上下文将在下一节中介绍。）</p><h3 id="Coordinate-Systems-and-Drawing-in-iOS"><a href="#Coordinate-Systems-and-Drawing-in-iOS" class="headerlink" title="Coordinate Systems and Drawing in iOS"></a>Coordinate Systems and Drawing in iOS</h3><p>当应用程序在iOS中绘制内容时，它必须在由坐标系定义的二维空间中定位绘制的内容。 这个概念乍一看似乎很简单，但事实并非如此。 iOS 中的应用有时必须在绘制时处理不同的坐标系。</p><p>在 iOS 中，所有绘图都在图形上下文中进行。 <strong>从概念上讲，图形上下文是</strong>描述绘图应在何处以及如何发生的对象，包括基本绘图属性，例如绘制时使用的颜色，剪切区域，线宽和样式信息，字体信息，合成选项等。</p><p>如下面这张图所示，每个图形上下文都有一个坐标系。 更确切地说，每个图形上下文都有三个坐标系：</p><ul><li>绘图（用户）坐标系(The drawing (user) coordinate system.)。 发出绘图命令时使用此坐标系。</li><li>视图坐标系（基本空间）(The view coordinate system (base space).)。 该坐标系是相对于视图的固定坐标系。</li><li>（物理）设备坐标系 (The (physical) device coordinate system.)。 该坐标系表示物理屏幕上的像素。</li></ul><p><img src="https://developer.apple.com/library/archive/documentation/2DDrawing/Conceptual/DrawingPrintingiOS/Art/coordinate_differences_2x.png" alt="The relationship between drawing coordinates, view coordinates, and hardware coordinates"></p><p>iOS 的绘图框架创建图形上下文，用于绘制到特定目的地，例如：屏幕，位图，PDF 内容等，并且这些图形上下文为该目标建立初始绘图坐标系。 此初始绘图坐标系称为默认坐标系(<strong>default coordinate system</strong>)，是视图底层坐标系上的 1:1 映射。</p><p>每个视图还具有当前变换矩阵（CTM），这是一种将当前绘图坐标系中的点映射到（固定）视图坐标系的数学矩阵。 应用程序可以修改此矩阵（如稍后所述）以更改将来绘制操作的行为。</p><p>iOS 的每个绘图框架都<strong>基于当前图形上下文建立默认坐标系</strong>。 在iOS中，有两种主要类型的坐标系：</p><ul><li>An upper-left-origin coordinate system (ULO). UIKit and Core Animation frameworks</li><li>A lower-left-origin coordinate system (LLO). Core Graphics</li></ul><p><img src="https://developer.apple.com/library/archive/documentation/2DDrawing/Conceptual/DrawingPrintingiOS/Art/flipped_coordinates-2_2x.png" alt="coordinate systems"></p><p>注意：OS X中的默认坐标系是基于 LLO 的。 尽管 Core Graphics 和 AppKit 框架的绘图功能和方法非常适合此默认坐标系，但 AppKit 提供了编程支持，可以将绘图坐标系翻转为左上角原点。</p><p>在调用视图的 drawRect: 方法之前， UIKit 通过为绘图操作提供图形上下文来建立绘制到屏幕的默认坐标系。 在视图的 drawRect: 方法中，应用程序可以设置图形状态参数（例如填充颜色）并绘制到当前图形上下文，而无需显式引用图形上下文。 此隐式图形上下文建立 ULO 默认坐标系。</p><h3 id="Points-Versus-Pixels"><a href="#Points-Versus-Pixels" class="headerlink" title="Points Versus Pixels"></a>Points Versus Pixels</h3><p>具体的看 <a href="http://joakimliu.github.io/2019/02/24/wwdc-2011-129/">http://joakimliu.github.io/2019/02/24/wwdc-2011-129/</a> 里面有讲到。</p><h3 id="Obtaining-Graphics-Contexts"><a href="#Obtaining-Graphics-Contexts" class="headerlink" title="Obtaining Graphics Contexts"></a>Obtaining Graphics Contexts</h3><p>大多数情况下，图形上下文<strong>已经为你配置好了</strong>。 每个视图对象都会自动创建一个图形上下文，以便代码可以在调用自定义 drawRect: 方法后立即开始绘制。 作为此配置的一部分，底层 UIView 类为当前绘图环境创建图形上下文（CGContextRef opaque类型）。</p><p>如果要绘制视图以外的其他位置（例如，捕获PDF或位图文件中的一系列绘图操作），或者需要调用需要上下文对象的 Core Graphics 函数，则必须执行其他步骤，获取图形上下文对象。 以下部分解释了如何。</p><p>有关图形上下文，修改图形状态信息以及使用图形上下文创建自定义内容的更多信息，请参阅<a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Introduction/Introduction.html#//apple_ref/doc/uid/TP30001066">Quartz 2D Programming Guide</a>。 有关与图形上下文结合使用的函数列表，请参阅 CGContext Reference ， CGBitmapContext Reference 和 CGPDFContext Reference 。</p><h4 id="Drawing-to-the-Screen"><a href="#Drawing-to-the-Screen" class="headerlink" title="Drawing to the Screen"></a>Drawing to the Screen</h4><p>如果使用 Core Graphics 函数绘制视图，无论是在 drawRect: 方法还是其他地方，都需要一个图形上下文来绘制。 （许多这些函数的第一个参数必须是CGContextRef对象。）可以调用函数 UIGraphicsGetCurrentContext 来获取在 drawRect 中隐含的相同图形上下文的显式版本。 因为它是相同的图形上下文，所以绘图函数也应该引用ULO默认坐标系。</p><p>如果要使用 Core Graphics 函数在 UIKit 视图中绘制，则应使用 UIKit 的 ULO 坐标系进行绘图操作。 或者，可以将翻转变换(flip transform)应用于 CTM ，然后使用 Core Graphics 原生 LLO 坐标系在 UIKit 视图中绘制对象。 “#Flipping the Default Coordinate System#”详细讨论了翻转变换。</p><p><strong>UIGraphicsGetCurrentContext 函数始终返回当前有效的图形上下文</strong>。 例如，如果创建PDF上下文然后调用UIGraphicsGetCurrentContext ，将收到该 PDF 上下文。 如果使用 Core Graphics 函数绘制视图，<strong>则必须使用</strong> <code>UIGraphicsGetCurrentContext</code> 返回的图形上下文。</p><h4 id="Drawing-to-Bitmap-Contexts-and-PDF-Contexts"><a href="#Drawing-to-Bitmap-Contexts-and-PDF-Contexts" class="headerlink" title="Drawing to Bitmap Contexts and PDF Contexts"></a>Drawing to Bitmap Contexts and PDF Contexts</h4><p>UIKit 提供了在位图图形上下文中渲染图像的功能，以及通过绘制PDF图形上下文来生成PDF内容的功能。 这两种方法都要求您首先分别调用创建图形上下文的函数 - 位图上下文或PDF上下文。 返回的对象充当后续绘图和状态设置调用的当前（和隐式）图形上下文。 在上下文中完成绘制后，可以调用另一个函数来关闭该上下文。</p><p>UIKit 提供的位图上下文和PDF上下文都建立了 ULO 默认坐标系。 Core Graphics 具有相应的功能，用于在位图图形上下文中进行渲染以及在PDF图形上下文中进行绘制。 但是，应用程序直接通过 Core Graphic s创建的上下文建立了 LLO 默认坐标系。</p><p>注意：在 iOS 中，建议使用 UIKit 函数绘制到位图上下文和 PDF 上下文。 但是，如果确实使用了 Core Graphics 替代方案并打算显示渲染结果，则必须调整代码以补偿默认坐标系中的差异。 有关详细信息，请参阅 “#Flipping the Default Coordinate System#”。</p><h3 id="Color-and-Color-Spaces"><a href="#Color-and-Color-Spaces" class="headerlink" title="Color and Color Spaces"></a>Color and Color Spaces</h3><p>iOS 支持 Quartz 提供的全系列颜色空间; 但是，大多数应用程序应该只需要 RGB 颜色空间。 <strong>由于iOS设计为在嵌入式硬件上运行并在屏幕上显示图形，因此 RGB 颜色空间是最合适的颜色空间</strong>。</p><p>UIColor 对象提供了使用 RGB ， HSB和灰度值指定颜色值的便捷方法。 以这种方式创建颜色时，您<strong>永远不需要指定颜色空间</strong>。 它由 UIColor 对象自动确定。</p><p>您还可以使用 Core Graphics 框架中的 <code>CGContextSetRGBStrokeColor</code> 和 <code>CGContextSetRGBFillColor</code> 函数来创建和设置颜色。 虽然 Core Graphics 框架包括支持使用其他颜色空间创建颜色，以及创建自定义颜色空间，但不建议在绘图代码中使用这些颜色。 您的绘图代码<strong>应始终使用 RGB 颜色</strong>。</p><h2 id="Drawing-with-Quartz-and-UIKit"><a href="#Drawing-with-Quartz-and-UIKit" class="headerlink" title="Drawing with Quartz and UIKit"></a>Drawing with Quartz and UIKit</h2><p>Quartz 是 iOS 中<strong>原生绘图技术的通用名称</strong>。 Core Graphics 框架是 Quartz 的核心，也是用于绘制内容的主要界面。 该框架提供了用于操作以下内容的数据类型和函数：</p><ul><li>Graphics contexts</li><li>Paths</li><li>Images and bitmaps</li><li>Transparency layers</li><li>Colors, pattern colors, and color spaces</li><li>Gradients and shadings</li><li>Fonts</li><li>PDF content</li></ul><p>UIKit 通过为图形相关操作提供一组集中的类来构建 Quartz 的基本功能。 UIKit 图形类并不是一套全面的绘图工具– Core Graphics 已经提供了这些工具。 <strong>相反，它们为其他 UIKit 类提供绘图支持</strong>。 UIKit 支持包括以下类和功能：</p><ul><li>UIImage, which implements an immutable class for displaying images</li><li>UIColor, which provides basic support for device colors</li><li>UIFont, which provides font information for classes that need it</li><li>UIScreen, which provides basic information about the screen</li><li>UIBezierPath, which enables your app to draw lines, arcs, ovals, and other shapes.</li><li>Functions for generating a JPEG or PNG representation of a UIImage object</li><li>Functions for drawing to a bitmap graphics context</li><li>Functions for generating PDF data by drawing to a PDF graphics context</li><li>Functions for drawing rectangles and clipping the drawing area</li><li>Functions for changing and getting the current graphics context</li></ul><h3 id="Configuring-the-Graphics-Context"><a href="#Configuring-the-Graphics-Context" class="headerlink" title="Configuring the Graphics Context"></a>Configuring the Graphics Context</h3><p>在调用 drawRect: 方法之前，视图对象会创建图形上下文并将其设置为当前上下文。 <strong>此上下文仅存在于 drawRect: 方法调用的生命周期中</strong>。 可以通过调用 <code>UIGraphicsGetCurrentContext</code> 函数来获取指向此图形上下文的指针。 此函数返回对 CGContextRef 类型的引用，将其传递给 Core Graphics 函数以修改当前图形状态。 下表列出了用于设置图形状态不同方面的主要功能。 有关函数的完整列表，请参阅<a href="https://developer.apple.com/documentation/coregraphics/cgcontextref?language=objc">CGContext Reference</a>。 该表还列出了 UIKit 存在的替代方案。</p><table><thead><tr><th>Graphics state</th><th>Core Graphics functions</th><th>UIKit alternative</th></tr></thead><tbody><tr><td>Current transformation matrix (CTM)</td><td><a href="https://developer.apple.com/documentation/coregraphics/1456228-cgcontextrotatectm">CGContextRotateCTM</a> CGContextScaleCTM CGContextTranslateCTM CGContextConcatCTM</td><td>None</td></tr><tr><td>Clipping area</td><td>CGContextClipToRect</td><td>UIRectClip function</td></tr><tr><td>Line: Width, join, cap, dash, miter limit</td><td>CGContextSetLineWidth CGContextSetLineJoin CGContextSetLineCap CGContextSetLineDash CGContextSetMiterLimit</td><td>None</td></tr><tr><td>Accuracy of curve estimation</td><td>CGContextSetFlatness</td><td>None</td></tr><tr><td>Anti-aliasing setting</td><td>CGContextSetAllowsAntialiasing</td><td>None</td></tr><tr><td>Color: Fill and stroke settings</td><td>CGContextSetRGBFillColor CGContextSetRGBStrokeColor</td><td>UIColor class</td></tr><tr><td>Alpha global value (transparency)</td><td>CGContextSetRenderingIntent</td><td>None</td></tr><tr><td>Rendering intent</td><td>CGContextSetRenderingIntent</td><td>None</td></tr><tr><td>Color space: Fill and stroke settings</td><td>CGContextSetFillColorSpace CGContextSetStrokeColorSpace</td><td>UIColor class</td></tr><tr><td>Text: Font, font size, character spacing, text drawing mode</td><td>CGContextSetFont CGContextSetFontSize CGContextSetCharacterSpacing</td><td>UIFont class</td></tr><tr><td>Blend mode</td><td>CGContextSetBlendMode</td><td>The UIImage class and various drawing functions let you specify which blend mode to use.</td></tr></tbody></table><p><strong>图形上下文包含已保存的图形状态的栈</strong>。 当 Quartz 创建图形上下文时，栈为空。 使用 <code>CGContextSaveGState</code> 函数将当前图形状态的副本推送到栈。 此后，对图形状态所做的修改会影响后续的绘图操作，但不会影响存储在栈中的副本。 完成修改后，可以使用 <code>CGContextRestoreGState</code> 函数将保存的状态弹出堆栈顶部，从而返回到先前的图形状态。 以这种方式推送(push)和弹出(pop)图形状态是<strong>返回先前状态的快速方法，并且无需单独撤消每个状态更改</strong>。 它也是将状态的某些方面（例如剪切路径）恢复到其原始设置的唯一方法。</p><h3 id="Creating-and-Drawing-Paths"><a href="#Creating-and-Drawing-Paths" class="headerlink" title="Creating and Drawing Paths"></a>Creating and Drawing Paths</h3><p><strong>路径是从一系列线和贝塞尔曲线创建的基于矢量的形状</strong>。 UIKit 包含 <code>UIRectFrame</code> 和 <code>UIRectFill</code> 函数（以及其他函数），用于在视图中绘制简单路径，例如矩形。 Core Graphics 还包括用于创建简单路径（如矩形和椭圆）的便捷功能。</p><p>对于更复杂的路径，必须使用 UIKit 的 UIBezierPath 类自己创建路径，或者使用在 Core Graphics 框架中对 CGPathRef opaque 类型进行操作的函数。 虽然可以使用任一API构建<strong>没有图形上下文的路径</strong>，但路径中的点仍然必须引用当前坐标系（具有ULO或LLO方向），并且仍需要图形上下文来实际呈现路径。</p><p>绘制路径时，必须设置当前上下文。 此上下文可以是自定义视图的上下文（在 <code>drawRect:</code>)中，位图上下文或 PDF 上下文。 坐标系确定路径的呈现方式。 UIBezierPath 假定 ULO 坐标系。 因此，如果您的视图被翻转（使用 LLO 坐标），则生成的形状可能会呈现与预期不同的形状。 <strong>为获得最佳结果，应始终指定相对于用于渲染的图形上下文的当前坐标系原点的点</strong>。</p><p>注意：即使遵循此“规则”，弧(Arc)是需要额外工作的路径的一个方面。 如果使用 Core Graphic 函数创建路径，该函数定位 ULO 坐标系中的点，然后在 UIKit 视图中渲染路径，则弧“指向”的方向不同。 有关此主题的更多信息，请参阅”#Side Effects of Drawing with Different Coordinate Systems#”。</p><p>要在iOS中创建路径，建议使用 UIBezierPath 而不是 CGPath 函数，除非需要一些仅 Core Graphics 提供的功能，例如向路径添加椭圆。 有关在 UIKit 中创建和渲染路径的更多信息，请参阅”#Drawing Shapes Using Bézier Paths#”。</p><h3 id="Creating-Patterns-Gradients-and-Shadings"><a href="#Creating-Patterns-Gradients-and-Shadings" class="headerlink" title="Creating Patterns, Gradients, and Shadings"></a>Creating Patterns, Gradients, and Shadings</h3><p>Core Graphics 框架包含用于创建模板(pattern)，渐变和阴影的附加功能。 您可以使用这些类型创建非单色颜色，并使用它们填充您创建的路径。 <strong>模板是根据重复的图像或内容创建的</strong>。 渐变和阴影提供了不同的方法来创建从颜色到颜色的平滑过渡。</p><p><a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Introduction/Introduction.html#//apple_ref/doc/uid/TP30001066">Quartz 2D Programming Guide</a> 中包含了创建和使用模式，渐变和阴影的详细信息。</p><h3 id="Customizing-the-Coordinate-Space"><a href="#Customizing-the-Coordinate-Space" class="headerlink" title="Customizing the Coordinate Space"></a>Customizing the Coordinate Space</h3><p>默认情况下， UIKit 创建一个直接的 CTM ，将点映射到像素上。 虽然可以在不修改该矩阵的情况下完成所有绘图，但有时这样做很方便。</p><p>首次调用视图的 drawRect: 方法时， CTM 已经配置好，使该坐标系（绘制）的原点与视图的原点匹配，正 X 轴向右延伸，正 Y 轴向下延伸。 但是，可以通过向其添加缩放，旋转和平移因子来更改 CTM ，从而更改默认坐标系相对于基础视图或窗口的大小，方向和位置。</p><h4 id="Using-Coordinate-Transforms-to-Improve-Drawing-Performance"><a href="#Using-Coordinate-Transforms-to-Improve-Drawing-Performance" class="headerlink" title="Using Coordinate Transforms to Improve Drawing Performance"></a>Using Coordinate Transforms to Improve Drawing Performance</h4><p><strong>修改 CTM 是在视图中绘制内容的标准技术，因为它允许您重用路径，这可能会减少绘制时所需的计算量</strong>。 例如，如果要从点（20,20）开始绘制一个正方形，则可以创建一个移动到（20,20）的路径，然后绘制所需的一组线以完成该正方形。 但是，如果后面决定将该方块移动到该点（10,10），则必须使用新起点重新创建路径。 因为创建路径是相对昂贵的操作，所以最好创建一个原点为（0,0）的正方形并修改CTM，以便在所需的原点绘制正方形。</p><p>在 Core Graphics 框架中，有两种方法可以修改CTM。 可以使用<a href="https://developer.apple.com/documentation/coregraphics/cgcontext">CGContext Reference</a>中定义的 CTM 操作函数直接修改 CTM 。 还可以创建<a href="https://developer.apple.com/documentation/coregraphics/cgaffinetransform">CGAffineTransform</a>结构，应用所需的任何转换，然后将该转换连接到 CTM 。 使用仿射变换可以对变换进行组装，然后将它们一次性应用到 CTM 。 还可以评估和转化仿射变换，使用它们来修改代代码中的点，大小和矩形值。 有关使用仿射变换的更多信息，请参阅<a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Introduction/Introduction.html#//apple_ref/doc/uid/TP30001066">Quartz 2D Programming Guide</a>的<a href="https://developer.apple.com/documentation/coregraphics/cgaffinetransform-rb5">CGAffineTransform Reference</a>。</p><h4 id="Flipping-the-Default-Coordinate-System"><a href="#Flipping-the-Default-Coordinate-System" class="headerlink" title="Flipping the Default Coordinate System"></a>Flipping the Default Coordinate System</h4><p>在 UIKit 绘图中<strong>翻转会修改背景(backing)CALayer</strong>，以将具有 LLO 坐标系的绘图环境与 UIKit 的默认坐标系对齐。 如果只使用 UIKit 方法和绘图功能，则不需要翻转 CTM 。 但是，如果将 Core Graphics 或 Image I/O 函数调用与 UIKit 调用混合使用，则可能需要翻转 CTM 。</p><p>尤其，如果通过直接调用 Core Graphics 函数绘制图像或 PDF 文档，则该对象将在视图的上下文中呈现为倒置。 必须翻转 CTM 才能正确显示图像和页面。</p><p>要将绘制到 Core Graphics 上下文的对象翻转，以便在 UIKit 视图中显示时正确显示，<strong>必须分两步修改CTM</strong>。 将原点转换为绘图区域的左上角，然后应用缩放平移，将 y 坐标修改为 -1。 执行此操作的代码类似于以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CGContextSaveGState(graphicsContext);</span><br><span class="line">CGContextTranslateCTM(graphicsContext, 0.0, imageHeight);</span><br><span class="line">CGContextScaleCTM(graphicsContext, 1.0, -1.0);</span><br><span class="line">CGContextDrawImage(graphicsContext, image, CGRectMake(0, 0, imageWidth, imageHeight));</span><br><span class="line">CGContextRestoreGState(graphicsContext);</span><br></pre></td></tr></table></figure><p>如果创建使用 Core Graphics 图像对象初始化的UIImage对象，<strong>UIKit 会为您执行翻转变换</strong>。 每个 UIImage 对象都由 CGImageRef opaque 类型支持(backed)。 可以通过 CGImage 属性访问 Core Graphics 对象，并对图像进行一些操作。 （Core Graphics 具有 UIKit 中不可用的图像相关功能。）完成后，可以从修改后的 CGImageRef 对象重新创建 UIImage 对象。</p><p>注意：可以使用 Core Graphics 函数 <code>CGContextDrawImage</code> 将图像绘制到任何渲染目标。 此函数有两个参数，第一个用于图形上下文，第二个用于矩形，用于定义图像的大小及其在绘图表面（如视图）中的位置。 使用 CGContextDrawImage 绘制图像时，如果不将当前坐标系调整为LLO方向，<strong>则图像在UIKit视图中显示为倒置</strong>。 此外，<strong>传递给此函数的矩形的原点是相对于调用函数时当前坐标系的原点</strong>。</p><h4 id="Side-Effects-of-Drawing-with-Different-Coordinate-Systems"><a href="#Side-Effects-of-Drawing-with-Different-Coordinate-Systems" class="headerlink" title="Side Effects of Drawing with Different Coordinate Systems"></a>Side Effects of Drawing with Different Coordinate Systems</h4><p>当使用一个绘图技术的默认坐标系绘制对象然后在另一个绘图技术的图形上下文中渲染时，会显示一些渲染奇怪现象。 可能需要调整代码以解决这些副作用。</p><h5 id="Arcs-and-Rotations"><a href="#Arcs-and-Rotations" class="headerlink" title="Arcs and Rotations"></a>Arcs and Rotations</h5><p>如果使用 CGContextAddArc 和 CGPathAddArc 等函数绘制路径并假设 LLO 坐标系，则需要翻转 CTM 以在 UIKit 视图中正确渲染弧。 但是，如果使用相同的函数创建包含位于 ULO 坐标系中的点的弧，然后在 UIKit 视图中渲染路径，将注意到弧是其原始的更改版本。 现在，弧的终止端点指向与使用 UIBezierPath 类创建的弧所做的端点相反的方向。 例如，向下箭头现在指向上方（如图1-5所示），弧“弯曲”的方向也不同。 所以必须更改 Core Graphics 绘制弧的方向以考虑基于 ULO 的坐标系; 此方向由这些函数的 startAngle 和 endAngle 参数控制。</p><p><img src="https://developer.apple.com/library/archive/documentation/2DDrawing/Conceptual/DrawingPrintingiOS/Art/flipped_coordinates-1_2x.png" alt="Figure 1-5  Arc rendering in Core Graphics versus UIKit"></p><p>如果旋转对象，则可以观察到相同类型的镜像效果（例如，通过调用 <code>CGContextRotateCTM</code> ）。 如果使用引用 ULO 坐标系的 Core Graphics 调用旋转对象，则在 UIKit 中渲染时对象的方向将反转。 必须在代码中考虑不同的轮换方向; 使用 CGContextRotateCTM ，可以通过反转角度参数的符号来执行此操作（例如，负值变为正值）。</p><h5 id="Shadows"><a href="#Shadows" class="headerlink" title="Shadows"></a>Shadows</h5><p>阴影从其对象落下的方向由偏移值指定，该偏移的含义是绘图框架的约定。 在 UIKit 中，正 x 和 y 偏移使阴影向下并且在对象的右侧。 在 Core Graphics 中，正 x 和 y 偏移会使阴影上升到对象的右侧。 翻转 CTM 以使对象与 UIKit 的默认坐标系对齐不会影响对象的阴影，因此阴影无法正确跟踪其对象。 要使其正确跟踪，必须适当修改当前坐标系的偏移值。</p><h2 id="Applying-Core-Animation-Effects"><a href="#Applying-Core-Animation-Effects" class="headerlink" title="Applying Core Animation Effects"></a>Applying Core Animation Effects</h2><p>Core Animation 是一个 Objective-C 框架，为快速，轻松地创建流畅的实时动画提供基础设施。 <strong>核心动画本身并不是绘图技术，因为它不提供用于创建形状，图像或其他类型内容的原始例程。 相反，它是一种操纵和显示 您使用其他技术创建的 内容 的技术。</strong></p><p>大多数应用程序都可以从 iOS 中以某种形式使用 Core Animation 中受益。 动画向用户提供有关正在发生的事情的反馈。 例如，当用户浏览“设置”应用时，屏幕会根据用户是否在首选项层次结构中向下导航或返回到根节点而滑入和滑出视图。 这种反馈很重要，并为用户提供上下文信息。 它还增强了应用程序的视觉风格。</p><p>在大多数情况下，您可以轻松地获得 Core Animation 的好处。 例如， UIView 类的几个属性（包括视图的框架，中心，颜色和不透明度等）可以配置为在其值发生变化时触发动画。 您必须做一些工作才能让 UIKit 知道您希望执行这些动画，但动画本身会自动创建并运行。 有关如何触发内置视图动画的信息，请参阅<a href="https://developer.apple.com/documentation/uikit/uiview">UIView Class Reference</a>中的动画视图。</p><p>当超越基本动画时，您必须更直接地与 Core Animation 类和方法进行交互。 以下部分提供有关 Core Animation 的信息，并向您展示如何使用其类和方法在 iOS 中创建典型动画。 有关 Core Animation 及其使用方法的其他信息，请参阅<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004514">Core Animation Programming Guide</a>。</p><h3 id="About-Layers"><a href="#About-Layers" class="headerlink" title="About Layers"></a>About Layers</h3><p>核心动画中的关键技术是图层对象。 图层是轻量级对象，<strong>在本质上与视图类似，但实际上是模型对象，它们封装了要显示的内容的几何，时间和视觉属性</strong>。 内容本身以三种方式之一提供：</p><ul><li>You can assign a CGImageRef to the contents property of the layer object.</li><li>You can assign a delegate to the layer and let the delegate handle the drawing.</li><li>You can subclass CALayer and override one of the display methods.</li></ul><p>操作图层对象的属性时，实际操作的是模型级数据，用于确定应如何显示关联内容。 <strong>该内容的实际渲染是与代码分开处理的</strong>，并经过大量优化以确保其快速。 <strong>您所要做的就是设置图层内容，配置动画属性，然后让 Core Animation 接管</strong>。有关图层及其使用方式的更多信息，请参阅<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004514">Core Animation Programming Guide</a>。</p><h3 id="About-Animations"><a href="#About-Animations" class="headerlink" title="About Animations"></a>About Animations</h3><p>在动画图层时， Core Animation 使用单独的动画对象来控制动画的时间和行为。 CAAnimation 类及其子类提供了可在代码中使用的不同类型的动画行为。 可以创建将属性从一个值迁移到另一个值的简单动画，也可以创建复杂的<strong>关键帧动画</strong>，即通过提供的一组值和计时功能来跟踪动画。</p><p>Core Animation 还允许<strong>将多个动画组合到一个单元中，称为事务</strong>。  CATransaction 对象将动画组作为一个单元进行管理。 还可以使用此类的方法来设置动画的持续时间。</p><p>有关如何创建自定义动画的示例，请参阅<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Animation_Types_Timing/Introduction/Introduction.html#//apple_ref/doc/uid/TP40006166">Animation Types and Timing Programming Guide</a>。</p><h3 id="Accounting-for-Scale-Factors-in-Core-Animation-Layers"><a href="#Accounting-for-Scale-Factors-in-Core-Animation-Layers" class="headerlink" title="Accounting for Scale Factors in Core Animation Layers"></a>Accounting for Scale Factors in Core Animation Layers</h3><p>直接使用 Core Animation 图层提供内容的应用<strong>可能需要调整其绘图代码以考虑比例因子</strong>。 通常，当在视图的 <code>drawRect:</code> 方法中绘制时，或者在<strong>图层委托</strong>的 <code>drawLayer:inContext:</code> 方法中绘制时，系统会自动调整图形上下文以考虑比例因子。 但是，当视图执行以下操作之一时，<strong>可能仍然需要了解或更改该比例因子</strong>：</p><ul><li>创建具有不同比例因子的其他 Core Animation 图层，并将它们合成为自己的内容 “Creates additional Core Animation layers with different scale factors and composites them into its own content”</li><li>直接设置 Core Animation 图层的 contents 属性 “Sets the contents property of a Core Animation layer directly”</li></ul><p><strong>Core Animation 的合成引擎</strong>查看每个图层的 contentsScale 属性，以确定在合成期间是否需要缩放该图层的内容。 如果应用创建<strong>没有关联视图的图层</strong>，则每个新图层对象的比例因子最初设置为 1.0 。 如果不更改该比例因子，并且随后在高分辨率屏幕上绘制该图层，则会自动缩放图层的内容以补偿(compensate)比例因子的差异。 如果不希望缩放内容，可以通过为 contentsScale 属性设置新值来将图层的比例因子更改为 2.0 ，但如果这样做但是不提供高分辨率内容，则现有内容可能会比期待的要小。 要解决该问题，则需要为图层提供更高分辨率的内容。</p><p>要点：图层的 contentsGravity 属性 在确定标准分辨率图层内容是否在高分辨率屏幕上缩放时 起作用。 默认情况下，此属性设置为值 kCAGravityResize ，这会导致图层内容缩放以适合图层的边界。 将该属性更改为非尺寸选项可消除否则会发生的自动缩放。 在这种情况下，您可能需要相应地调整内容或比例因子。</p><p>当直接设置图层的 contents 属性时，<strong>调整图层的内容</strong>以适应不同的比例因子是最合适的。 <strong>Quartz图像没有比例因子的概念，因此直接与像素一起工作</strong>。 因此，在创建计划用于图层内容的 CGImageRef 对象之前，请检查比例因子并相应地调整图像的大小。 具体来说，从应用程序包中加载适当大小的图像，或使用  <code>UIGraphicsBeginImageContextWithOptions</code> 函数创建一个图像，<strong>其比例因子与图层的比例因子相匹配</strong>。 如果不创建高分辨率位图，则可以如前所述缩放现有位图。</p><p>有关如何指定和加载高分辨率图像的信息，请参阅”#Loading Images into Your App#”。 有关如何创建高分辨率图像的信息，请参阅”#Drawing to Bitmap Contexts and PDF Contexts#”。</p><h1 id="Drawing-Shapes-Using-Bezier-Paths"><a href="#Drawing-Shapes-Using-Bezier-Paths" class="headerlink" title="Drawing Shapes Using Bézier Paths"></a>Drawing Shapes Using Bézier Paths</h1><p>在 iOS 3.2 及更高版本中，可以使用 UIBezierPath 类创建基于<strong>矢量的路径</strong>。 UIBezierPath 类是 Core Graphics 框架中与路径相关的功能的 Objective-C 包装器。 可以使用此类定义简单形状，例如椭圆和矩形，以及包含多个直线和曲线线段的复杂形状。(ps: UIKit 都对 Core Graphics 的相关功能进行了封装。)</p><p>可以使用路径对象在应用程序的用户界面中绘制形状(draw shapes)。 可以绘制路径的轮廓，填充它所包含的空间，或两者。 还可以使用路径为当前图形上下文定义剪切区域，然后可以使用该剪辑区域修改该上下文中的后续绘制操作。(ps: 这里有一个 dmeo: <a href="https://developer.apple.com/library/archive/samplecode/QuartzDemo/Introduction/Intro.html#//apple_ref/doc/uid/DTS40007531">Quartz2D for iOS</a>)</p><h2 id="Bezier-Path-Basics"><a href="#Bezier-Path-Basics" class="headerlink" title="Bézier Path Basics"></a>Bézier Path Basics</h2><p>UIBezierPath 对象是 CGPathRef 数据类型的包装器。 <strong>路径是使用直线和曲线段构建的基于矢量的形状</strong>。 您可以使用线段创建矩形和多边形，也可以使用曲线段创建圆弧，圆和复杂的曲线形状。 每个段由一个或多个点（在当前坐标系中）和一个绘图命令组成，该命令定义这些点是如何解释（ps: interpreted 这里翻译成处理会更好）。</p><p>每组连接的线和曲线段形成所谓的子路径。 子路径中一行或曲线段的末尾<strong>定义下一行的开头</strong>。 单个 UIBezierPat h对象可以包含一个或多个定义整个路径的子路径，由moveToPoint：命令分隔，这些命令可以有效地提升绘图笔并将其移动到新位置。</p><p>构建和使用路径对象的过程是分开的。 构建路径是第一个过程，涉及以下步骤：</p><ol><li> 创建路径对象。</li><li> 设置UIBezierPath对象的任何相关绘图属性，例如描边路径的lineWidth或lineJoinStyle属性或已填充路径的usesEvenOddFillRule属性。 这些绘图属性适用于整个路径。</li><li> 使用moveToPoint：方法设置初始段的起始点。</li><li> 添加线和曲线段以定义子路径。</li><li> （可选）通过调用closePath关闭子路径，<strong>closePath从最后一个段的末尾到第一个段的开头绘制一条直线段</strong>。</li><li> （可选）重复步骤3,4和5以定义其他子路径。</li></ol><p>构建路径时，应该相对于原点（0,0）排列路径的点。 这样做可以更轻松地在以后移动路径。 在绘制过程中，路径的点将按原样应用于当前图形上下文的坐标系。 如果您的路径相对于原点定向，当重新定位时，你所需要做的就，将具有平移因子的仿射变换应用于当前图形上下文。 <strong>修改图形上下文（与路径对象本身相对）的优点是，您可以通过保存和恢复图形状态轻松撤消转换</strong>。</p><p>要绘制路径对象，请使用描边和填充方法(stroke and fill)。 这些方法在当前图形上下文中渲染路径的线段和曲线段。 渲染过程涉及使用路径对象的属性栅格化线和曲线段。 <strong>栅格化过程不会修改路径对象本身</strong>。 因此，您可以在当前上下文或另一个上下文中多次渲染相同的路径对象。<br>(ps: 栅格化到底是个什么鬼？)</p><h2 id="Adding-Lines-and-Polygons-to-Your-Path"><a href="#Adding-Lines-and-Polygons-to-Your-Path" class="headerlink" title="Adding Lines and Polygons to Your Path"></a>Adding Lines and Polygons to Your Path</h2><p>线条和多边形是 使用 <code>moveToPoint:</code> 和 <code>addLineToPoint:</code> 方法逐点构建的 简单形状。 <code>moveToPoint:</code> 方法设置 要创建的形状的 起点。 从那个点起，您可以使用 <code>addLineToPoint:</code> 方法创建形状的线条。 还可以连续创建线条，每条线条都在前一个点和您指定的新点之间形成。</p><p>清单2-1显示了使用单独的线段创建五边形形状所需的代码。 （图2-1显示了 使用适当的笔触和填充颜色设置绘制此形状的 结果，如”#Rendering the Contents of a Bézier Path Object#”所述。）此代码设置形状的初始点，然后添加四个连接的线段。 通过调用closePath方法添加第五个段，该方法将最后一个点（0,40）与第一个点（100,0）连接起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 2-1  Creating a pentagon shape</span><br><span class="line"></span><br><span class="line">UIBezierPath *aPath &#x3D; [UIBezierPath bezierPath];</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Set the starting point of the shape.</span><br><span class="line">[aPath moveToPoint:CGPointMake(100.0, 0.0)];</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Draw the lines.</span><br><span class="line">[aPath addLineToPoint:CGPointMake(200.0, 40.0)];</span><br><span class="line">[aPath addLineToPoint:CGPointMake(160, 140)];</span><br><span class="line">[aPath addLineToPoint:CGPointMake(40.0, 140)];</span><br><span class="line">[aPath addLineToPoint:CGPointMake(0.0, 40.0)];</span><br><span class="line">[aPath closePath];</span><br></pre></td></tr></table></figure><p><img src="https://developer.apple.com/library/archive/documentation/2DDrawing/Conceptual/DrawingPrintingiOS/Art/bezier_pentagon_2x.png" alt="Figure 2-1  Shape drawn with methods of the UIBezierPath class"></p><p>使用closePath方法不仅会结束描述形状的子路径，还会在第一个和最后一个点之间绘制一条线段。 这是完成多边形而不必绘制最终线的便捷方法。</p><h2 id="Adding-Arcs-to-Your-Path"><a href="#Adding-Arcs-to-Your-Path" class="headerlink" title="Adding Arcs to Your Path"></a>Adding Arcs to Your Path</h2><p>UIBezierPath 类支持使用弧段初始化新路径对象。<code>bezierPathWithArcCenter:radius:startAngle:endAngle:clockwise:</code> 方法的参数 定义了包含所需弧的圆以及弧本身的起点和终点。 图2-2显示了创建弧的组件，包括定义弧的圆和用于指定弧的角度测量。 在这种情况下，弧沿顺时针方向创建。 （以逆时针方向绘制圆弧将改为绘制圆的虚线部分。）创建此弧的代码如清单2-2所示。</p><p><img src="https://developer.apple.com/library/archive/documentation/2DDrawing/Conceptual/DrawingPrintingiOS/Art/arc_layout_2x.png" alt="Figure 2-2  An arc in the default coordinate system"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 2-2  Creating a new arc path</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; pi is approximately equal to 3.14159265359.</span><br><span class="line">#define   DEGREES_TO_RADIANS(degrees)  ((pi * degrees)&#x2F; 180)</span><br><span class="line"> </span><br><span class="line">- (UIBezierPath *)createArcPath</span><br><span class="line">&#123;</span><br><span class="line">   UIBezierPath *aPath &#x3D; [UIBezierPath bezierPathWithArcCenter:CGPointMake(150, 150)</span><br><span class="line">                           radius:75</span><br><span class="line">                           startAngle:0</span><br><span class="line">                           endAngle:DEGREES_TO_RADIANS(135)</span><br><span class="line">                           clockwise:YES];</span><br><span class="line">   return aPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要将弧段合并到路径的中间，则必须直接修改路径对象的CGPathRef数据类型。 有关使用Core Graphics函数修改路径的更多信息，请参阅”#Modifying the Path Using Core Graphics Functions#”。</p><h2 id="Adding-Curves-to-Your-Path"><a href="#Adding-Curves-to-Your-Path" class="headerlink" title="Adding Curves to Your Path"></a>Adding Curves to Your Path</h2><p>UIBezierPath 类支持将三次(Cubic)和二次(Quadratic) 贝塞尔曲线添加到路径。 曲线段从当前点开始，到您指定的点结束。 使用起点和终点之间的切线(tangent)以及一个或多个控制点来定义曲线的形状。 图2-3显示了两种曲线类型的近似值以及控制点与曲线形状之间的关系。 每个段的精确曲率涉及所有点之间的复杂数学关系，并且在线文档和<a href="http://en.wikipedia.org/wiki/Bezier_curve">维基百科</a>都有详细记录。</p><p><img src="https://developer.apple.com/library/archive/documentation/2DDrawing/Conceptual/DrawingPrintingiOS/Art/curve_segments_2x.png" alt="Figure 2-3  Curve segments in a path"></p><p>要将曲线添加到路径，请使用以下方法：</p><ul><li>Cubic curve: addCurveToPoint:controlPoint1:controlPoint2:</li><li>Quadratic curve: addQuadCurveToPoint:controlPoint:</li></ul><p>由于<strong>曲线依赖于路径的当前点</strong>，因此必须在调用上述任一方法之前设置当前点。 完成曲线后，当前点将更新为您指定的新结束点。</p><h2 id="Creating-Oval-and-Rectangular-Paths"><a href="#Creating-Oval-and-Rectangular-Paths" class="headerlink" title="Creating Oval and Rectangular Paths"></a>Creating Oval and Rectangular Paths</h2><p>椭圆和矩形是使用曲线和线段组合构建的常见路径类型。 UIBezierPath类包含bezierPathWithRect：和bezierPathWithOvalInRect：方便方法，用于创建椭圆或矩形形状的路径。这两种方法都创建了一个新的路径对象，并使用指定的形状对其进行初始化。您可以立即使用返回的路径对象，也可以根据需要添加更多形状。</p><p>如果要将矩形添加到现有路径对象，则必须使用moveToPoint：，addLineToPoint：和closePath方法，就像对任何其他多边形一样。对矩形的最后一侧使用closePath方法是 添加路径的最后一行并且还标记矩形子路径的末尾的 便捷方式。</p><p>如果要在现有路径中添加椭圆，最简单的方法是使用Core Graphics。 虽然您可以使用addQuadCurveToPoint：controlPoint：来近似椭圆曲面，但CGPathAddEllipseInRect函数使用起来更简单，更准确。 有关更多信息，请参阅”#Modifying the Path Using Core Graphics Functions#”。</p><h2 id="Modifying-the-Path-Using-Core-Graphics-Functions"><a href="#Modifying-the-Path-Using-Core-Graphics-Functions" class="headerlink" title="Modifying the Path Using Core Graphics Functions"></a>Modifying the Path Using Core Graphics Functions</h2><p>UIBezierPath 类实际上只是 CGPathRef 数据类型的包装器以及与该路径关联的绘图属性。 虽然通常使用U IBezierPath 类的方法添加线段和曲线段，但该类还公开了一个 CGPath 属性，可以使用该属性直接修改路径数据类型。 当您希望使用 Core Graphics 框架的功能构建路径时，可以使用此属性。</p><p>有两种方法可以修改与 UIBezierPath 对象关联的路径。 可以使用 Core Graphics 函数完全修改路径，也可以混合使用 Core Graphics 函数和 UIBezierPath 方法。 在某些方面，使用 Core Graphics 调用完全修改路径更容易。 可以创建可变 CGPathRef 数据类型并调用修改其路径信息所需的任何函数。 完成后，将路径对象分配给相应的 UIBezierPath 对象，如清单2-3所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 2-3  Assigning a new CGPathRef to a UIBezierPath object</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Create the path data.</span><br><span class="line">CGMutablePathRef cgPath &#x3D; CGPathCreateMutable();</span><br><span class="line">CGPathAddEllipseInRect(cgPath, NULL, CGRectMake(0, 0, 300, 300));</span><br><span class="line">CGPathAddEllipseInRect(cgPath, NULL, CGRectMake(50, 50, 200, 200));</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Now create the UIBezierPath object.</span><br><span class="line">UIBezierPath *aPath &#x3D; [UIBezierPath bezierPath];</span><br><span class="line">aPath.CGPath &#x3D; cgPath;</span><br><span class="line">aPath.usesEvenOddFillRule &#x3D; YES;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; After assigning it to the UIBezierPath object, you can release</span><br><span class="line">&#x2F;&#x2F; your CGPathRef data type safely.</span><br><span class="line">CGPathRelease(cgPath);</span><br></pre></td></tr></table></figure><p>如果选择使用 Core Graphics 函数和 UIBezierPath 方法的<strong>混合，则必须在两者之间来回小心地移动路径信息</strong>。 因为 UIBezierPath 对象拥有其基础 CGPathRef 数据类型，<strong>所以不能简单地检索该类型并直接修改它。 相反，必须制作可变副本，修改副本，然后将副本分配回CGPath属性</strong>，如清单2-4所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 2-4  Mixing Core Graphics and UIBezierPath calls</span><br><span class="line"></span><br><span class="line">UIBezierPath *aPath &#x3D; [UIBezierPath bezierPathWithOvalInRect:CGRectMake(0, 0, 300, 300)];</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Get the CGPathRef and create a mutable version.</span><br><span class="line">CGPathRef cgPath &#x3D; aPath.CGPath;</span><br><span class="line">CGMutablePathRef  mutablePath &#x3D; CGPathCreateMutableCopy(cgPath);</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Modify the path and assign it back to the UIBezierPath object.</span><br><span class="line">CGPathAddEllipseInRect(mutablePath, NULL, CGRectMake(50, 50, 200, 200));</span><br><span class="line">aPath.CGPath &#x3D; mutablePath;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Release both the mutable copy of the path.</span><br><span class="line">CGPathRelease(mutablePath);</span><br></pre></td></tr></table></figure><h2 id="Rendering-the-Contents-of-a-Bezier-Path-Object"><a href="#Rendering-the-Contents-of-a-Bezier-Path-Object" class="headerlink" title="Rendering the Contents of a Bézier Path Object"></a>Rendering the Contents of a Bézier Path Object</h2><p>创建 UIBezierPath 对象后，可以使用其描边和填充方法在当前图形上下文中渲染它。但是，在调用这些方法之前，通常还需要执行一些其他任务来确保正确绘制路径：</p><ul><li>使用 UIColor 类的方法设置所需的描边和填充颜色。</li><li>将形状放在目标视图中所需的位置。<br>如果创建了相对于点（0,0）的路径，则可以将适当的仿射变换应用于当前绘图上下文。例如，要从点（10,10）开始绘制形状，将调用 <code>CGContextTranslateCTM</code> 函数并为水平和垂直平移值指定 10 。首选调整图形上下文（而不是路径对象中的点），因为可以通过保存和恢复以前的图形状态来更轻松地撤消更改。</li><li>更新路径对象的绘图属性。在渲染路径时， UIBezierPath 实例的绘图属性会覆盖与图形上下文关联的值。</li></ul><p>清单2-5显示了 <code>drawRect:</code> 方法的示例实现，该方法在自定义视图中绘制椭圆。椭圆的边界矩形的左上角位于视图坐标系中的点（50,50）处。因为填充操作直接绘制到路径边界，所以此方法在描边之前填充路径。这可以防止填充颜色遮挡一半的描边线。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 2-5  Drawing a path in a view</span><br><span class="line"></span><br><span class="line">- (void)drawRect:(CGRect)rect</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Create an oval shape to draw.</span><br><span class="line">    UIBezierPath *aPath &#x3D; [UIBezierPath bezierPathWithOvalInRect:</span><br><span class="line">                                CGRectMake(0, 0, 200, 100)];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Set the render colors.</span><br><span class="line">    [[UIColor blackColor] setStroke];</span><br><span class="line">    [[UIColor redColor] setFill];</span><br><span class="line"> </span><br><span class="line">    CGContextRef aRef &#x3D; UIGraphicsGetCurrentContext();</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; If you have content to draw after the shape,</span><br><span class="line">    &#x2F;&#x2F; save the current state before changing the transform.</span><br><span class="line">    &#x2F;&#x2F;CGContextSaveGState(aRef);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Adjust the view&#39;s origin temporarily. The oval is</span><br><span class="line">    &#x2F;&#x2F; now drawn relative to the new origin point.</span><br><span class="line">    CGContextTranslateCTM(aRef, 50, 50);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Adjust the drawing options as needed.</span><br><span class="line">    aPath.lineWidth &#x3D; 5;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Fill the path before stroking it so that the fill</span><br><span class="line">    &#x2F;&#x2F; color does not obscure the stroked line.</span><br><span class="line">    [aPath fill];</span><br><span class="line">    [aPath stroke];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Restore the graphics state before drawing any other content.</span><br><span class="line">    &#x2F;&#x2F;CGContextRestoreGState(aRef);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Doing-Hit-Detection-on-a-Path"><a href="#Doing-Hit-Detection-on-a-Path" class="headerlink" title="Doing Hit-Detection on a Path"></a>Doing Hit-Detection on a Path</h2><p>要确定是否在路径的填充部分上发生了触摸事件，可以使用 UIBezierPath 的 <code>containsPoint:</code> 方法。此方法针对路径对象中所有<strong>已关闭</strong>的子路径测试指定点，如果它位于任何这些子路径上或内部，则返回YES。</p><p><strong>要点：</strong> containsPoint: 方法和Core Graphics命中测试功能<strong>仅在封闭路径上</strong>运行。对于打开的子路径上的命中，这些方法始终返回 NO 。如果要在打开的子路径上执行命中检测，则必须先创建路径对象的副本，然后在测试点之前关闭打开的子路径。</p><p>如果要对<strong>路径的描边部分（而不是填充区域）进行命中测试</strong>(on the stroked portion of the path (instead of the fill area))，则必须使 用Core Graphics 。 <code>CGContextPathContainsPoint</code> 函数允许测试当前分配给图形上下文的路径的填充或描边部分上的点。清单2-6显示了一个方法，用于测试指定的点是否与指定的路径相交。 inFill 参数允许调用者指定是否应针对路径的填充或描边部分测试该点。调用者传入的路径必须包含一个或多个已关闭的<strong>子路径</strong>，以使命中检测成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 2-6  Testing points against a path object</span><br><span class="line"></span><br><span class="line">- (BOOL)containsPoint:(CGPoint)point onPath:(UIBezierPath *)path inFillArea:(BOOL)inFill</span><br><span class="line">&#123;</span><br><span class="line">   CGContextRef context &#x3D; UIGraphicsGetCurrentContext();</span><br><span class="line">   CGPathRef cgPath &#x3D; path.CGPath;</span><br><span class="line">   BOOL    isHit &#x3D; NO;</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; Determine the drawing mode to use. Default to</span><br><span class="line">   &#x2F;&#x2F; detecting hits on the stroked portion of the path.</span><br><span class="line">   CGPathDrawingMode mode &#x3D; kCGPathStroke;</span><br><span class="line">   if (inFill)</span><br><span class="line">   &#123;</span><br><span class="line">      &#x2F;&#x2F; Look for hits in the fill area of the path instead.</span><br><span class="line">      if (path.usesEvenOddFillRule)</span><br><span class="line">         mode &#x3D; kCGPathEOFill;</span><br><span class="line">      else</span><br><span class="line">         mode &#x3D; kCGPathFill;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; Save the graphics state so that the path can be</span><br><span class="line">   &#x2F;&#x2F; removed later.</span><br><span class="line">   CGContextSaveGState(context);</span><br><span class="line">   CGContextAddPath(context, cgPath);</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; Do the hit detection.</span><br><span class="line">   isHit &#x3D; CGContextPathContainsPoint(context, point, mode);</span><br><span class="line"> </span><br><span class="line">   CGContextRestoreGState(context);</span><br><span class="line"> </span><br><span class="line">   return isHit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Drawing-and-Creating-Images"><a href="#Drawing-and-Creating-Images" class="headerlink" title="Drawing and Creating Images"></a>Drawing and Creating Images</h1><p>大多数情况下，使用标准视图显示图像非常简单。 但是，有两种情况您可能需要做额外的工作：</p><ul><li>如果要将图像显示为自定义视图的一部分，则必须在视图的 <code>drawRect:</code> 方法中自行绘制图像。 “#Drawing Images#” 解释了为什么。</li><li>如果要在屏幕外渲染图像（稍后绘制或保存到文件中），则必须创建位图图像上下文。 要了解更多信息，请阅读”#Creating New Images Using Bitmap Graphics Contexts#”。</li></ul><h2 id="Drawing-Images"><a href="#Drawing-Images" class="headerlink" title="Drawing Images"></a>Drawing Images</h2><p>为了获得最佳性能，如果使用 UIImageView 类可以满足图像绘制需求，则应使用此图像对象初始化 UIImageView 对象。 但是，如果<strong>需要显式绘制图像</strong>，则可以存储图像并稍后在视图的d <code>rawRect:</code> 方法中使用它。下面的代码是从 bundle 加载图片。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSString *imagePath &#x3D; [[NSBundle mainBundle] pathForResource:@&quot;myImage&quot; ofType:@&quot;png&quot;];</span><br><span class="line">UIImage *myImageObj &#x3D; [[UIImage alloc] initWithContentsOfFile:imagePath];</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Store the image into a property of type UIImage *</span><br><span class="line">&#x2F;&#x2F; for use later in the class&#39;s drawRect: method.</span><br><span class="line">self.anImage &#x3D; myImageObj;</span><br></pre></td></tr></table></figure><p>要在视图的 <code>drawRect:</code> 方法中显式绘制生成的图像，可以使用 UIImage 中提供的任何绘图方法。 这些方法允许指定视图中要绘制图像的位置，因此不需要在绘制之前创建和应用单独的变换。</p><p>以下代码段在视图中的点（10,10）处绘制上面加载的图像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)drawRect:(CGRect)rect</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Draw the image.</span><br><span class="line">    [self.anImage drawAtPoint:CGPointMake(10, 10)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要点：如果使用 <code>CGContextDrawImage</code> 函数直接绘制位图图像，则默认情况下图像数据沿 y 轴反转。 这是因为Quartz 图像假定坐标系具有左下角的原点，而正坐标轴从该点向上和向右延伸。 虽然可以在绘制之前应用变换，但绘制 Quartz 图像的简单（和推荐）方法是将它们<strong>包装在 UIImage 对象中，该对象可自动补偿坐标空间中的这种差异</strong>。 有关使用 Core Graphics 创建和绘制图像的更多信息，请参阅<a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Introduction/Introduction.html#//apple_ref/doc/uid/TP30001066">Quartz 2D Programming Guide</a>。</p><h2 id="Creating-New-Images-Using-Bitmap-Graphics-Contexts"><a href="#Creating-New-Images-Using-Bitmap-Graphics-Contexts" class="headerlink" title="Creating New Images Using Bitmap Graphics Contexts"></a>Creating New Images Using Bitmap Graphics Contexts</h2><p>大部分时间，在绘图时，你的目标是在屏幕上显示某些内容。但是，<strong>将某些内容绘制到屏幕外缓冲区有时很有用</strong>。例如，可能希望创建现有图像的缩略图，绘制到缓冲区中以便将其保存到文件中，等等。为了支持这些需求，可以创建位图图像上下文，使用 UIKit 框架或 Core Graphics 函数绘制它，然后从上下文中获取图像对象。</p><p>在 UIKit 中，步骤如下：</p><ol><li><p>调用 <code>UIGraphicsBeginImageContextWithOptions</code> 来创建位图上下文并将其推送到图形堆栈。<br> 对于第一个参数（大小），传递 CGSize 值以指定位图上下文的维度（<strong>以点为单位</strong>）。// Core Graphics 是以像素为单位的<br> 对于第二个参数（不透明），如果图像包含透明度（Alpha通道），则传递 NO。否则，传递 YES 以最大化性能。<br> 对于最终参数（比例），对于为设备主屏幕适当缩放的位图传递 0.0 ，或者传递您选择的比例因子。<br> 例如，以下代码段创建一个 200 x 200 像素的位图。 （<strong>像素数通过将图像的大小乘以比例因子来确定。</strong>） <code>UIGraphicsBeginImageContextWithOptions（CGSizeMake（100.0, 100.0），NO，2.0）;</code></p><p> 注意：通常应该避免调用类似名称的 <code>UIGraphicsBeginImageContext</code> 函数（除了作为向后兼容性的后备），因为它始终创建比例因子为 1.0 的图像。如果底层设备具有高分辨率屏幕，则使用  <code>UIGraphicsBeginImageContext</code> 创建的图像在渲染时可能不会显示为平滑。</p></li><li><p> 使用 UIKit 或 Core Graphics 例程将图像的内容绘制到新创建的图形上下文中。</p></li><li><p> 调用 <code>UIGraphicsGetImageFromCurrentImageContex</code>t 函数，根据绘制的内容生成并返回 UIImage 对象。如果需要，还可以继续绘制并再次调用此方法以生成其他图像。</p></li><li><p> 调用 <code>UIGraphicsEndImageContext</code> 从图形堆栈中弹出上下文。</p></li></ol><p>清单3-1中的方法得到一个 image 通过互联网下载并将其绘制到基于图像的上下文中，缩小到应用程序图标的大小。然后，它获取从位图数据创建的 UIImage 对象，并将其分配给实例变量。请注意，位图的大小(<code>UIGraphicsBeginImageContextWithOptions</code>的第一个参数)和绘制内容的大小（imageRect的大小）应该匹配。如果内容大于位图，则内容的一部分将被剪切而不会出现在结果图像中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-1  Drawing a scaled-down image to a bitmap context and obtaining the resulting image</span><br><span class="line"></span><br><span class="line">- (void)connectionDidFinishLoading:(NSURLConnection *)connection &#123;</span><br><span class="line">    UIImage *image &#x3D; [[UIImage alloc] initWithData:self.activeDownload];</span><br><span class="line">    if (image !&#x3D; nil &amp;&amp; image.size.width !&#x3D; kAppIconHeight &amp;&amp; image.size.height !&#x3D; kAppIconHeight) &#123;</span><br><span class="line">        CGRect imageRect &#x3D; CGRectMake(0.0, 0.0, kAppIconHeight, kAppIconHeight);</span><br><span class="line">        UIGraphicsBeginImageContextWithOptions(itemSize, NO, [UIScreen mainScreen].scale);</span><br><span class="line">        [image drawInRect:imageRect];</span><br><span class="line">        self.appRecord.appIcon &#x3D; UIGraphicsGetImageFromCurrentImageContext();  &#x2F;&#x2F; UIImage returned.</span><br><span class="line">        UIGraphicsEndImageContext();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        self.appRecord.appIcon &#x3D; image;</span><br><span class="line">    &#125;</span><br><span class="line">    self.activeDownload &#x3D; nil;</span><br><span class="line">    [image release];</span><br><span class="line">    self.imageConnection &#x3D; nil;</span><br><span class="line">    [delegate appImageDidLoad:self.indexPathInTableView];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以调用 Core Graphics 函数来绘制生成的位图图像的内容; 清单3-2中的代码片段绘制了 PDF 页面的缩小图像，给出了一个示例。 请注意，代码在调用 <code>CGContextDrawPDFPage</code> 之前翻转图形上下文，以将绘制的图像与 UIKit 的默认坐标系对齐。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Listing 3-2  Drawing to a bitmap context using Core Graphics functions</span><br><span class="line">&#x2F;&#x2F; Other code precedes...</span><br><span class="line"> </span><br><span class="line">CGRect pageRect &#x3D; CGPDFPageGetBoxRect(page, kCGPDFMediaBox);</span><br><span class="line">pdfScale &#x3D; self.frame.size.width&#x2F;pageRect.size.width;</span><br><span class="line">pageRect.size &#x3D; CGSizeMake(pageRect.size.width * pdfScale, pageRect.size.height * pdfScale);</span><br><span class="line">UIGraphicsBeginImageContextWithOptions(pageRect.size, YES, pdfScale);</span><br><span class="line">CGContextRef context &#x3D; UIGraphicsGetCurrentContext();</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; First fill the background with white.</span><br><span class="line">CGContextSetRGBFillColor(context, 1.0,1.0,1.0,1.0);</span><br><span class="line">CGContextFillRect(context,pageRect);</span><br><span class="line">CGContextSaveGState(context);</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Flip the context so that the PDF page is rendered right side up</span><br><span class="line">CGContextTranslateCTM(context, 0.0, pageRect.size.height);</span><br><span class="line">CGContextScaleCTM(context, 1.0, -1.0);</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Scale the context so that the PDF page is rendered at the</span><br><span class="line">&#x2F;&#x2F; correct size for the zoom level.</span><br><span class="line">CGContextScaleCTM(context, pdfScale,pdfScale);</span><br><span class="line">CGContextDrawPDFPage(context, page);</span><br><span class="line">CGContextRestoreGState(context);</span><br><span class="line">UIImage *backgroundImage &#x3D; UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">UIGraphicsEndImageContext();</span><br><span class="line">backgroundImageView &#x3D; [[UIImageView alloc] initWithImage:backgroundImage];</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Other code follows...</span><br></pre></td></tr></table></figure><p>如果您更喜欢完全使用 Core Graphics 来绘制位图图形上下文，则可以使用 <code>CGBitmapContextCreate</code> 函数创建位图上下文并将图像内容绘制到其中。 完成绘制后，调用 <code>CGBitmapContextCreateImage</code> 函数以从位图上下文中获取 CGImageRef 对象。 您可以直接绘制 Core Graphics 图像或使用它来初始化 UIImage 对象。 完成后，在图形上下文中调用 CGContextRelease 函数。</p><h2 id="Generating-PDF-Content"><a href="#Generating-PDF-Content" class="headerlink" title="Generating PDF Content"></a>Generating PDF Content</h2><p>ps:暂时没用到。不看</p><h2 id="Printing"><a href="#Printing" class="headerlink" title="Printing"></a>Printing</h2><p>ps:暂时没用到。不看</p><h2 id="Improving-Drawing-Performance"><a href="#Improving-Drawing-Performance" class="headerlink" title="Improving Drawing Performance"></a>Improving Drawing Performance</h2><p><strong>在任何平台上绘图都是一项相对昂贵的操作，优化绘图代码应始终是开发过程中的重要一步</strong>。 下面列出了几种确保绘图代码尽可能最佳的技巧。 除了这些提示以外，还应始终使用可用的性能工具来测试代码并删除热点和冗余。</p><ul><li>Draw minimally (在每个更新周期中，应该只更新视图中实际更改的部分。 如果使用 UIView 的 <code>drawRect:</code> 方法来绘制图形，请使用传递给该方法的更新矩形来限制绘图的范围。 对于 OpenGL 绘图，您必须自己跟踪更新。)</li><li>Call setNeedsDisplay: judiciously (如果正在调用 <code>setNeedsDisplay:</code> , 请始终花时间计算需要重绘的实际区域。 不要只传递包含整个视图的矩形。 此外，不要调用 <code>setNeedsDisplay:</code> 除非确实需要重绘内容。 如果内容实际上没有更改，请不要重绘。)</li><li>Mark opaque views as such (合成内容不透明的视图比合成部分透明的视图要少得多。 要使视图不透明，视图的内容不得包含<strong>任何透明度</strong>，并且视图的 opaque 属性必须设置为YES。)</li><li>Reuse table cells and views during scrolling (应该不惜一切代价避免在滚动期间创建新视图。 <strong>花时间创建新视图减少了更新屏幕的可用时间，从而导致不均匀的滚动行为</strong>。)</li><li>Reuse paths by modifying the current transformation matrix (通过修改当前转换矩阵，可以使用单个路径在屏幕的不同部分上绘制内容。 有关详细信息，请参阅”#Using Coordinate Transforms to Improve Drawing Performance#”。)</li><li>Avoid clearing the previous content during scrolling (默认情况下， UIKit 在调用其<code>drawRect:</code> 方法之前会清除视图的当前上下文缓冲区以更新同一区域。 如果要响应视图中的滚动事件，<strong>则在滚动更新期间反复清除此区域可能会非常昂贵</strong>。 要禁用该行为，可以将 <code>clearsContextBeforeDrawing</code> 属性中的值更改为 NO 。)</li><li>Minimize graphics state changes while drawing (更改图形状态需要底层图形子系统的工作。 如果您需要绘制使用类似状态信息的内容，请尝试将该内容绘制在一起<strong>以减少所需的状态更改次数</strong>。)</li><li>Use Instruments to debug your performance (核心动画工具可以帮助您发现应用中的绘图性能问题。 特别是：Flash Updated Regions 可让您轻松查看视图的哪些部分实际更新。 Color Misaligned Images 可帮助您查看对齐不良的图像，从而导致图像模糊和性能不佳。有关更多信息，请参阅 <a href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/index.html#//apple_ref/doc/uid/TP40004652">Instruments User Guide</a> 中的 <a href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/ExportingandImportingTraceData.html#//apple_ref/doc/uid/TP40004652-CH14">Measuring Graphics Performance in Your iOS Device</a>。)</li></ul><h1 id="Supporting-High-Resolution-Screens-In-Views"><a href="#Supporting-High-Resolution-Screens-In-Views" class="headerlink" title="Supporting High-Resolution Screens In Views"></a>Supporting High-Resolution Screens In Views</h1><p>针对 iOS SDK 4.0 及更高版本构建的应用程序，需要准备好在具有不同屏幕分辨率的设备上运行。 幸运的是，iOS可以轻松支持多种屏幕分辨率。 处理不同类型屏幕的大部分工作都是由系统框架完成的。 但是，应用仍需要做一些工作来更新基于光栅的图像(raster-based images)，并且根据应用程序，可能需要执行其他工作以利用可用的额外像素。</p><p>有关此主题的重要背景信息，请参阅”#Points Versus Pixels#”。</p><h2 id="Checklist-for-Supporting-High-Resolution-Screens"><a href="#Checklist-for-Supporting-High-Resolution-Screens" class="headerlink" title="Checklist for Supporting High-Resolution Screens"></a>Checklist for Supporting High-Resolution Screens</h2><p>要为具有高分辨率屏幕的设备更新应用程序，您需要执行以下操作：</p><ul><li>为应用包中的每个图像资源提供高分辨率图像，如”#Updating Your Image Resource Files#”中所述。</li><li>提供高分辨率应用和文档图标，如”#Updating Your App’s Icons and Launch Images#”中所述。</li><li>对于基于矢量的形状和内容，请像以前一样继续使用自定义 Core Graphics 和 UIKi t绘图代码。 如果要为绘制的内容添加额外的细节，请参阅点”#Points Versus Pixels#”以获取有关如何执行此操作的信息。</li><li>如果使用 OpenGL ES 进行绘制，请确定是否要选择加入高分辨率绘图并相应地设置图层的比例因子，如”#Drawing High-Resolution Content Using OpenGL ES or GLKit#”中所述。</li><li>对于自定义图像，请修改图像创建代码以将当前比例因子考虑在内，如”#Drawing to Bitmap Contexts and PDF Contexts#”中所述。</li><li>如果应用使用核心动画，请根据需要调整代码以补偿比例因子，如”#Accounting for Scale Factors in Core Animation Layers#”中所述。</li></ul><h2 id="Drawing-Improvements-That-You-Get-for-Free"><a href="#Drawing-Improvements-That-You-Get-for-Free" class="headerlink" title="Drawing Improvements That You Get for Free"></a>Drawing Improvements That You Get for Free</h2><p>iOS 中的绘图技术提供了大量支持，无论底层屏幕的分辨率如何，都可以帮助您使渲染内容看起来很好：</p><ul><li>标准 UIKit 视图（文本视图，按钮，表视图等）可以在任何分辨率下自动呈现。</li><li>基于矢量的内容（UIBezierPath ， CGPathRef ， PDF）自动利用任何其他像素来为形状渲染更清晰的线条。</li><li>文本以更高的分辨率自动呈现。</li><li>UIKit 支持自动加载图像的高分辨率变体(@2x)。</li></ul><p>如果您的应用<strong>仅使用原生绘图技术进行渲染，那么支持更高分辨率的屏幕，您需要做的唯一就是提供高分辨率版本的图像</strong>。</p><h2 id="Updating-Your-Image-Resource-Files"><a href="#Updating-Your-Image-Resource-Files" class="headerlink" title="Updating Your Image Resource Files"></a>Updating Your Image Resource Files</h2><p>在 iOS 4 中运行的应用现在应该为每个图像资源包含两个单独的文件。 一个文件提供给定图像的标准分辨率版本，第二个文件提供同一图像的高分辨率版本。 每对图像文件的命名约定如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">标准: &lt;ImageName&gt; &lt;device_modifier&gt;.&lt;filename_extension&gt;</span><br><span class="line">高分辨率: &lt;ImageName&gt; @2x &lt;device_modifier&gt;.&lt;filename_extension&gt;</span><br></pre></td></tr></table></figure><p>每个名称的 <ImageName> 和 <filename_extension> 部分指定文件的通常名称和扩展名。 <strong><device_modifier>部分是可选的，包含字符串<del>ipad或</del>iphone</strong>。 如果要为 iPad 和 iPhone 指定不同版本的图像，请包含其中一个修饰符(modifier)。 为高分辨率图像添加 @2x 修饰符是新的，让系统知道图像是标准图像的高分辨率变体。</p><p>要点：修饰符的顺序至关重要。 如果错误地将 @2x 放在设备修饰符之后， iOS 将无法找到该图像。</p><p>在创建图像的高分辨率版本时，请将新版本放在应用包中与原始版本相同的位置。</p><h3 id="Loading-Images-into-Your-App"><a href="#Loading-Images-into-Your-App" class="headerlink" title="Loading Images into Your App"></a>Loading Images into Your App</h3><p>UIImage 类处理将高分辨率图像加载到应用程序所需的所有工作。 创建新图像对象时，使用相同的名称来请求图像的标准版本和高分辨率版本。 例如，如果有两个名为 Button.png 和 <a href="mailto:&#66;&#117;&#116;&#x74;&#111;&#x6e;&#64;&#50;&#x78;&#46;&#112;&#110;&#x67;">&#66;&#117;&#116;&#x74;&#111;&#x6e;&#64;&#50;&#x78;&#46;&#112;&#110;&#x67;</a> 的图像文件，则可以使用以下代码来请求您的按钮图像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIImage *anImage &#x3D; [UIImage imageNamed:@&quot;Button&quot;];</span><br></pre></td></tr></table></figure><p>注意：在 iOS 4 及更高版本中，可以在指定图像名称时省略文件扩展名。</p><p>在具有高分辨率屏幕的设备上 <code>imageNamed</code> ， <code>imageWithContentsOfFile:</code> 和 <code>initWithContentsOfFile:</code> 方法会自动查找所请求图像的版本，其名称中包含 @2x 修饰符。如果找到一个，则会加载该图像。<strong>如果您未提供给定图像的高分辨率版本，则图像对象仍会加载标准分辨率图像（如果存在）并在绘图期间对其进行缩放</strong>。</p><p>加载图像时， UIImage 对象会根据图像文件的后缀<strong>自动将大小和比例属性设置为适当的值</strong>。对于标准分辨率图像，它将 scale 属性设置为 1.0 ，并将图像的大小设置为图像的像素尺寸。对于文件名中带有 @2x 后缀的图像，<strong>它将scale属性设置为 2.0 ，并将 width 和 height 值减半以补偿比例因子。这些减半的值与您需要在逻辑坐标空间中用于渲染图像的基于点的尺寸正确关联</strong>。</p><p>注意：<strong>如果使用 Core Graphics 创建图像，请记住 Quartz 图像没有明确的比例因子，因此它们的比例因子假定为1.0</strong>。 如果要从 CGImageRef 数据类型创建 UIImage 对象，请使用 <code>initWithCGImage:scale:orientation:</code> 来执行此操作。 该方法允许您将特定比例因子与 Quartz 图像数据相关联。</p><p>在绘制过程中， UIImage 对象会自动考虑其比例因子。 因此，只要在应用包中提供正确的图像资源，用于渲染图像的任何代码都应该相同。</p><h3 id="Using-an-Image-View-to-Display-Multiple-Images"><a href="#Using-an-Image-View-to-Display-Multiple-Images" class="headerlink" title="Using an Image View to Display Multiple Images"></a>Using an Image View to Display Multiple Images</h3><p>如果应用程序使用 UIImageView 类为突出显示或动画显示多个图像，则分配给该视图的<strong>所有图像必须使用相同的比例因子</strong>。 可以使用图像视图显示单个图像或为多个图像设置动画，还可以提供高光图像。 因此，如果您为其中一个图像提供高分辨率版本，那么所有图像也必须具有高分辨率版本。(ps: 分辨率都得相同。)</p><h3 id="Updating-Your-App’s-Icons-and-Launch-Images"><a href="#Updating-Your-App’s-Icons-and-Launch-Images" class="headerlink" title="Updating Your App’s Icons and Launch Images"></a>Updating Your App’s Icons and Launch Images</h3><p>除了更新应用的自定义图像资源外，还应该为应用的图标和启动图像提供新的高分辨率图标。 更新这些图像资源的过程与所有其他图像资源相同。 创建图像的新版本，将 @2x 修饰符字符串添加到相应的图像文件名，并在处理原始图像时处理图像。 例如，对于应用程序图标，将高分辨率图像文件名添加到应用程序的 Info.plist 文件的 CFBundleIconFiles 键。</p><p>有关为应用程序指定图标和启动图像的信息，请参阅<a href="https://developer.apple.com/library/archive/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007072">App Programming Guide for iOS</a>中的<a href="https://developer.apple.com/library/archive/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Inter-AppCommunication/Inter-AppCommunication.html#//apple_ref/doc/uid/TP40007072-CH6">App-Related Resources</a>。</p><h2 id="Drawing-High-Resolution-Content-Using-OpenGL-ES-or-GLKit"><a href="#Drawing-High-Resolution-Content-Using-OpenGL-ES-or-GLKit" class="headerlink" title="Drawing High-Resolution Content Using OpenGL ES or GLKit"></a>Drawing High-Resolution Content Using OpenGL ES or GLKit</h2><p>ps:暂时没用到。不看</p><h1 id="Loading-Images"><a href="#Loading-Images" class="headerlink" title="Loading Images"></a>Loading Images</h1><p>出于功能和美学的原因，图像是 app 用户界面的普遍元素。 它们可以成为应用程序跟其他应用不同的关键因素。</p><p>应用程序使用的许多图像（包括启动图像和应用程序图标）都作为文件存储在应用程序的主程序包中。 可以启动特定于设备类型的图像和图标（iPad与iPhone和iPod touch），并针对高分辨率显示进行了优化。 可以在 <a href="https://developer.apple.com/library/archive/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007072">App Programming Guide for iOS</a> 的 <a href="https://developer.apple.com/library/archive/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/PerformanceTips/PerformanceTips.html#//apple_ref/doc/uid/TP40007072-CH7">Advanced App Tricks</a> 和 <a href="https://developer.apple.com/library/archive/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Inter-AppCommunication/Inter-AppCommunication.html#//apple_ref/doc/uid/TP40007072-CH6">App-Related Resources</a>中找到这些捆绑图像文件(bundled image files) 的完整描述。 “#Updating Your Image Resource Files#”讨论了使图像文件与高分辨率屏幕兼容的调整。</p><p>此外， iOS 还支持使用 UIKit 和 Core Graphics 框架加载和显示图像。 如何确定用于绘制图像的类和函数取决于您打算如何使用它们。 但是，只要有可能，建议使用 UIKit 类在代码中表示图像。 表C-1列出了一些使用方案以及处理它们的建议选项。</p><table><thead><tr><th>Scenario</th><th>Recommended usage</th></tr></thead><tbody><tr><td>Display an image as the content of a view</td><td>使用 UIImageView 类显示图像。 此选项假定视图的唯一内容是图像。 但仍然可以在图像视图的顶部层叠其他视图以绘制其他控件或内容。</td></tr><tr><td>Display an image as an adornment for part of a view</td><td>使用 UIImage 类加载并绘制图像。</td></tr><tr><td>Save some bitmap data into an image object</td><td>可以像在”#Creating New Images Using Bitmap Graphics Contexts#”中描述的 UIKit 函数或核心图形函数来执行此操作。</td></tr><tr><td>Save an image as a JPEG or PNG file</td><td>从原始图像数据创建 UIImage 对象。 调用<code>UIImageJPEGRepresentation</code> 或 <code>UIImagePNGRepresentation</code> 函数来获取NSData对象，并使用该对象的方法将数据保存到文件中。</td></tr></tbody></table><h2 id="System-Support-for-Images"><a href="#System-Support-for-Images" class="headerlink" title="System Support for Images"></a>System Support for Images</h2><p>UIKit 框架以及 iOS 的低级系统框架提供了创建，访问，绘图，编写和操作图像的广泛可能性。</p><h3 id="UIKit-Image-Classes-and-Functions"><a href="#UIKit-Image-Classes-and-Functions" class="headerlink" title="UIKit Image Classes and Functions"></a>UIKit Image Classes and Functions</h3><p>UIKit框架有三个类和一个协议，它们以某种方式与图像相关：</p><ul><li>UIImage (此类的对象表示 UIKit 框架中的图像。 可以从几个不同的源创建它们，包括文件和 Quartz 图像对象。<strong>该类的方法能够使用不同的混合模式(blend modes)和不透明度值(opacity values)将图像绘制到当前图形上下文</strong>。  UIImage 类自动处理任何所需的转换，例如应用适当的比例因子（考虑高分辨率显示），并且在给定 Quartz 图像时，修改图像的坐标系以使其与默认的坐标系匹配 UIKit(y起源位于左上角))</li><li>UIImageView (此类的对象是显示单个图像或为一系列图像设置动画的视图。 <strong>如果图像是视图的唯一内容，请使用 UIImageView 类而不是绘制图像</strong>。)</li><li>UIImagePickerController 和 UIImagePickerControllerDelegate (此类和协议为应用程序提供了获取用户提供的图像（照片）和视频的方法。 该类提供和管理用户界面，用于选择和拍摄 照片和视频。 当用户选择照片时，它会将选定的 UIImage 对象传递给委托，该委托必须实现协议方法。)</li></ul><p>除了这些类之外，UIKit 还声明了可以使用图像执行各种任务的函数：</p><ul><li>Drawing into an image-backed graphics context. (<code>UIGraphicsBeginImageContext</code> 函数创建一个屏幕外位图图形上下文。可以在此图形上下文中绘制，然后从中提取 UIImage 对象。 （有关其他信息，请参阅”#Drawing Images#”。）)</li><li>Getting or caching image data. (<strong>每个 UIImage 对象都有一个可以直接访问的支持 Core Graphics 图像对象(CGImageRef</strong>) (“backing Core Graphics image object (CGImageRef)”)。 然后，<strong>可以将 Core Graphics 对象传递给 Image I/O 框架以保存数据</strong>。 还可以通过调用 <code>UIImagePNGRepresentation</code> 或 <code>UIImageJPEGRepresentation</code> 函数将 UIImage 对象中的图像数据转换为 PNG 或 JPEG 格式。 然后，可以访问数据对象中的字节，并可以将图像数据写入文件。)</li><li>Writing an image to the Photo Album on a device. (调用 <code>UIImageWriteToSavedPhotosAlbum</code> 函数，传入UIImage对象，将该图像放入设备上的相册中。)</li></ul><p>“#Drawing Images#”标识了使用这些UIKit类和函数时的场景。</p><h3 id="Other-Image-Related-Frameworks"><a href="#Other-Image-Related-Frameworks" class="headerlink" title="Other Image-Related Frameworks"></a>Other Image-Related Frameworks</h3><p>可以使用除 UIKit 之外的多个系统框架来创建，访问，修改和写入图像。 如果发现无法使用 UIKit 方法或函数完成某个与图像相关的任务，则这些较低级别框架之一的功能可能能够执行您想要的操作。 其中一些功能可能需要 Core Graphics 图像对象（CGImageRef）。 可以通过 CGImage 属性访问支持 UIImage 对象的 CGImageRef 对象。</p><p>注意：如果存在 UIKit 方法或函数来完成给定的图像相关任务，则应使用它而不是任何相应的低级函数。</p><p>相关的框架有 </p><ul><li>Core Graphics framework</li><li>Image I/O framework (读取和写入各种图片格式。支持快速的编码、解码图片，图片元数据，图片缓存)</li><li>Assets Library </li></ul><h3 id="Supported-Image-Formats"><a href="#Supported-Image-Formats" class="headerlink" title="Supported Image Formats"></a>Supported Image Formats</h3><p>表C-2列出了 iOS 直接支持的图像格式。 在这些格式中，<strong>PNG 格式是最适合在您的应用中使用的格式</strong>。 通常，UIKit 支持的图像格式与 Image I/O 框架支持的格式相同。<br>(ps: 具体的看官方文档吧。)</p><h2 id="Maintaining-Image-Quality"><a href="#Maintaining-Image-Quality" class="headerlink" title="Maintaining Image Quality"></a>Maintaining Image Quality</h2><p>为用户界面提供高质量的图像应该是<strong>设计的首要任务</strong>。图像提供了一种显示复杂图形的合理有效方式，应该在适当的地方使用。为应用创建图片时，请牢记以下准则：</p><ul><li>Use the PNG format for images.   (使用PNG格式的图像。 <strong>PNG 格式提供无损图像内容，这意味着将图像数据保存为 PNG 格式然后将其读回会产生完全相同的像素值。 PNG 具有优化的存储格式，旨在更快地读取图像数据。它是 iOS 的首选图像格式</strong>。)</li><li>Create images so that they do not need resizing.  (创建图像，以便它们不需要调整大小。如果您计划使用特定大小的图像，请确保以该大小创建相应的图像资源。不要创建更大的图像并将其缩小以适应，<strong>因为缩放需要额外的 CPU 周期并需要插值。如果需要以可变大小显示图像，请包含不同大小的图像的多个版本，并从相对接近目标大小的图像缩小</strong>。)</li><li>Remove alpha channels from opaque PNG files.   (从不透明的 PNG 文件中删除 Alpha 通道。如果PNG 图像的每个像素都是不透明的，则删除 Alpha 通道可<strong>以避免混合包含该图像的图层。这大大简化了图像的合成，并提高了绘图性能。</strong>)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对官方文档&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/2DDrawing/Conceptual/DrawingPrintingiOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40010156-CH1-SW1&quot;&gt;Drawing and Printing Guide for iOS&lt;/a&gt;的一个翻译学习记录。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="AppleDocument" scheme="http://example.com/tags/AppleDocument/"/>
    
  </entry>
  
  <entry>
    <title>Practical Drawing for iOS Developers(Quartz 2D Programming Guide)</title>
    <link href="http://example.com/2019/02/24/wwdc-2011-129/"/>
    <id>http://example.com/2019/02/24/wwdc-2011-129/</id>
    <published>2019-02-24T08:40:43.000Z</published>
    <updated>2021-05-24T15:33:13.504Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WWDC"><a href="#WWDC" class="headerlink" title="WWDC"></a>WWDC</h1><p><a href="https://developer.apple.com/videos/play/wwdc2011/129/">Practical Drawing for iOS Developers</a>主要讲了怎样用 Core Graphic 相关 API ，开头讲了一些精美的App, eg:股市、天气、iBooks、YouTube 等等，着重讲怎么完成股市 App 的相关绘制效果：渐变背景、数据表格等，提到的相关技术点有</p> <a id="more"></a><ul><li>Gradient</li><li>Anti-aliasing</li><li>Path(filling clipping)</li><li>Shadow</li><li>Transparency Layers</li><li>UIImage draw</li><li>Pattern</li></ul><p>可以用来当查看手册，具体的可以看。效果如下：</p><p><img src="https://github.com/JoakimLiu/BlogPhoto/blob/master/wwdc/2011/129/prototype.png?raw=true" alt="App 效果"><br><img src="https://github.com/JoakimLiu/BlogPhoto/blob/master/wwdc/2011/129/result.png?raw=true" alt="demo 效果"></p><p>两种细节上差距还是很大的，但是 demo 已经把大致的效果给做出来了，这里就主要讲讲点和像素的关系。</p><p>先来说说 iOS 的坐标系，有三种</p><ul><li>drawing (user) coordinate system, 绘图坐标系，也就是 Core Graphic 发出绘制命令时的坐标系。</li><li>view coordinate system (base space), 视图坐标系，是相对于视图的固定坐标系。</li><li>(physical) device coordinate system, 设备坐标系，表示物理屏幕上的像素。</li></ul><p>绘图坐标系和视图坐标系都是逻辑坐标系，跟具体的设备没关系，它是抽象的，跟分辨率无关。我们绘制接触的是逻辑坐标系，以点表示(在开发中，10 个点的字体，44X44 的矩形是一个好的触摸大小)。那么从绘图坐标系怎么转换到设备坐标系呢？ Core Graphic 使用当前变换矩阵(CTM)来映射转换处理的。</p><h2 id="Points-vs-Pixels"><a href="#Points-vs-Pixels" class="headerlink" title="Points vs Pixels"></a>Points vs Pixels</h2><p><img src="https://github.com/JoakimLiu/BlogPhoto/blob/master/wwdc/2011/129/point.png?raw=true" alt="Points"></p><p>如上图所示，点是两条线的交点。上图宽两个点，从左边的那个到右边的那个点画一条线。（一个覆盖八个点，因为宽是两个点，横穿四个点）<br>在设备上，显示效果如下：</p><p><img src="https://github.com/JoakimLiu/BlogPhoto/blob/master/wwdc/2011/129/pixel.png?raw=true" alt="Pixels"><br>像素，它是物理的，如果它存在的话，就代表一个颜色值（不能代表多个颜色值）。在 Retina 屏幕上，一个点等于两个像素，所以总共覆盖 32 个像素。(ps: 这里的等于两个像素，还有另外一种说法一个点的面积，等于 <code>2*2=4</code> 个像素的面积，这样应该更直观些)</p><p>如果我们绘制一条宽为 1 point 的线条，上线两边各占 0.5 point, 在 retain 屏上显示就刚刚好，在 1 DPI 屏上，就会出现锯齿效果，因为只有一半的强度(不可能只渲染半个单元格撒)。为了防止这种问题出现，把点向上或者向下偏移 0.5 point(使得刚好占据一行 pixel) 。如果线宽是偶数，则不用去处理。</p><p>如果，那如果我们要在 retain 屏上绘制一条 1 pixel 的线呢？只需把线条宽度置为 0.5 point, 同时偏移 0.25 point 。(具体的看下面的图吧，自己动手画一下会清楚很多)<br>Q: 那在 plus 设备上绘制一条 1 pixel 的线呢？<br>A: 线条宽度置为 0.5 point ，同时偏移 1/(3*2) point 。</p><p><img src="https://developer.apple.com/library/archive/documentation/2DDrawing/Conceptual/DrawingPrintingiOS/Art/pixel_alignment_2x.png" alt="A one-point line centered at a whole-numbered point value"></p><p><img src="https://developer.apple.com/library/archive/documentation/2DDrawing/Conceptual/DrawingPrintingiOS/Art/regular_vs_retina_2x.png" alt="Appearance of one-point-wide lines on standard and retina displays"></p><p>注意，这些调整都是系统给我们调整的。如果在 xib 上设置 1 pixel 宽的线条，不起作用，请用纯代码设置。</p><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><ul><li>要在有 Context 的情况下，调用相关 Core Graphic API;</li><li>自己创建 Context 的方法有: CGBitmapContextCreate(没有自定义算法时，就使用) 和 UIGraphicsBeginImageContextWithOptions(当有自定义算法时，就使用)</li></ul><h1 id="Apple-Document"><a href="#Apple-Document" class="headerlink" title="Apple Document"></a>Apple Document</h1><p><a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007533-SW1">Quartz 2D Programming Guide</a></p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Core Graphics 就是 Quart 2D ，是一种先进的二维绘图引擎，可用于 iOS tvOS macOS 应用程序开发。 Quartz 2D 提供低级，轻量级 2D 渲染，无论显示器或打印设备如何，都具有无与伦比的<strong>输出保真度</strong>。 Quartz 2D 与分辨率和设备无关。</p><p>“The Quartz 2D API is easy to use and provides access to powerful features such as transparency layers, path-based drawing, offscreen rendering, advanced color management, anti-aliased rendering, and PDF document creation, display, and parsing.” Quartz 2D API 易于使用，并提供对强大功能的访问，如透明层，基于路径的绘图，离屏渲染，高级颜色管理，消除锯齿渲染以及 PDF 文档创建，显示和解析。</p><h2 id="Overview-of-Quartz-2D"><a href="#Overview-of-Quartz-2D" class="headerlink" title="Overview of Quartz 2D"></a>Overview of Quartz 2D</h2><p>Quartz 2D 提供的功能，上面有提到。 Quartz 2D <strong>尽可能利用图形硬件的强大功能</strong>。 在 iOS 中，它可与所有可用的图形和动画技术<strong>配合使用</strong>，例如 Core Animation, OpenGL ES 和 UIKit 类。</p><h3 id="The-Page"><a href="#The-Page" class="headerlink" title="The Page"></a>The Page</h3><p>Quartz 2D 使用 painter’s model 进行成像。 在 painter’s model 中，<strong>每个连续的绘图操作都将一层“绘画”应用于输出“画布”，通常称为页面</strong>。 可以通过在其他绘图操作中<strong>覆盖</strong>更多绘制来修改页面上的绘制。 <strong>除非覆盖，否则无法</strong>修改页面上绘制的对象。 此模型允许从少量强大的基元构造极其复杂的图像。(ps: 覆盖到画布上，来修改不同的内容)</p><p><img src="https://sat02pap001files.storage.live.com/y4m09EaZfyl4a12xDCRUouRvuS31G5q-nJsojzx7VFcwTqxbMTgPaPHxxVcapC2gWuE5xzC3EhnxuZC7_7-GlGnclxRLS0De_NlwHR0ulsO_xlZe3FKaNFFeGIF_oKwKROT7bQZ2k7sRRADtbu_1xJjQBe0-1KWxWe0xVIPM0D4Rxa5S3aKrItgh8I_DKMZpHba?width=318&height=344&cropmode=none" alt="The painter’s model"><br>上图展示了不同绘制顺序的不同结果。</p><p>页面可以是真正的纸张（如果输出设备是打印机）； 它可能是一张虚拟纸（如果输出设备是PDF文件）；它甚至可能是位图图像。 页面的性质<strong>取决于使用的特定图形上下文</strong>。 (ps: 应该就算后面说的 destination 吧)。</p><h3 id="Drawing-Destinations-The-Graphics-Context"><a href="#Drawing-Destinations-The-Graphics-Context" class="headerlink" title="Drawing Destinations: The Graphics Context"></a>Drawing Destinations: The Graphics Context</h3><p>图形上下文是一种不透明的数据类型(CGContextRef)，它封装了 Quartz <strong>用于将图像绘制到输出设备的信息</strong>，例如 PDF 文件，位图或显示器上的窗口。 图形上下文中的信息<strong>包括</strong>图形绘制参数和页面上绘制的设备特定表示。Quartz 中的<strong>所有对象都被</strong>绘制到图形上下文中。</p><p>可以将图形上下文视为绘图目标。</p><p><img src="https://sat02pap001files.storage.live.com/y4mjcewn8vKvFJCYuRm3ANl-8OQPzL_SV8KiMUJZ_Ls00TU8awIvwJP1yichqZPLN8X0pbM9Hyf0vIEiJTZqIGhEDAs5nSl0LQP1TRr9yYPCRlKRu4qUXBtEhgnCSeoVNeDReJNJzvK-njU9SrIkjGhrfSspv7HmpbZYhRSLY-5ElFNGtbnal88dGZSNim0q45a?width=404&height=384&cropmode=none" alt="Quartz drawing destinations"><br>上图展示了，通过为相同的 Quartz 绘图例程序列<strong>提供不同的</strong>图形上下文，将相同的图像绘制到不同的设备；并且无需执行任何特定于设备的计算，Quartz 都做了。</p><p>以下这些图形上下文可供应用程序使用：</p><ul><li>bitmap graphics context(位图图形上下文), 允许将 RGB 颜色， CMYK 颜色或灰度绘制到位图中。<strong>位图是像素的矩形阵列（或光栅），每个像素表示图像中的点</strong>。位图图像也称为采样图像。请参阅”#Creating a Bitmap Graphics Context#”。</li><li>PDF graphics context (PDF图形上下文)， 允许创建PDF文件。具体的看 “#Creating a PDF Graphics Context#” </li><li>window graphics context(窗口图形上下文), 是可用于绘制到窗口中的图形上下文。 具体的看 “#Creating a Window Graphics Context in Mac OS X#”</li><li>layer context(图层上下文), 它是与另一个图形上下文关联的<strong>屏幕外(offscreen drawing)**绘图目标。它旨在将图层绘制到它创建的图形上下文时获得</strong>最佳性能<strong>。与位图图形上下文相比，图层上下文可以是</strong>屏幕外绘制的更好选择**。请参阅”# Core Graphics Layer Drawing#”。</li><li>PostScript graphics context, OS X 上打印会用到的。</li></ul><h3 id="Quartz-2D-Opaque-Data-Types"><a href="#Quartz-2D-Opaque-Data-Types" class="headerlink" title="Quartz 2D Opaque Data Types"></a>Quartz 2D Opaque Data Types</h3><p>除了图形上下文之外， Quartz 2D API 还定义了各种不透明数据类型。由于 API 是 Core Graphics 框架的一部分，因此数据类型和对它们进行操作的例程(routine)<strong>使用 CG 前缀</strong>。 Quartz 2D 从应用程序操作的不透明数据类型创建对象，以实现特定的绘图输出。<br>并且例举了它提供的不透明数据类型，包括<strong>相关内容</strong>：(ps: 有需要的时候，具体再看)</p><h3 id="Graphics-States"><a href="#Graphics-States" class="headerlink" title="Graphics States"></a>Graphics States</h3><p>Quartz <strong>根据当前图形状态中的参数修改绘制操作的结果</strong>。图形状态(graphics state)包含参数，然后这些参数将作为绘图例程的参数。绘制到图形上下文的例程<strong>会查询图形状态</strong>以确定如何呈现其结果。</p><p>图形上下文包含一堆图形状态。当 Quartz 创建图形上下文时，堆栈为空。保存图形状态时， Quartz 会将当前图形状态的<strong>副本推送到</strong>堆栈中。当恢复图形状态时， Quartz 会将图形状态从堆栈顶部弹出，弹出状态变为当前图形状态。保存用 CGContextSaveGState ，恢复用 CGContextRestoreGState 。</p><p>请注意，<strong>并非</strong>当前绘图环境的所有方面<strong>都是</strong>图形状态的元素。例如，the current path 就不是。 具体的请看文档的 “Parameters that are associated with the graphics state” 。</p><h3 id="Quartz-2D-Coordinate-Systems"><a href="#Quartz-2D-Coordinate-Systems" class="headerlink" title="Quartz 2D Coordinate Systems"></a>Quartz 2D Coordinate Systems</h3><p>可以在<strong>用户空间</strong>(user space)坐标系中指定图形的位置和大小。 坐标定义为浮点值。</p><p>Quartz 2D 的坐标系和 UIKit 中的还是有区别的， y 轴刚好相反。<br><img src="https://sat02pap001files.storage.live.com/y4m-Sn6xHEpozjGpIMFOk0O_k0YnYXlEmgzUWN3B63GuHsuT8-xr4P3m35ofo0uWQ9qtY3d3qrpigZN6CPELWHrIr_8Ii1P21d7NJbqqapBCdjoQuVLcqkN2pIC16y8frZOwAFF_VG7UvZ6WDywfvVELyb4H6upEibwe7F-A5KzxXHMJLyPP8E9FyPohC2OumSN?width=235&height=168&cropmode=none" alt="The Quartz coordinate system"></p><p>由于不同的设备具有不同的底层成像功能，因此必须<strong>以与设备无关的方式</strong>定义图形的位置和大小。例如，屏幕显示设备可能能够显示每英寸不超过 96 个像素，而打印机可能能够显示每英寸300个像素。如果在设备级别定义坐标系（在此示例中为 96 像素或 300 像素），则在该空间中绘制的对象无法在其他设备上重现，而不会出现可见的失真。它们看起来太大或太小。</p><p>Quartz 使用单独的坐标系 - 用户空间 - <strong>使用当前变换矩阵或 CTM 将其映射到输出设备</strong> - 设备空间的坐标系来实现设备独立性。<strong>矩阵是</strong>用于有效地描述一组相关方程的数学构造。当前变换矩阵(CTM)是称为仿射变换的特定类型的矩阵，其通过应用平移，旋转和缩放操作（移动，旋转和调整坐标系的大小的计算）将点从一个坐标空间映射到另一个坐标空间。</p><p>一些技术使用与 Quartz 使用的默认坐标系<strong>不同的默认坐标系</strong>来设置其图形上下文。相对于 Quartz ，这样的坐标系是一个<strong>修改过的</strong>坐标系，<strong>必须在执行某些 Quartz 绘图操作时进行补偿</strong>。最常见的修改坐标系将原点放置在上下文的左上角，并将 y 轴更改为指向页面底部。可能会看到使用此特定坐标系的几个地方如下：</p><ul><li>在Mac OS X中，NSView的子类重写其isFlipped方法以返回YES。</li><li>在 iOS 中，由 UIView 返回的绘图上下文。</li><li>在 iOS 中，通过调用 UIGraphicsBeginImageContextWithOptions 函数创建的绘图上下文。</li></ul><p>如果应用程序想要使用相同的绘图例程来绘制 UIView 对象和 PDF 图形上下文（由 Quartz 创建并使用默认坐标系），则需要应用变换以便 PDF 图形上下文接收相同的修改坐标系。要执行此操作，请应用将原点转换为 PDF 上下文左上角的变换，并将 y 坐标缩放 -1 。翻转的效果如下图所示，就像镜子反射一样。</p><p><img src="https://sat02pap001files.storage.live.com/y4mz9gVYtX2Pjghad-RtThLzTNLE9Qtfit0it5i0rLbCKzjR_MA2w-qwaIxJ45YNsCCH51U70-EeFEXJy-UkfkzQMTYU3mWDCyD-JWYAPSzay1KT9XiC-EWMGAi5Seys78T2y5zQyqVbEopUPiPiG8O2q6avic1GPw7ygt8_nx2rQy9-Hl5IdhlWByckxkwddB4?width=509&height=202&cropmode=none" alt="Modifying the coordinate system creates a mirrored image"></p><p>应用程序可以<strong>调整</strong>它对已应用转换的上下文进行的任何 Quartz 调用。 例如，如果要将图像或 PDF 正确绘制到图形上下文中，则应用程序可能<strong>需要临时</strong>调整图形上下文的 CTM 。 在 iOS 中，如果使用 UIImage 对象来包装创建的 CGImage 对象，则<strong>无需修改CTM</strong>。 UIImage 对象<strong>自动补偿</strong> UIKit 应用的修改坐标系。 (ps: 在不同坐标系下使用相同绘制例程时，要记得处理坐标系补偿，当然用 UIKit 的相应类是不需要的，因为它会自动帮你处理。)</p><p>重要提示：当 UIKit 为应用程序创建绘图上下文时，它还是会对上下文进行其他更改以匹配默认的 UIKit 约定。<strong>但是</strong>， patterns 和 shadows, 不受 CTM 的影响，所以还是得自己处理来匹配。</p><h3 id="Memory-Management-Object-Ownership"><a href="#Memory-Management-Object-Ownership" class="headerlink" title="Memory Management: Object Ownership"></a>Memory Management: Object Ownership</h3><p>Quartz 使用 Core Foundation 内存管理模型，其中对象被<strong>引用计数</strong>。 </p><h2 id="Graphics-Contexts"><a href="#Graphics-Contexts" class="headerlink" title="Graphics Contexts"></a>Graphics Contexts</h2><p>图形上下文表示绘图目标。图形上下文定义了基本的绘图属性，例如绘图时使用的颜色，剪裁区域，线宽和样式信息，字体信息，合成选项以及其他几种。</p><p>可以使用 Quartz 上下文创建函数或使用 iOS 和 Mac OS 里面相关框架提供的更高级别函数来获取图形上下文。 Quartz 提供各种 Quartz 图形上下文的功能，包括位图和 PDF, 可以使用它们来创建自定义内容。</p><p>本章介绍如何为各种绘图目标创建图形上下文。图形上下文在代码中由数据类型 <strong>CGContextRef</strong> 表示，它是一种不透明的数据类型。<strong>获取</strong>图形上下文后，可以使用 Quartz 2D 函数<strong>绘制上下文</strong>，对上下文执行操作（如位移），以及更改图形状态参数，如线宽和填充颜色。</p><h3 id="Drawing-to-a-View-Graphics-Context-in-iOS"><a href="#Drawing-to-a-View-Graphics-Context-in-iOS" class="headerlink" title="Drawing to a View Graphics Context in iOS"></a>Drawing to a View Graphics Context in iOS</h3><p>要在 iOS 应用程序中绘制到屏幕，请设置 UIView 对象并实现其 <code>drawRect:</code> 方法以执行绘图。<strong>当视图在屏幕上可见并且其内容需要更新时</strong>，将调用视图的 <code>drawRect:</code> 方法。在调用自定义 <code>drawRect:</code> 方法之前，视图对象(UIView object)<strong>会自动</strong>配置其绘图环境，以便代码可以立即开始绘制。作为此配置的一部分， UIView 对象为当前绘图环境<strong>创建</strong>图形上下文（CGContextRef opaque类型）。可以通过调用 UIKit 函数 UIGraphicsGetCurrentContext 在 <code>drawRect:</code> 方法中获取此图形上下文。</p><p>整个 UIKit 使用的默认坐标系与 Quartz 使用的坐标系不同。在 UIKit 中，原点位于左上角，正 y 值指向下方。 UIView 对象通过将原点转换为视图的左上角，并通过将其乘以 -1 来反转 y 轴，来修改 Quartz 图形上下文的 CTM 以匹配 UIKit 约定。有关修改坐标系的更多信息以及自己的绘图代码中的含义，请参阅”#Quartz 2D Coordinate Systems#”。</p><p>UIView 对象在 <a href="https://developer.apple.com/library/archive/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009503">View Programming Guide for iOS</a> 中有详细描述。</p><h3 id="Creating-a-Window-Graphics-Context-in-Mac-OS-X"><a href="#Creating-a-Window-Graphics-Context-in-Mac-OS-X" class="headerlink" title="Creating a Window Graphics Context in Mac OS X"></a>Creating a Window Graphics Context in Mac OS X</h3><p>先不管。</p><h3 id="Creating-a-PDF-Graphics-Context"><a href="#Creating-a-PDF-Graphics-Context" class="headerlink" title="Creating a PDF Graphics Context"></a>Creating a PDF Graphics Context</h3><p>先不管。</p><h3 id="Creating-a-Bitmap-Graphics-Context"><a href="#Creating-a-Bitmap-Graphics-Context" class="headerlink" title="Creating a Bitmap Graphics Context"></a>Creating a Bitmap Graphics Context</h3><p>位图图形上下文接收 指向<strong>包含</strong>位图存储空间的<strong>内存缓冲区</strong>的 指针。 当绘制到位图图形上下文时，缓冲区会更新。 释放图形上下文后，将<strong>以指定的像素格式获得完全更新的位图</strong>。</p><p>注意：位图图形上下文有时用于绘制屏幕外。在决定使用位图图形上下文之前，请参阅”#Core Graphics Layer Drawing#”。 CGLayer对象（CGLayerRef）针对屏幕外绘制进行了优化，因为只要有可能， Quartz 就会在 video card 上缓存图层。</p><p>iOS注意： iOS 应用程序<strong>应该使用</strong>函数 UIGraphicsBeginImageContextWithOptions <strong>而不是</strong>使用此处描述的低级 Quartz 函数。如果应用程序使用 Quartz 创建一个屏幕外位图，则位图图形上下文使用的坐标系是<strong>默认的</strong> Quartz 坐标系。相反，如果应用程序通过调用函数 UIGraphicsBeginImageContextWithOptions 来创建图像上下文，则 UIKit 将相同的变换应用于上下文的坐标系，就像对 UIView 对象的图形上下文一样。这允许应用程序使用相同的绘图代码，而无需担心不同的坐标系。虽然应用程序可以手动调整坐标转换矩阵以获得正确的结果，但实际上，这样做没有性能优势。(ps: 手动转换坐标系，虽然可以，但是没有性能优势。)</p><p>可以使用函数 CGBitmapContextCreate 来创建位图图形上下文。此函数采用以下参数：</p><ul><li>data. 在内存中提供指向要渲染图形的目标的指针。此内存块的大小应至少为 (bytesPerRow * height) 字节(bytes)</li><li>width. 指定位图的宽度（以像素为单位）。</li><li>height. 指定位图的高度（以像素为单位）。</li><li>bitsPerComponent. 指定内存中像素的每个组件<strong>使用的位数</strong> 。 例如，对于 32 位像素格式和 RGB 颜色空间，可以为每个组件指定 8 位的(bitsPerComponent = 8)值。请参阅”#Supported Pixel Formats#”。</li><li>bytesPerRow. 指定每行位图使用的内存字节数。 提示：创建位图图形上下文时，如果<strong>确保</strong>数据和 bytesPerRow 是 16 字节对齐，则可以<strong>获得最佳性能</strong>。 </li><li>colorspace. 用于位图上下文的颜色空间。创建位图图形上下文时，可以提供灰色，RGB，CMYK或NULL颜色空间。(ps: 官方文档有讲很多用到颜色什么的，请参阅哪里哪里，具体的看官方文档吧)</li><li>bitmapInfo. 指定位图是否应包含 alpha 组件，像素中 alpha 组件（如果有）的相对位置，alpha 组件是否预乘，以及颜色分量是整数或浮点值。</li></ul><p>这里也有代码讲怎么样创建位图上下文(见下面) 和 怎么绘制到该位图上下文(去看文档)，重要的代码都有讲解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Creating a bitmap graphics context</span><br><span class="line"></span><br><span class="line">CGContextRef MyCreateBitmapContext (int pixelsWide,</span><br><span class="line">                            int pixelsHigh)</span><br><span class="line">&#123;</span><br><span class="line">    CGContextRef    context &#x3D; NULL;</span><br><span class="line">    CGColorSpaceRef colorSpace;</span><br><span class="line">    void *          bitmapData;</span><br><span class="line">    int             bitmapByteCount;</span><br><span class="line">    int             bitmapBytesPerRow;</span><br><span class="line"> </span><br><span class="line">    bitmapBytesPerRow   &#x3D; (pixelsWide * 4); &#x2F;&#x2F;  1 声明一个变量来表示每行的字节数。 本例中位图中的每个像素由4个字节(byte)表示; 红色，绿色，蓝色和 alpha 各 8 位(bit)。</span><br><span class="line">    bitmapByteCount     &#x3D; (bitmapBytesPerRow * pixelsHigh); &#x2F;&#x2F; 总的字节数</span><br><span class="line"> </span><br><span class="line">    colorSpace &#x3D; CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB);&#x2F;&#x2F; 2 颜色空间</span><br><span class="line">    bitmapData &#x3D; calloc(bitmapByteCount, sizeof(uint8_t));&#x2F;&#x2F; 3 调用calloc函数来创建和清除用于存储位图数据的内存块。 此示例创建一个 32 位 RGBA 位图（即每像素 32 位的数组，每个像素包含红色，绿色，蓝色和 alpha 信息各 8 位 (4*8&#x3D;32)）。 位图中的每个像素占用4个字节的内存。 在Mac OS X 10.6和iOS 4中，可以省略此步骤 - 如果将NULL作为位图数据传递，Quartz会自动为位图分配空间。</span><br><span class="line">    if (bitmapData &#x3D;&#x3D; NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf (stderr, &quot;Memory not allocated!&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    context &#x3D; CGBitmapContextCreate (bitmapData,&#x2F;&#x2F; 4</span><br><span class="line">                                    pixelsWide,</span><br><span class="line">                                    pixelsHigh,</span><br><span class="line">                                    8,      &#x2F;&#x2F; bits per component</span><br><span class="line">                                    bitmapBytesPerRow,</span><br><span class="line">                                    colorSpace,</span><br><span class="line">                                    kCGImageAlphaPremultipliedLast); &#x2F;&#x2F; 常量 kCGImageAlphaPremultipliedLast 表示 alpha 组件存储在每个像素的最后一个字节中，并且颜色组件已经乘以此 alpha 值。 有关预乘 alpha 的更多信息，请参阅&quot;#The Alpha Value#&quot;。</span><br><span class="line">    if (context&#x3D;&#x3D; NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        free (bitmapData);&#x2F;&#x2F; 5</span><br><span class="line">        fprintf (stderr, &quot;Context not created!&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    CGColorSpaceRelease(colorSpace);&#x2F;&#x2F; 6</span><br><span class="line"> </span><br><span class="line">    return context;</span><br></pre></td></tr></table></figure><h4 id="Supported-Pixel-Formats"><a href="#Supported-Pixel-Formats" class="headerlink" title="Supported Pixel Formats"></a>Supported Pixel Formats</h4><p>文档上有一个表，记录了不同颜色空间(color space, cs)下，像素格式的 bits per pixel (bpp) 和 bits per component (bpc) 和 bitmap information constant 。</p><h4 id="Anti-Aliasing"><a href="#Anti-Aliasing" class="headerlink" title="Anti-Aliasing"></a>Anti-Aliasing</h4><p>位图图形上下文支持抗锯齿(anti-aliasing)，这是<strong>人工校正</strong>在绘制文本或形状时有时在位图图像中看到的锯齿(jagged or aliased)边缘的过程。<br>当位图的分辨率明显<strong>低于眼睛的分辨率时</strong>，会出现这些锯齿状边缘。为了使对象在位图中显得平滑，Quartz <strong>对</strong>围绕形状轮廓的像素使用不同的颜色。通过以这种方式混合颜色，形状看起来光滑。可以在下图中看到使用抗锯齿的效果。可以通过调用 CGContextSetShouldAntialias 函数来关闭<strong>特定</strong>位图图形上下文的抗锯齿。抗锯齿设置<strong>是</strong>图形状态的一部分。</p><p>可以使用 CGContextSetAllowsAntialiasing 函数控制<strong>是否允许</strong>特定图形上下文的抗锯齿。 传 true 允许抗锯齿，反之则不允许。 此设置不是图形状态的一部分。当上下文和图形状态设置设置为 true 时， Quartz 会执行消除锯齿。 </p><p><img src="https://sat02pap001files.storage.live.com/y4mvL9zxZfXLveK3GYqwqGPIOwAFtAky2W0xYzzdgl2UHkBmOFA0PfbXTgJfYagDkssKFPKAvaq6mp8KDJRmxez3R1CtRavG2ryTtrVjgV5xVZW-VHB-umAjTS1o7HwbqAzMDnB9IW8gUgBmJd1ZaycHi1ijfYdtytwBdRicFEpCFLQU1Hb1w-bq6mC90hJIk-y?width=414&height=435&cropmode=none" alt="A comparison of aliased and anti-aliasing drawing"></p><h3 id="Obtaining-a-Graphics-Context-for-Printing"><a href="#Obtaining-a-Graphics-Context-for-Printing" class="headerlink" title="Obtaining a Graphics Context for Printing"></a>Obtaining a Graphics Context for Printing</h3><p>OS X 先不管。</p><h2 id="Paths"><a href="#Paths" class="headerlink" title="Paths"></a>Paths</h2><p>路径(path)定义一个或多个形状(shapes)或子路径(subpaths)。 子路径可以由直线，曲线或两者组成。 它可以是开放的(open)或封闭(closed)的。 子路径可以是简单的形状，例如线，圆，矩形或星形，或更复杂的形状，例如山脉的轮廓(silhouette)或抽象涂鸦(doodle)。 下图显示了可以创建的一些路径。 直线（图中左上角）是虚线; 线条也可以是实心的。 波浪形的路径（在中间的顶部）由几条曲线组成，是一条开放的路径。 同心圆被填充，但没有被描边。 加利福尼亚州是一条封闭的道路，由许多曲线和线条组成，路径既有条纹也有填充。 星星说明了填充路径的两个选项，将在本章后面阅读这些选项。</p><p><img src="https://sat02pap001files.storage.live.com/y4m06v4jCo05x0Kcs5NmUz8G-UzCnsF5514ND7mInesSblBX8F7-VU0l2-il6UajOIO_-Pg5zzEqwcRd9y-Hpq5zRQI2yN6vC8ugzwhdOvrWGK3tCx4dg3i_kL0h4GWxSADBnyu2o5HRWAzOvZ6CD6ABiLMH17fl3q4fbrkLH5l0V42Pze04ZTFm6VwWBeV0gzO?width=309&height=224&cropmode=none" alt="Quartz supports path-based drawing"></p><h3 id="Path-Creation-and-Path-Painting"><a href="#Path-Creation-and-Path-Painting" class="headerlink" title="Path Creation and Path Painting"></a>Path Creation and Path Painting</h3><p>路径创建和路径绘制<strong>是单独的任务</strong>。 首先，创建一个路径。 当想要渲染路径时，请求 Quartz 去绘制它。</p><ul><li>stroke: 描边</li><li>fill: 填充</li></ul><h3 id="The-Building-Blocks"><a href="#The-Building-Blocks" class="headerlink" title="The Building Blocks"></a>The Building Blocks</h3><p>子路径由线，弧和曲线构成。 Quartz 还提供了便捷功能，可通过单个函数调用添加矩形和椭圆。 点也是路径的基本构建块，因为点定义了形状的起始和结束位置。</p><h4 id="Points"><a href="#Points" class="headerlink" title="Points"></a>Points</h4><p>点是 x 和 y 坐标，用于指定用户空间中的位置。 可以调用函数 CGContextMoveToPoint 来<strong>指定</strong>新子路径的起始位置。 Quartz <strong>跟踪当前点</strong>，这是用于路径构建的<strong>最后位置</strong>。</p><h4 id="Lines"><a href="#Lines" class="headerlink" title="Lines"></a>Lines</h4><p>一条线由其终点定义。 它的起始点始终假定为当前点，因此在创建线时，只指定其终点。 使用函数 CGContextAddLineToPoint 将单行附加到子路径。 可以通过调用函数 CGContextAddLines 将一系列连接的行添加到路径中。将此函数传递给一系列点。 第一点<strong>必须是</strong>第一行的起点; 剩下的点是终点。</p><h4 id="Arcs"><a href="#Arcs" class="headerlink" title="Arcs"></a>Arcs</h4><p>弧是圆弧段。  Quartz提供了两个创建弧的函数。(ps: 具体的见官方文档，都有图说明)</p><ul><li>CGContextAddArc, 从圆创建一个曲线段。 可以指定圆的中心，半径和径向角（以弧度表示）。</li><li>CGContextAddArcToPoint, 圆角矩形的理想选择。</li></ul><p>如果当前路径已包含子路径，则 Quartz 会将当前点的直线段附加到弧的起始点。 如果当前路径为空，Quartz 会在弧的起始点创建一个新的子路径，并且不会添加初始直线段。</p><h4 id="Curves"><a href="#Curves" class="headerlink" title="Curves"></a>Curves</h4><p>二次(Quadratic)和三次(cubic)贝塞尔曲线是代数曲线，可以指定任意数量的有趣曲线形状。函数有 CGContextAddCurveToPoint 和 CGContextAddQuadCurveToPoint 。 (ps: 具体的见官方文档，都有图说明)</p><h4 id="Closing-a-Subpath"><a href="#Closing-a-Subpath" class="headerlink" title="Closing a Subpath"></a>Closing a Subpath</h4><p>要关闭当前子路径，应用程序应调用 CGContextClosePath 。 此函数添加从当前点到子路径<strong>起点的线段</strong>并关闭子路径。 以子路径起点结束的直线，圆弧和曲线实际上<strong>不会</strong>关闭子路径。 必须显式调用 CGContextClosePath 才能关闭子路径。</p><p>关闭子路径后，如果应用程序进行额外调用以向路径添加直线，圆弧或曲线，Quartz 将从刚刚关闭的子路径的起点开始一个新的子路径。 所有移动都以顺时针(clockwise)方向定向。</p><h4 id="Ellipses"><a href="#Ellipses" class="headerlink" title="Ellipses"></a>Ellipses</h4><p>椭圆基本上是一个压扁的圆。 CGContextAddEllipseInRect 函数。 所有移动都以逆时针(counter-clockwise)方向定向。</p><h4 id="Rectangles"><a href="#Rectangles" class="headerlink" title="Rectangles"></a>Rectangles</h4><p>可以通过调用函数 CGContextAddRect 将矩形添加到当前路径。 </p><h3 id="Creating-a-Path"><a href="#Creating-a-Path" class="headerlink" title="Creating a Path"></a>Creating a Path</h3><p>如果要在图形上下文中构造路径，可以通过调用函数 CGContextBeginPath 来发出 Quartz 信号。 接下来，通过调用函数 CGContextMoveToPoint ，在路径中设置第一个形状或子路径的起点。 建立第一个点后，可以在路径中添加直线，圆弧和曲线，请记住以下内容：(ps: 具体的见官方文档，这里只讲了最重要的。)</p><ul><li>……</li><li><strong>必须</strong>调用绘制函数来填充或描边路径，因为<strong>创建路径不会绘制路径</strong>。有关详细信息，请参阅”#Painting a Path#”。</li></ul><p>绘制路径后，将从图形上下文中刷新(flush)它。可能不希望如此轻易地<strong>丢失</strong>路径，特别是如果它描绘了想要反复使用的复杂场景。因此， Quartz 提供了两种用于<strong>创建可重用路径</strong>的数据类型 CGPathRef 和 CGMutablePathRef 。  Quartz 提供了一组 CGPath 函数，这些函数与”#The Building Blocks#”中讨论的相关函数并行 。路径函数在 CGPath 对象上运行，而不是在图形上下文上运行。(ps: 具体的相关函数见官方文档)</p><p>如果要将路径附加到图形上下文，请调用函数 CGContextAddPath 。路径保留在图形上下文中，直到 Quartz 绘制它。可以通过调用 CGContextAddPath 再次添加路径。</p><p>注意：可以通过调用函数 CGContextReplacePathWithStrokedPath 将图形上下文中的路径替换为路径的描边版本。</p><h3 id="Painting-a-Path"><a href="#Painting-a-Path" class="headerlink" title="Painting a Path"></a>Painting a Path</h3><p>可以通过描边或填充或两者来绘制当前路径。 描边画一条跨越路径的线。 填充绘制路径中包含的区域。 Quartz 具有允许描边路径，填充路径或者描边和填充路径的功能。 描边线的特征（宽度，颜色等），填充颜色以及 Quartz 用于计算填充区域的方法都是图形状态的一部分（参见”#Graphics States#”）。</p><h4 id="Parameters-That-Affect-Stroking"><a href="#Parameters-That-Affect-Stroking" class="headerlink" title="Parameters That Affect Stroking"></a>Parameters That Affect Stroking</h4><p>可以通过修改表3-1中列出的参数来影响路径的描述方式。 这些参数是<strong>图形状态</strong>的一部分，这<strong>意味着</strong>为参数设置的值<strong>会影响所有后续描边，直到将参数设置为另一个值</strong>。参数有：</p><ul><li>Line width</li><li>Line join</li><li>Line cap</li><li>Miter limit</li><li>Line dash pattern</li><li>Stroke color space</li><li>Stroke color</li><li>Stroke pattern</li></ul><p>(ps: 具体的详情就看官方文档吧)</p><h4 id="Functions-for-Stroking-a-Path"><a href="#Functions-for-Stroking-a-Path" class="headerlink" title="Functions for Stroking a Path"></a>Functions for Stroking a Path</h4><p>Quartz提供表3-4中所示的功能，用于描绘当前路径。 一些是用于描边矩形或椭圆的便利功能。<br>(ps: 具体的详情就看官方文档吧) </p><h4 id="Filling-a-Path"><a href="#Filling-a-Path" class="headerlink" title="Filling a Path"></a>Filling a Path</h4><p>填充当前路径时， Quartz 就像关闭路径中包含的每个子路径一样处理。 然后它使用这些封闭的子路径并计算要填充的像素。 Quartz 可以通过两种方式计算填充区域。 椭圆形和矩形等简单路径具有明确的区域。 但是，如果路径由重叠的段组成，或者路径包含多个子路径，例如图3-12中所示的同心圆，则可以使用两个规则来确定填充区域。</p><ul><li>nonzero winding number rule</li><li>even-odd rule</li></ul><p>(ps: 具体的详情就看官方文档吧) </p><h4 id="Setting-Blend-Modes"><a href="#Setting-Blend-Modes" class="headerlink" title="Setting Blend Modes"></a>Setting Blend Modes</h4><p>混合模式指定 Quartz如 何在背景上应用绘画。 Quartz 默认使用普通混合模式，它使用以下公式将前景绘画与背景绘画相结合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result &#x3D; (alpha * foreground) + (1 - alpha) * background</span><br></pre></td></tr></table></figure><p>“#Color and Color Spaces#”提供了颜色的 alpha 组件的详细讨论，它指定颜色的不透明度。 对于本节中的示例，可以假设颜色完全不透明（alpha = 1.0）。 对于不透明的颜色，当使用普通混合模式进行绘制时，在背景上绘制的任何内容都会完全遮盖背景。</p><p>(ps: 具体的详情就看官方文档吧，每种不同的混合模式，都有例子说明)</p><h3 id="Clipping-to-a-Path"><a href="#Clipping-to-a-Path" class="headerlink" title="Clipping to a Path"></a>Clipping to a Path</h3><p>当前剪切区域(current clipping area)是从<strong>用作蒙版(mask)**的路径创建的，允许阻止不想绘制的页面部分。例如，如果有一个非常大的位图图像并且</strong>只想**显示它的一小部分，则可以将剪切区域设置为仅显示想要显示的部分。</p><p>绘制时， Quartz <strong>仅在剪切区域内</strong>渲染绘制。在剪切区域的封闭子路径内发生的绘制是可见的；在剪切区域的闭合子路径之外发生的绘制不是。</p><p>当<strong>最初创建</strong>图形上下文时，剪切区域包括上下文的<strong>所有</strong>可绘制区域（例如，PDF上下文的媒体框）。可以通过设置当前路径，然后使用剪切功能而不是绘图功能<strong>来更改</strong>剪切区域。剪切功能将当前路径的填充区域与现有剪切区域<strong>相交</strong>。因此，可以与剪切区域相交，缩小图片的可见区域，但<strong>不能增加</strong>剪裁区域的面积。</p><p>(ps: 具体的详情就看官方文档吧)</p><h1 id="Color-and-Color-Spaces"><a href="#Color-and-Color-Spaces" class="headerlink" title="Color and Color Spaces"></a>Color and Color Spaces</h1><p>设备（显示器，打印机，扫描仪，照相机）<strong>不会以</strong>同样的方式处理颜色，每个都有自己的颜色范围。 在一台设备上生成的颜色<strong>可能无法在其</strong>他设备上生成。</p><p>要有效地处理颜色并理解使用颜色空间和颜色的 Quartz 2D 函数，应该熟悉<a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/csintro/csintro_intro/csintro_intro.html#//apple_ref/doc/uid/TP30001148">Color Management Overview</a>中讨论的术语。 该文档讨论了颜色感知(perception)，颜色值，设备无关和设备颜色空间，颜色匹配问题，渲染意图(rendering intent)，颜色管理模块和ColorSync。</p><h2 id="About-Color-and-Color-Spaces"><a href="#About-Color-and-Color-Spaces" class="headerlink" title="About Color and Color Spaces"></a>About Color and Color Spaces</h2><p>Quartz 中的颜色由一组值表示。 <strong>没有指示如何解释颜色信息的颜色空间，这些值是没有意义的</strong>。 例如，表4-1中的值均表示全强度时的蓝色。 但是，如果不知道每个颜色空间的颜色空间或允许的值范围，无法知道每组值所代表的颜色。</p><h2 id="The-Alpha-Value"><a href="#The-Alpha-Value" class="headerlink" title="The Alpha Value"></a>The Alpha Value</h2><p>alpha 值是 Quartz 用于确定<strong>如何将</strong>新绘制的对象<strong>合成到</strong>现有页面的图形状态参数。 在完全强度下，新绘制的物体是不透明的。 在零强度下，新绘制的对象是不可见的。</p><p><img src="https://sat02pap001files.storage.live.com/y4m4tgtfv2Ep9qCSSBKHjTd1rxkJQIKBvtspAp3CbH9oWN-y9cX5WA5K4_9hUsIW4xUPA2Mv0bI1Zw2B6CePhNERd21Aq7itEo7xpUCNcnUqNIgOhrGu92qHMJHySt7NEpeWsAdbTmknkI_niieIS25OL1JZdeXQVkWVWtB_WjMl2tQpJV-oiB7LG71rPAT7Tl8?width=369&height=90&cropmode=none" alt="A comparison of large rectangles painted using various alpha values"></p><p>通过在绘制之前在图形上下文中<strong>全局</strong>设置 alpha 值，可以使页面上的对象和页面本身都透明。</p><p>在普通混合模式（这是图形状态的默认模式）中， Quartz 通过使用以下公式将源颜色的组件与目标颜色的组件组合来执行 Alpha 混合 (ps: 前面 “#Setting Blend Modes#” 也有提到)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">destination &#x3D; (alpha * source) + (1 - alpha) * destination</span><br></pre></td></tr></table></figure><p>其中 source 是新颜色的一个组件， destination 是背景颜色的一个组件。对于每个新绘制的形状或图像执行该公式。 </p><p>可以为所有接收颜色的例程提供 alpha 值作为最后一个颜色组件。还可以使用 CGContextSetAlpha 函数设置全局 Alpha 值。请记住，如果<strong>同时设置两者</strong>，Quartz 会将 alpha 颜色组件乘以全局 alpha 值。</p><p>要允许页面本身<strong>完全透明</strong>，只要图形上下文是窗口或位图图形上下文，就可以使用 CGContextClearRect 函数显式清除图形上下文的 Alpha 通道。</p><h2 id="Creating-Color-Spaces"><a href="#Creating-Color-Spaces" class="headerlink" title="Creating Color Spaces"></a>Creating Color Spaces</h2><p>Quartz 支持颜色管理系统，用于设备无关颜色空间的标准颜色空间，并且还支持通用，索引和图案颜色空间。 与设备无关的颜色空间以可在设备之间移植的方式表示颜色。 它们用于将颜色数据从一个设备的原生颜色空间交换到另一个设备的原生颜色空间。 与设备无关的颜色空间中的颜色在不同设备上显示时显示相同，达到设备功能允许的程度。 因此，与设备无关的色彩空间是表示色彩的最佳选择。</p><p>具有精确颜色要求的应用程序应始终使用与设备无关的颜色空间。 常见的设备无关颜色空间是通用颜色空间。 通用色彩空间让操作系统为您的应用程序提供最佳色彩空间。 绘制到显示器看起来与将相同内容打印到打印机一样好。</p><p>重要提示：<strong>iOS 不支持</strong>与设备无关或通用的颜色空间。 iOS应用程序必须使用设备颜色空间。</p><h3 id="Creating-Device-Independent-Color-Spaces"><a href="#Creating-Device-Independent-Color-Spaces" class="headerlink" title="Creating Device-Independent Color Spaces"></a>Creating Device-Independent Color Spaces</h3><h3 id="Creating-Generic-Color-Spaces"><a href="#Creating-Generic-Color-Spaces" class="headerlink" title="Creating Generic Color Spaces"></a>Creating Generic Color Spaces</h3><h3 id="Creating-Device-Color-Spaces"><a href="#Creating-Device-Color-Spaces" class="headerlink" title="Creating Device Color Spaces"></a>Creating Device Color Spaces</h3><h3 id="Creating-Indexed-and-Pattern-Color-Spaces"><a href="#Creating-Indexed-and-Pattern-Color-Spaces" class="headerlink" title="Creating Indexed and Pattern Color Spaces"></a>Creating Indexed and Pattern Color Spaces</h3><h2 id="Setting-and-Creating-Colors"><a href="#Setting-and-Creating-Colors" class="headerlink" title="Setting and Creating Colors"></a>Setting and Creating Colors</h2><p>Quartz 提供了一套用于设置填充颜色，描边颜色，颜色空间和 alpha 的功能。 这些颜色参数中的每一个都适用于<strong>图形状态</strong>，这<strong>意味着</strong>一旦设置，该设置将保持有效直到设置为另一个值。</p><p><strong>颜色必须具有关联的颜色空间。否则，Quartz 将不知道如何解释颜色值</strong>。 此外，需要为绘图目标提供适当的颜色空间。 比如下图左侧的蓝色填充颜色，即 CMYK 填充颜色，右侧显示蓝色，这是 RGB 填充颜色。 如果查看此文档的屏幕版本，将看到填充颜色之间的巨大差异。 <strong>颜色在理论上是相同的，但只有当 RGB 颜色用于 RGB 设备并且 CMYK 颜色用于 CMYK 设备时才显示相同</strong>。</p><p><img src="https://sat02pap001files.storage.live.com/y4mIYSwvioabsFckbo2mnsgmYPUgNNmrDEVFNdrwKRTWr7LTPWiGsh-ypZZAh0ccMVIVgYWEHA8PdKhJ9S-nhPiq62hJNjdCXgd3K7dxsEnHdCpe9IZB3p1Lk62CmM6eOt9CSvASR3M9xroTMLDwMQ3Kt0evCPhX8ICElbgnEf1ceuFBF-MzQt5hGBmdqItgUuG?width=430&height=206&cropmode=none" alt="A CMYK fill color and an RGB fill color"></p><p>可以使用 CGContextSetFillColorSpace 和 CGContextSetStrokeColorSpace 函数来设置填充和描边颜色空间，也可以使用为设备颜色空间设置颜色的便捷功能之一（在表4-2中列出）。</p><p>“You can improve your application’s performance by using CGColor objects directly.”<br>(ps: 具体的详情就看官方文档吧)</p><h2 id="Setting-Rendering-Intent"><a href="#Setting-Rendering-Intent" class="headerlink" title="Setting Rendering Intent"></a>Setting Rendering Intent</h2><p>渲染意图(rendering intent)指定 Quartz 如何将颜色从源颜色空间<strong>映射到</strong>图形上下文的目标颜色空间的色域(color space)内。如果未明确设置渲染意图， Quartz 会对<strong>除</strong>位图（采样）图像<strong>之外的</strong>所有绘图使用相对色度渲染意图。 Quartz 使用感知(perceptual)渲染意图。</p><p>要设置渲染意图，请调用函数 CGContextSetRenderingIntent ，传递图形上下文和以下常量之一：</p><h2 id="Transforms"><a href="#Transforms" class="headerlink" title="Transforms"></a>Transforms</h2><p>Quartz 2D 绘图模型定义了两个完全独立的坐标空间：用户空间（代表文档页面）和设备空间（代表设备的原始分辨率）。用户空间坐标是与设备空间中像素分辨率<strong>无关的</strong>浮点数。当想要打印或显示文档时， Quartz <strong>会将</strong>用户空间坐标映射到设备空间坐标。因此，<strong>无需重写</strong>应用程序或编写其他代码来调整应用程序的输出，以便在不同设备上实现最佳显示。</p><p>可以通过在当前转换矩阵(<strong>CTM</strong>)上操作来修改默认<strong>用户空间</strong>。创建图形上下文后， CTM 是单位矩阵。可以使用 Quartz 转换函数来修改 CTM ，从而修改用户空间中的绘图。</p><h3 id="About-Quartz-Transformation-Functions"><a href="#About-Quartz-Transformation-Functions" class="headerlink" title="About Quartz Transformation Functions"></a>About Quartz Transformation Functions</h3><p>可以使用 Quartz 2D 内置转换功能轻松地平移(translate)，缩放(scale)和旋转(rotate)绘图。 只需几行代码，就可以按任何顺序和任意组合应用这些转换。 下图说明了缩放和旋转图像的效果。 应用的每个转换<strong>都会</strong>更新CTM。 <strong>CTM 始终表示用户空间和设备空间之间的当前映射</strong>。 此映射可确保应用程序的输出在任何显示屏或打印机上都很好看。</p><p><img src="https://sat02pap001files.storage.live.com/y4mQ_R2vReAHk_CQMnFdzw4ZnJMYVVTopsDapeDs3O3wqSlLY68gegDmagcgjIg6epMAgfYHwyv5hVYK913wJRGCE5mxWaoevZTbmAw1eJZrOHp-ssxWPSxm4im5Qjroxn_qtait7SVryRAzIno-H1l9_UL08w-9U_g4CdI8Km5x48fGLpkSdRJNlL4GNbwe4DI?width=310&height=144&cropmode=none" alt="Applying scaling and rotation"></p><h3 id="Modifying-the-Current-Transformation-Matrix"><a href="#Modifying-the-Current-Transformation-Matrix" class="headerlink" title="Modifying the Current Transformation Matrix"></a>Modifying the Current Transformation Matrix</h3><p>讲了一系列平移(translate)，缩放(scale)和旋转(rotate) CTM 后，公鸡图案显示的例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 角度和弧度之间的转换</span><br><span class="line">static inline double radians (double degrees) &#123;return degrees * M_PI&#x2F;180;&#125;</span><br></pre></td></tr></table></figure><h3 id="Creating-Affine-Transforms"><a href="#Creating-Affine-Transforms" class="headerlink" title="Creating Affine Transforms"></a>Creating Affine Transforms</h3><p>Quartz 中可用的仿射变换函数<strong>在矩阵上</strong>运行，而不是在 CTM 上运行。 可以使用这些函数构造一个矩阵，稍后通过调用 CGContextConcatCTM 函数将其应用于CTM。 仿射变换函数可以操作或返回 CGAffineTransform 数据结构。 可以构造可重用的简单或复杂仿射变换。 (ps: 矩阵操作)</p><h3 id="Evaluating-Affine-Transforms"><a href="#Evaluating-Affine-Transforms" class="headerlink" title="Evaluating Affine Transforms"></a>Evaluating Affine Transforms</h3><p>可以通过调用函数 CGAffineTransformEqualToTransform 来确定一个仿射变换是否等于另一个仿射变换。 如果传递给它的两个变换是相等的，则此函数返回 true ，否则返回 false 。</p><p>函数 CGAffineTransformIsIdentity 是用于检查变换是否是标识变换(identity transform)的有用函数。标识变换不执行转换，缩放或旋转。 将此变换应用于输入坐标<strong>始终返回</strong>输入坐标。 Quartz 常量 CGAffineTransformIdentity 表示身份转换。</p><h3 id="Getting-the-User-to-Device-Space-Transform"><a href="#Getting-the-User-to-Device-Space-Transform" class="headerlink" title="Getting the User to Device Space Transform"></a>Getting the User to Device Space Transform</h3><p>通常，当使用 Quartz 2D 绘图时，<strong>只能在</strong>用户空间中工作。 Quartz 负责为转换用户和设备空间。如果应用程序需要获取 Quartz 用于在用户和设备空间之间进行转换的仿射变换，则可以调用函数 CGContextGetUserSpaceToDeviceSpaceTransform 。</p><ul><li>Points. CGContextConvertPointToDeviceSpace  CGContextConvertPointToUserSpace</li><li>Sizes. CGContextConvertSizeToDeviceSpace  CGContextConvertSizeToUserSpace</li><li>Rectangles. CGContextConvertRectToDeviceSpace  CGContextConvertRectToUserSpace</li></ul><h3 id="The-Math-Behind-the-Matrices"><a href="#The-Math-Behind-the-Matrices" class="headerlink" title="The Math Behind the Matrices"></a>The Math Behind the Matrices</h3><p>矩阵运算。值得仔细一看。 反正就是行*列。</p><p>请注意，连接矩阵的顺序很重要 - 矩阵乘法<strong>不是可交换</strong>的。也就是说，矩阵A乘以矩阵B的结果<strong>不一定等</strong>于矩阵B乘以矩阵A的结果。</p><p>如前所述，连接是仿射变换矩阵包含具有常数值 0,0,1 的第三列的原因。为了将一个矩阵与另一个矩阵相乘，一个矩阵的列数<strong>必须与</strong>另一个矩阵的行数相匹配。 。这意味着2 x 3矩阵不能与2 x 3矩阵相乘。因此，我们需要包含<strong>常量值的额外列</strong>。</p><p>反转操作从转换的坐标产生原始坐标。给定坐标（x，y），其已经由给定矩阵A变换为新坐标（x’，y’），将坐标（x’，y’）变换为矩阵<strong>A的逆矩阵</strong>产生原始坐标（x，y）。当矩阵乘以其逆时，结果是单位矩阵。</p><h2 id="Patterns"><a href="#Patterns" class="headerlink" title="Patterns"></a>Patterns</h2><p>模式(pattern)是一系列绘制操作，重复绘制到图形上下文。 可以使用与使用颜色相同的方式使用图案。 当使用图案进行绘制时，Quartz 将页面划分为一组图案单元格，每个单元格都是图案图像的大小，并使用我们提供的回调绘制每个单元格。 下图显示了绘制到窗口图形上下文的模式。 (ps: 这一节，其他的就不讲了，具体用到再说，只讲”#How Patterns Work#”。)</p><p><img src="https://sat02pap001files.storage.live.com/y4m6y7_4aUXx5GZJwh476YlIJDL93LeqQ-fFN6AZYe0oDfdjfrHeiBuoh1CdQZsPGZdJdJqfx6uIb7cs2nFNAuxPJrehCm9DQxXMHf7IAScjaE40Q0rtnn_OlEX9ZYzugtjqwHnFsr9WTLC4KesGwD9aBohmIJZntY8YDLFhUTpCEuVAMsSWrn9Xo-5gVPnTaKh?width=354&height=265&cropmode=none" alt="A pattern drawn to a window"></p><p>这里讲到绘制五角星的 demo 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">### The Anatomy of a Pattern</span><br><span class="line">### Colored Patterns and Stencil (Uncolored) Patterns</span><br><span class="line">### Tiling</span><br></pre></td></tr></table></figure><h3 id="How-Patterns-Work"><a href="#How-Patterns-Work" class="headerlink" title="How Patterns Work"></a>How Patterns Work</h3><p>用 CTM 位移处理，像打字机一样，一行一行的打。(ps: 记住，绘制之前要保存图形状态，完成之后要恢复图形状态)</p><ul><li>保存图形状态。</li><li>将当前变换矩阵转换为模式单元的原点。 </li><li>将 CTM 与模式矩阵连接在一起。</li><li>剪辑到模式单元格的边界矩形。</li><li>调用绘图回调来绘制模式单元格。</li><li>恢复图形状态。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">### Painting Colored Patterns</span><br><span class="line">#### Write a Callback Function That Draws a Colored Pattern Cell</span><br><span class="line">#### Set Up the Colored Pattern Color Space</span><br><span class="line">#### Set Up the Anatomy of the Colored Pattern</span><br><span class="line">#### Specify the Colored Pattern as a Fill or Stroke Pattern</span><br><span class="line">#### Draw With the Colored Pattern</span><br><span class="line">#### A Complete Colored Pattern Painting Function</span><br><span class="line"></span><br><span class="line">### Painting Stencil Patterns</span><br><span class="line">#### Write a Callback Function That Draws a Stencil Pattern Cell</span><br><span class="line">#### Set Up the Stencil Pattern Color Space</span><br><span class="line">#### Set Up the Anatomy of the Stencil Pattern</span><br><span class="line">#### Specify the Stencil Pattern as a Fill or Stroke Pattern</span><br><span class="line">#### Drawing with the Stencil Pattern</span><br><span class="line">#### A Complete Stencil Pattern Painting Function</span><br></pre></td></tr></table></figure><h2 id="Shadows"><a href="#Shadows" class="headerlink" title="Shadows"></a>Shadows</h2><p>阴影是在图形对象下面绘制并偏移<strong>的图像</strong>，使得阴影<strong>模仿</strong>投射在图形对象上的光源的效果，如下图所示。 文本也可以被遮蔽。 阴影可以使图像看起来是三维的，或者就像浮动一样。</p><p><img src="https://sat02pap001files.storage.live.com/y4mAeYgUOUTPuS33lOXYheEk3Tad3Y7fvZVOqNY1bLpCP77WelgrBi6EgJtKg6UZw4hK1RJg73KwqOHfm7TGuiFUMFbHxtcM96uB_GELS_lD89yLmkDX2Rz7QfLZpbkMEY8gnl7jg53VO_4Cmi_y-VFmEQ5zYjOtwnEBcdVL8FdMlNUxGS3tednRr-5KJxa-1DS?width=171&height=166&cropmode=none" alt="A shadow"></p><h3 id="How-Shadows-Work"><a href="#How-Shadows-Work" class="headerlink" title="How Shadows Work"></a>How Shadows Work</h3><p>Quartz 中的阴影是<strong>图形状态的一部分</strong>。 调用函数 CGContextSetShadow ，传递图形上下文，偏移值和模糊值。 设置阴影后，绘制的任何对象都会使用<strong>黑色</strong>绘制阴影，该颜色在设备 RGB 颜色空间中具有 1/3 alpha值。 换句话说，使用设置为 {0,0,0,1.0 / 3.0} 的 RGBA 值绘制阴影。</p><p>可以通过调用 CGContextSetShadowWithColor 函数绘制彩色阴影，传递图形上下文，偏移值，模糊值和 CGColor 对象。 要为颜色提供的值取决于要绘制的颜色空间。</p><p>如果在调用 CGContextSetShadow 或 CGContextSetShadowWithColor 之前保存图形状态，则可以通过恢复图形状态来关闭阴影。 还可以通过将阴影颜色<strong>设置为NULL</strong>来禁用阴影。</p><h3 id="Shadow-Drawing-Conventions-Vary-Based-on-the-Context"><a href="#Shadow-Drawing-Conventions-Vary-Based-on-the-Context" class="headerlink" title="Shadow Drawing Conventions Vary Based on the Context"></a>Shadow Drawing Conventions Vary Based on the Context</h3><p>阴影绘制约定不受当前转换矩阵的影响。</p><h3 id="Painting-with-Shadows"><a href="#Painting-with-Shadows" class="headerlink" title="Painting with Shadows"></a>Painting with Shadows</h3><p>讲了怎么绘制阴影。<br>(ps: 记住，绘制之前要保存图形状态，完成之后要恢复图形状态)</p><h2 id="Gradients"><a href="#Gradients" class="headerlink" title="Gradients"></a>Gradients</h2><p>Quartz提供了两种不透明的数据类型来创建渐变 -  CGShadingRef 和 CGGradientRef 。可以使用其中任何一个来创建轴向(axial)或径向(radial)渐变。渐变是从一种颜色到另一种颜色不同的填充。</p><p>轴向渐变（也称为线性渐变）沿着两个限定的端点之间的轴变化。位于<strong>垂直于轴</strong>的直线上的所有点<strong>具有相同</strong>的颜色值。</p><p>径向梯度是沿两个限定端之间的轴径向变化的填充，其通常是两个圆。如果点位于中心点落在轴上的<strong>圆周</strong>上，则它们共享相同的颜色值。梯度的圆形截面的半径由端圆的半径限定，每个中间圆的半径从一端到另一端线性变化。</p><p>本章提供了可以使用Quartz创建的各种线性和径向渐变的示例，比较了绘制渐变时可以采用的两种方法，然后展示了如何使用每种不透明数据类型来创建渐变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">### Axial and Radial Gradient Examples</span><br><span class="line">### A Comparison of CGShading and CGGradient Objects</span><br><span class="line">### Extending Color Beyond the End of a Gradient</span><br><span class="line">### Using a CGGradient Object</span><br><span class="line">### Using a CGShading Object</span><br><span class="line">#### Painting an Axial Gradient Using a CGShading Object</span><br><span class="line">#### Painting a Radial Gradient Using a CGShading Object</span><br><span class="line">### See Also</span><br></pre></td></tr></table></figure><h2 id="Transparency-Layers"><a href="#Transparency-Layers" class="headerlink" title="Transparency Layers"></a>Transparency Layers</h2><p>透明层由两个或多个对象组成，这些对象<strong>组合在一起</strong>以生成复合图形。 生成的复合材料被视为<strong>单个对象</strong>。 当想要将效果应用于一组对象时，透明度层很有用。</p><p><img src="https://sat02pap001files.storage.live.com/y4m9Y_1flxViLs8pQ1J0ZkmDG9htlxLNSbp2MKY8RCI8NXMhuwkrmy5S-BxD4pJUeCQyLvZg2p_7NWthtgAuKhf-wv9p4Bwz6JcrYPADr1jUONvbix4qsVS8Le5A_EtW_0c8KCk08sT2CJ-7UwlgUDhlOjaiUePR4VBSgN72cllFu1qSYA7h9L_8urmh41fXRY1?width=263&height=259&cropmode=none" alt="Three circles as a composite in a transparency layer"></p><p><img src="https://sat02pap001files.storage.live.com/y4mGBC88odCSVHL-xxZCaEVyr55q67QbqSjOXMmDgCT1fQii0prgjB0Msypx_n1X44Z1CNKV4vCStcEaHH2wf-QZ3voNiEgUwrSNEvwE9lWbQTVcGY4w3IF4_JHhIMlT5jCkqvSlSBYlqJ03m1hZy4cnZhCNWlEBvBBsZlM-yl8CmhrIb9F9OLR2pNP1KhDGfew?width=263&height=256&cropmode=none" alt="Three circles painted as separate entities"></p><h3 id="How-Transparency-Layers-Work"><a href="#How-Transparency-Layers-Work" class="headerlink" title="How Transparency Layers Work"></a>How Transparency Layers Work</h3><p>Quartz 透明层与许多流行的图形应用程序中可用的层类似。 图层是独立的实体。 <strong>Quartz 为每个上下文维护一个透明层栈，并且可以嵌套透明层</strong>。但由于图层始终是堆栈的一部分，因此无法独立操作它们。</p><p>通过调用 CGContextBeginTransparencyLayer 函数来指示透明层的开始，该函数将图形上下文和 CFDictionary 对象作为参数。字典允许提供选项以指定有关图层的其他信息，但由于 Quartz 2D API 尚未使用该字典，因此您传递 NULL 。在此调用之后，图形状态参数保持不变，除了 alpha（设置为1），阴影（关闭），混合模式（设置为正常）以及影响最终复合的其他参数。</p><p>开始透明图层后，执行要在该图层中显示的任何图形。指定上下文中的绘制操作将作为复合绘制到完全透明的<strong>背景中</strong>。此背景被视为与上下文分离的<strong>目标缓冲区</strong>。</p><p>完成绘制后，调用 CGContextEndTransparencyLayer 函数。 Quartz 使用上下文的全局 alpha 值和阴影状态将结果<strong>合成到</strong>上下文中，并遵循上下文的剪切区域。<br>(ps: 现在外面绘制，然后合成处理)</p><h3 id="Painting-to-a-Transparency-Layer"><a href="#Painting-to-a-Transparency-Layer" class="headerlink" title="Painting to a Transparency Layer"></a>Painting to a Transparency Layer</h3><p>demo 就去看官方文档吧。</p><h2 id="Data-Management-in-Quartz-2D"><a href="#Data-Management-in-Quartz-2D" class="headerlink" title="Data Management in Quartz 2D"></a>Data Management in Quartz 2D</h2><p>管理数据是每个图形应用程序需要执行的任务。 对于 Quartz ，数据管理是指向 Quartz 2D 例程提供数据，或从 Quartz 2D 例程接收数据。 一些 Quartz 2D 例程将数据移动到Quartz 中，例如从文件或应用程序的其他部分获取图像或PDF数据的那些。 其他例程接受 Quartz 数据，例如将图像或PDF数据写入文件或将数据提供给应用程序的其他部分的数据。</p><p>Quartz提供了各种用于管理数据的功能。 通过阅读本章，应该能够确定哪种功能最适合您的应用。 (ps: 具体的就去看官方文档吧。)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">### Moving Data into Quartz 2D</span><br><span class="line">### Moving Data out of Quartz 2D</span><br><span class="line">### Moving Data Between Quartz 2D and Core Image in Mac OS X</span><br></pre></td></tr></table></figure><h2 id="Bitmap-Images-and-Image-Masks"><a href="#Bitmap-Images-and-Image-Masks" class="headerlink" title="Bitmap Images and Image Masks"></a>Bitmap Images and Image Masks</h2><p>位图图像(Bitmap images)和图像蒙版(image masks)就像 Quart 中的任何绘图基元一样。 Quartz 中的图像和图像蒙版<strong>都由</strong> CGImageRef 数据类型表示。 正如将在本章后面看到的那样，可以使用各种功能来创建图像。 其中一些需要数据提供者或图像源来提供位图数据。 其他功能通过复制图像或对图像应用操作从现有图像创建图像。 <strong>无论</strong>如何在 Quartz 中创建位图图像，<strong>都可以将</strong>图像绘制到任何风格的图形上下文中。 请记住，<strong>位图图像是特定分辨率的位数组</strong>(“Keep in mind that a bitmap image is an array of bits at a specific resolution.”)。 如果将位图图像绘制为与分辨率无关的图形上下文（例如PDF图形上下文），则位图受创建它的分辨率<strong>限制</strong>。</p><h3 id="About-Bitmap-Images-and-Image-Masks"><a href="#About-Bitmap-Images-and-Image-Masks" class="headerlink" title="About Bitmap Images and Image Masks"></a>About Bitmap Images and Image Masks</h3><p>“A bitmap image (or sampled image) is an array of pixels (or samples). Each pixel represents a single point in the image.”<br>位图图像（或采样图像）是像素（或样本）的数组。 每个像素代表图像中的单个点。 JPEG ， TIFF 和 PNG 图形文件是位图图像的示例。 应用程序图标是位图图像。 <strong>位图图像仅限于矩形</strong>。 但是通过使用 alpha 组件，它们可以呈现各种形状，并且可以旋转和修剪，如下图所示。 </p><p><img src="https://sat02pap001files.storage.live.com/y4m0jerQ9LfRQ23JhWkbRf9KvUW4jXhbxpWfKmg67nLTYDXnZI11a9JRx8qe9pVYkeRkHc2fxN9n8zI6OcwBsmAS_6LFnkzfosKUxRqeSSK1TMzb41dy8ZMeAQeyAHw6ZGgPYofhEfJKF-pX6OBiCGVl_zBMBhVQR-XzRfGUBEEow5RwARTZipcqT81eA6-sz6r?width=306&height=270&cropmode=none" alt="Bitmap images"></p><p>位图中的每个样本<strong>都包含</strong>指定颜色空间中的一个或多个颜色组件，以及一个指定 alpha 值以指示透明度的其他组件。每个组件可以是 1 到 32 位。</p><p>Quartz 还支持图像蒙版。图像蒙版是一个位图，<strong>用于指定要绘制的区域，但不指定颜色</strong>。实际上，图像蒙版充当模板(stencil)以指定在页面上放置颜色的<strong>位置</strong>。 Quartz 使用当前填充颜色来绘制图像蒙版。图像蒙版可以具有 1-8 位的深度。</p><h3 id="Bitmap-Image-Information"><a href="#Bitmap-Image-Information" class="headerlink" title="Bitmap Image Information"></a>Bitmap Image Information</h3><p>Quartz 支持各种图像格式，并具有几种流行格式的内置知识。在 iOS 中，格式包括JPEG，GIF，PNG，TIF，ICO，GMP，XBM和CUR 。其他位图图像格式或专有格式，要求我们向 Quartz <strong>指定</strong>有关图像格式的详细信息，以确保正确解释图像。提供给函数 CGImageCreate 的图像数据<strong>必须基于每个像素而不是每个扫描行进行交错</strong>。 Quartz 不支持平面数据(planar data)。</p><p>本节介绍与位图图像关联的信息。当创建和使用 Quartz 图像（使用 CGImageRef 数据类型）时，会看到一些 Quartz 图像创建功能要求指定所有这些信息，而其他功能需要此信息的子集。我们提供的内容<strong>取决于</strong>用于位图数据的编码，以及位图是表示图像还是图像蒙版。</p><p>注意：<strong>为了</strong>在处理原始图像数据时获得<strong>最佳性能</strong>，请使用 vImage 框架。可以使用 vImageBuffer_InitWithCGImage 函数从 CGImageRef 引用将图像数据导入 vImage。有关详细信息，请参阅<a href="https://developer.apple.com/library/archive/releasenotes/Performance/RN-vecLib/index.html#//apple_ref/doc/uid/TP40001049">Accelerate Release Notes</a>。</p><p>Quartz 在创建位图图像（CGImageRef）时使用以下信息：</p><ul><li>A bitmap data source, 可以是 Quartz 数据提供程序或 Quartz 图像源。 “#Data Management in Quartz 2D#”描述了两者并讨论了提供位图数据源的功能。</li><li>An optional decode array</li><li>An interpolation setting, 是一个布尔值，指定 Quartz 在调整图像大小时<strong>是否应该</strong>应用插值算法。</li><li>A rendering intent, 指定如何映射位于图形上下文的目标颜色空间内的颜色。图像蒙版不需要此信息。有关更多信息，请参阅”#Setting Rendering Intent#”。</li><li>The image dimensions</li><li>The pixel format, which includes bits per component, bits per pixel, and bytes per row (Pixel Format) 。包括每个组件的比特，每像素的比特和每行的字节数（像素格式）。</li><li>对于图像，颜色空间和位图布局（”#Color Spaces and Bitmap Layout#”）信息，用于<strong>描述</strong> alpha 的位置以及位图是否使用浮点值。 图像蒙版不需要此信息。</li></ul><h4 id="Decode-Array"><a href="#Decode-Array" class="headerlink" title="Decode Array"></a>Decode Array</h4><p><strong>解码数组将图像颜色值映射到其他颜色值，这对于去饱和图像或反转颜色等任务非常有用</strong>。 该数组包含每个颜色组件的一对数字。 当 Quartz 渲染图像时，它应用线性变换将原始组件值<strong>映射到</strong>适合目标颜色空间的指定范围内的相对数字。 例如， RGB 颜色空间中的图像的解码阵列包含六个条目，每个红色，绿色和蓝色分量一对。</p><h4 id="Pixel-Format"><a href="#Pixel-Format" class="headerlink" title="Pixel Format"></a>Pixel Format</h4><p>像素格式包含以下信息：</p><ul><li>Bits per component, 即像素中每个单独颜色组件中的位数。 对于图像掩码，该值是源像素中的重要掩蔽位的数量。 例如，如果源图像是 8 位掩码，则为每个组件指定8位。</li><li>Bits per pixel, 即源像素中的总位数。 该值必须至少为 Bits per component 乘以 components per pixel 。 // (ps: pixel 包含 components ， components 包含 Bits)</li><li>Bytes per row, 图像中每个水平行的字节数。</li></ul><h4 id="Color-Spaces-and-Bitmap-Layout"><a href="#Color-Spaces-and-Bitmap-Layout" class="headerlink" title="Color Spaces and Bitmap Layout"></a>Color Spaces and Bitmap Layout</h4><p>为确保 Quartz 正确解释每个像素的位，必须指定：</p><ul><li>位图是否包含 Alpha 通道。 Quartz支持RGB，CMYK和灰色空间。它还支持 alpha 或透明度，但 alpha 信息<strong>并非在</strong>所有位图图像格式中都可用。当它可用时， alpha 组件可以位于像素的最高有效位或最低有效位。</li><li>对于具有 alpha 组件的位图，颜色组件是否已经乘以 alpha 值。预乘(Premultiplied) alpha 描述了一种源颜色，其组件已经乘以 alpha 值。预乘通过<strong>消除</strong>每个颜色组件的额外乘法<strong>运算来加速</strong>图像的渲染。例如，在 RGB 颜色空间中，渲染具有预乘 alpha 的图像消除了图像中每个像素的三个乘法运算（RGB 三种的 alpha）。</li><li>样本的数据格式 - 整数或浮点值。</li></ul><p>使用 CGImageCreate 函数创建图像时，提供 CGImageBitmapInfo 类型的 bitmapInfo 参数以指定位图布局信息。以下常量指定 alpha 组件的位置以及颜色组件是否预乘：</p><ul><li>kCGImageAlphaLast- alpha 组件存储在每个像素的最低有效位中，例如RGBA。</li><li>kCGImageAlphaFirst- alpha分量存储在每个像素的最高有效位中，例如ARGB。</li><li>kCGImageAlphaPremultipliedLast- alpha分量存储在每个像素的最低有效位中，颜色分量已经乘以此alpha值。</li><li>kCGImageAlphaPremultipliedFirst-alpha分量存储在每个像素的最高有效位中，颜色分量已经乘以此alpha值。</li><li>kCGImageAlphaNoneSkipLast-没有alpha分量。如果像素的总大小大于颜色空间中的颜色分量的数量所需的空间，则忽略最低有效位。</li><li>kCGImageAlphaNoneSkipFirst-没有alpha组件。如果像素的总大小大于颜色空间中颜色分量的数量所需的空间，则忽略最高有效位。</li><li>kCGImageAlphaNone-相当于kCGImageAlphaNoneSkipLast。</li></ul><p>使用常量 kCGBitmapFloatComponents 指示使用浮点值的位图格式。对于浮点格式，可以使用上一个列表中的相应常量对此常量进行逻辑 OR 运算。例如，对于使用预乘 alpha 的每像素 128 位浮点格式，alpha 位于每个像素的最低有效位，可以向Quartz提供以下信息：</p><p><code>kCGImageAlphaPremultipliedLast | kCGBitmapFloatComponents</code></p><p>下图直观地描述了在使用 16 位或 32 位整数格式的 CMYK 和 RGB 颜色空间中如何表示像素。 32 位整数像素格式每个组件使用 8 位(8 bits per component)。 16 位整数格式每个组件使用 5 位(5 bits per component)。 Quartz 2D 还支持 128 位浮点像素格式，每个组件使用 32 位。 128位格式未在图中显示。</p><p><img src="https://sat02pap001files.storage.live.com/y4mCldo9-3qMbPf0uu-I3bufDRdUiyhN98bivQHf2kbn20pSsSTObGql8KrLLeG4YGGJBPBESH47elofLDl6iR_RRmuYasDvBKRqzWE0vx6OprOIPKWkF5igGWb84WDmCwX1iayDylmrMgv35BtArKyeVZ9QO4_8g6I9Tq9yecWlDYpeupgEqGDuqLFdhz3yfli?width=480&height=356&cropmode=none" alt="32-bit and 16-bit pixel formats for CMYK and RGB color spaces in Quartz 2D"></p><h3 id="Creating-Images"><a href="#Creating-Images" class="headerlink" title="Creating Images"></a>Creating Images</h3><p>讲了各种创建图片的方法。方法的选择取决于图片数据源。最灵活的是 CGImageCreate ，但同时也是最复杂的，因为要指定布局信息，详见”#Color Spaces and Bitmap Layout#”</p><h4 id="Creating-an-Image-From-Part-of-a-Larger-Image"><a href="#Creating-an-Image-From-Part-of-a-Larger-Image" class="headerlink" title="Creating an Image From Part of a Larger Image"></a>Creating an Image From Part of a Larger Image</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#### Creating an Image from a Bitmap Graphics Context</span><br></pre></td></tr></table></figure><h3 id="Creating-an-Image-Mask"><a href="#Creating-an-Image-Mask" class="headerlink" title="Creating an Image Mask"></a>Creating an Image Mask</h3><p>Quartz 位图图像蒙版的使用方式与艺术家使用丝网(silkscreen)印刷的方式相同。位图图像蒙版确定<strong>如何传输</strong>颜色，而不是使用哪种颜色。图像蒙版中的每个样本值(sample value)指定在特定位置<strong>屏蔽</strong>当前填充颜色的量。样本值指定蒙版的不透明度。较大的值表示较大的不透明度，并指定 Quartz 绘制<strong>较少</strong>颜色的位置。 可以将样本值视为<strong>反 alpha 值</strong>。值 1 是透明的，0 是不透明的。</p><h3 id="Masking-Images"><a href="#Masking-Images" class="headerlink" title="Masking Images"></a>Masking Images</h3><p>(ps: 具体的见官方文档，都有图说明)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#### Masking an Image with an Image Mask</span><br><span class="line">#### Masking an Image with an Image</span><br><span class="line">#### Masking an Image with Color</span><br><span class="line">&quot;Chroma key masking&quot; 把图片的背景颜色给去掉了。</span><br><span class="line"></span><br><span class="line">#### Masking an Image by Clipping the Context</span><br></pre></td></tr></table></figure><h3 id="Using-Blend-Modes-with-Images"><a href="#Using-Blend-Modes-with-Images" class="headerlink" title="Using Blend Modes with Images"></a>Using Blend Modes with Images</h3><p>您可以使用 Quartz 2D 混合模式（请参阅”#Setting Blend Modes#”）来合成两个图像，或者将图像合成到已经绘制到图形上下文的任何内容上。 本节讨论在背景图上合成图像。<br>(ps: 具体的见官方文档，都有图说明)</p><h2 id="Core-Graphics-Layer-Drawing"><a href="#Core-Graphics-Layer-Drawing" class="headerlink" title="Core Graphics Layer Drawing"></a>Core Graphics Layer Drawing</h2><p>CGLayer 对象（CGLayerRef 数据类型）允许应用程序使用图层进行绘制。 图层适用于以下内容：</p><ul><li>计划重复使用的高质量的绘图离线渲染。例如，可能正在构建场景并计划重用相同的背景。将背景场景绘制到图层，然后在需要时绘制图层。一个额外的好处是不需要知道绘制到图层的颜色空间或设备相关信息。</li><li>重复绘图。例如，可能希望创建一个由反复绘制的相同项组成的模式。将项目绘制到图层，然后重复绘制图层，如下图所示。重复绘制的任何 Quartz 对象（包括CGPath，CGShading和CGPDFPage对象）都可以从将其绘制到 CGLayer 中时<strong>提高性能</strong>。请注意，图层不仅适​​用于屏幕绘图; 可以将它用于非面向屏幕的图形上下文，例如PDF图形上下文。</li><li>缓冲。虽然可以为此目的使用图层，但不需要这样做，因为 Quartz Compositor 不需要缓冲。如果<strong>必须绘制到</strong>缓冲区，<strong>请使用</strong>图层而不是位图图形上下文。</li></ul><p><img src="https://sat02pap001files.storage.live.com/y4mZaU0RFWkaEI6Wr5vKpFW20dVU46ZK4gKN6Fn0k2tAzDsWSaFmUraUzOwnyKrcABG5S1GkaESG7WSBj6n_C_SVnOD8xevS4rym97mhGbGTTBZGiZY4eWcEZxPTeWVkWcwbih3Kddyo-ZxGl-H2vQKL1gpIEHl0--dUCYgCGwrXZ0zZZ65-xdF8N-qOA5xcjnX?width=249&height=101&cropmode=none" alt="Repeatedly painting the same butterfly image"></p><p>CGLayer 对象和透明层，与 CGContext 函数创建的 CGPath 对象和路径并行。 对于 CGLayer 或 CGPath 对象，可以绘制到抽象目标，然后可以将完整的绘制绘制到另一个目标，例如显示或PDF。 当绘制透明图层或使用绘制路径的 CGContext 函数时，可以直接绘制到图形上下文所表示的目标。 没有用于组装绘画的中间抽象目的地。 (ps: CGLayer 和 CGPath 有中间抽象目的地，可以用存储下来，下次再用。)</p><h3 id="How-Layer-Drawing-Works"><a href="#How-Layer-Drawing-Works" class="headerlink" title="How Layer Drawing Works"></a>How Layer Drawing Works</h3><p>由 CGLayerRef 数据类型表示的层(Layer)旨在实现<strong>最佳性能</strong>。如果可能， Quartz 使用<strong>适合</strong>与其关联的 Quartz 图形上下文类型的机制<strong>来缓存</strong> CGLayer 对象。例如，与 video card 相关联的图形上下文可以缓存 video card 上的图层，这使得绘制图层中的内容比渲染从位图图形上下文构造的类似图像快得多。因此，与位图图形上下文相比，图层通常是<strong>屏幕外绘图</strong>的更好选择。</p><p>所有 Quartz 绘图函数<strong>都绘制</strong>到图形上下文。图形上下文提供了<strong>目标的抽象</strong>，使我们可以从目标的详细信息中解放出来，例如其分辨率。在用户空间中工作，Quartz 执行必要的转换以将绘图正确呈现到目标。使用 CGLayer 对象进行绘制时，还可以绘制到图形上下文。下图说明了图层绘制的必要步骤。</p><p><img src="https://sat02pap001files.storage.live.com/y4mmiItsl4XuVoV5vrOYPqv6Cxjbh2nJlcv08TLPAIFn0NxbPen5s3ziQjbFEJE5AeXNcA5m6MgEUAX7PqkvMMVaN0C4rHwUk8gCi_jgc7hJITkbxyapoVhohKEUj3YPHDlyBsm1XwQROQPB8E3ECgbiVuCwuZGuQZByd7dOwQYI8YOinhXqRCvOjn9g6K8OoGJ?width=585&height=273&cropmode=none" alt="12-2 Layer drawing"></p><p>所有图层绘制都以图形上下文开始，可以使用 CGLayerCreateWithContext 函数从该图形上下文创建 CGLayer 对象。用于创建 CGLayer 对象的图形上下文<strong>通常是</strong>窗口图形上下。 Quartz 创建一个图层，使其<strong>具有</strong>图形上下文的所有特征 - 分辨率，颜色空间和图形状态设置。如果想使用图形上下文的大小，则可以为图层提供大小。在图12-2中，左侧显示了用于创建图层的图形上下文。右侧框中标有CGLayer对象的灰色部分表示新创建的图层。</p><p>在绘制到图层之前，<strong>必须</strong>通过调用函数 CGLayerGetContext 来获取与图层关联的图形上下文。此图形上下文与用于创建图层的图形上下文相同。只要用于创建图层的图形上下文是窗口图形上下文，如果可能的话，CGLayer 图形上下文将缓存到 GPU 。图12-2右侧框的白色部分表示新创建的图层图形上下文。</p><p>可以绘制到图层的图形上下文，就像绘制到任何图形上下文一样，将图层的图形上下文传递给绘图函数。图12-2显示了绘制到图层上下文的叶子形状。</p><p>当准备使用图层的内容时，可以调用函数 CGContextDrawLayerInRect 或 CGContextDrawLayerAtPoint ，将图层绘制到图形上下文中。通常，将绘制到用于创建图层对象的相同图形上下文，但是不需要。将图层绘制到任何图形上下文，请记住图层绘制<strong>具有用于创建</strong>图层对象的图形上下文的特征，这可能会施加某些约束（例如，性能或分辨率）。例如，与屏幕相关联的层可以高速缓存在视频硬件(video hardware)中。如果目标上下文是打印或PDF上下文，则可能需要将其从图形硬件提取到内存，从而导致性能不佳。</p><p>图12-2显示了图层的内容 - 重复绘制的叶子到用于创建图层对象的图形上下文。在释放 CGLayer 对象之前，可以多次重复使用图层中的图形。</p><p>提示：如果要合成图形的某些部分以实现遮蔽一组对象等效果，请使用透明度图层。 （请参阅”#Transparency Layers#”）如果要在<strong>屏幕外</strong>绘制或需要重复绘制相同的内容时，请使用 CGLayer 对象。</p><h3 id="Drawing-with-a-Layer"><a href="#Drawing-with-a-Layer" class="headerlink" title="Drawing with a Layer"></a>Drawing with a Layer</h3><p>(ps: demo 见官方文档吧)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#### Create a CGLayer Object Initialized with an Existing Graphics Context</span><br><span class="line">#### Get a Graphics Context for the Layer</span><br><span class="line">#### Draw to the CGLayer Graphics Context</span><br><span class="line">#### Draw the Layer to the Destination Graphics Context</span><br></pre></td></tr></table></figure><h3 id="Example-Using-Multiple-CGLayer-Objects-to-Draw-a-Flag"><a href="#Example-Using-Multiple-CGLayer-Objects-to-Draw-a-Flag" class="headerlink" title="Example: Using Multiple CGLayer Objects to Draw a Flag"></a>Example: Using Multiple CGLayer Objects to Draw a Flag</h3><p>(ps: demo 见官方文档吧，有图有代码，讲了怎么绘制一个美国国旗)</p><h2 id="PDF-Document-Creation-Viewing-and-Transforming"><a href="#PDF-Document-Creation-Viewing-and-Transforming" class="headerlink" title="PDF Document Creation, Viewing, and Transforming"></a>PDF Document Creation, Viewing, and Transforming</h2><p>暂时用不到，先不管。</p><h2 id="PDF-Document-Parsing"><a href="#PDF-Document-Parsing" class="headerlink" title="PDF Document Parsing"></a>PDF Document Parsing</h2><p>暂时用不到，先不管。</p><h2 id="PostScript-Conversion"><a href="#PostScript-Conversion" class="headerlink" title="PostScript Conversion"></a>PostScript Conversion</h2><p>暂时用不到，先不管。</p><h2 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h2><p>本章先前描述了 Quartz 提供的基本文本支持。 但是， Quartz 提供的低级支持已经被 Core Text 弃用并取代，Core Text 是一种用于布局文本和处理字体的高级低级技术。 Core Text 旨在实现高性能和易用性，并允许将 Unicode 文本直接绘制到图形上下文中。 如果你正在编写需要精确控制文本显示方式的应用程序，请参阅<a href="https://developer.apple.com/library/archive/documentation/StringsTextFonts/Conceptual/CoreText_Programming/Introduction/Introduction.html#//apple_ref/doc/uid/TP40005533">Core Text Programming Guide</a>。</p><p>如果正在为iOS开发文本应用程序的话，请首先查看<a href="https://developer.apple.com/library/archive/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009542">Text Programming Guide for iOS</a>，其中介绍了iOS中的文本支持。 特别是，UIKit提供了实现常见任务的类，可以轻松地向应用程序添加文本。</p><h2 id="Glossary"><a href="#Glossary" class="headerlink" title="Glossary"></a>Glossary</h2><ul><li>alpha value (Quartz 用于确定如何将新绘制的对象合成到现有页面的图形状态参数。在全强度（alpha = 1.0）时，新绘制的对象是不透明的。在零强度下，新绘制的对象是不可见的（alpha = 0.0）。)</li><li>axial gradient (渐变沿两个定义的端点之间的轴变化的填充。位于垂直于轴的直线上的所有点具有相同的颜色值。也称为线性渐变。)</li><li>bitmap (像素的矩形数组（或栅格），每个像素代表图像中的一个点。位图图像也称为采样图像。)</li><li>blend mode (指定Quartz如何将前景绘画与背景绘画相结合。)</li><li>clipping area (剪切区域用于约束其边界内其他对象的绘制的路径。)</li><li>color space (一维，二维，三维或四维环境，其组成部分（或通道）代表强度值。)</li><li>concatenation (连接通过将两个矩阵相乘来组合两个矩阵的操作。)</li><li>current graphics state (确定 Quartz 在绘制时如何呈现结果的参数值。)</li><li>current point (Quartz在绘制路径时使用的最后位置。)</li><li>current transformation matrix (Quartz 用于将点从一个坐标空间映射到另一个坐标空间的仿射变换。)</li><li>device color space (设备颜色空间与特定设备的颜色表示系统相关联的颜色空间。这种类型的色彩空间不适合在不同设备之间交换颜色数据。)</li><li>device-independent color space (与设备无关的颜色空间可在设备之间移植的颜色表示，用于将颜色数据从一个设备的本机颜色空间交换到另一个设备的本机颜色空间。与设备无关的颜色空间中的颜色在不同设备上显示时显示相同，达到设备功能允许的程度。)</li><li>even-odd rule (确定何时绘制像素的填充规则。结果不依赖于绘制路径段的方向。与 nonzero winding number rule 比较。)</li><li>fill (绘制路径中区域的操作。)</li><li>generic color space (Mac OS X自动选择与设备无关的颜色空间，以便为绘图目标生成最佳颜色。)</li><li>gradient (填充因颜色而异。另请参见轴向梯度和径向梯度。)</li><li>graphics context (一种不透明的数据类型（CGContextRef），它封装了 Quartz 用于将图像绘制到输出设备的信息，例如PDF文件，位图或显示器上的窗口。图形上下文中的信息包括图形绘制参数和页面上绘制的设备特定表示。)</li><li>identity transform (一种仿射变换，当应用于输入坐标时，始终返回输入坐标。)</li><li>image mask (一种位图，指定要绘制的区域，但不指定颜色。图像蒙版的作用类似于模板，用于指定在页面上放置颜色的位置。)</li><li>inversion (从转换的坐标生成原始坐标的操作。)</li><li>layer context (为实现最佳性能而设计的屏幕外绘图目标（CGLayerRef）。对于屏幕外绘制而言，图层上下文是比位图图形上下文更好的选择。)</li><li>line cap (Quartz用于绘制线对接，圆形或投影方块的端点的样式。)</li><li>line dash pattern (用于绘制虚线的重复的线段和空格系列。)</li><li>line join (Quartz用于绘制连接线段之间的连接的样式 - 斜接，圆形或斜角。)</li><li>line width (一行的总宽度，以用户空间单位表示。)</li><li>linear gradient (See axial gradient.)</li><li>nonzero winding number rule (确定何时绘制像素的填充规则。结果取决于绘制路径段的方向。与 even-odd rule 相比。)</li><li>page (Quartz绘制的虚拟画布。)</li><li>painter’s model  (一种绘图模型，其中每个连续的绘图操作都将一层绘制应用于页面。)</li><li>path (Quartz作为一个单元绘制的一个或多个形状（称为子路径）。 子路径可以由直线，曲线或两者组成。 它可以是开放的或封闭的。)</li><li>pattern (Quartz可以重复绘制到图形上下文的一系列绘制操作。)</li><li>pattern space (通过创建模式时指定的变换矩阵（模式矩阵）映射到默认用户空间的抽象空间。 模式空间与用户空间分开。 无论当前转换矩阵的状态如何，未转换的模式空间都映射到基本（未转换的）用户空间。)</li><li>premultiplied alpha (一种源颜色，其组件已经乘以一个alpha值。 预乘通过消除额外的乘法来加速图像的渲染)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;WWDC&quot;&gt;&lt;a href=&quot;#WWDC&quot; class=&quot;headerlink&quot; title=&quot;WWDC&quot;&gt;&lt;/a&gt;WWDC&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2011/129/&quot;&gt;Practical Drawing for iOS Developers&lt;/a&gt;主要讲了怎样用 Core Graphic 相关 API ，开头讲了一些精美的App, eg:股市、天气、iBooks、YouTube 等等，着重讲怎么完成股市 App 的相关绘制效果：渐变背景、数据表格等，提到的相关技术点有&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="WWDC" scheme="http://example.com/tags/WWDC/"/>
    
      <category term="AppleDocument" scheme="http://example.com/tags/AppleDocument/"/>
    
  </entry>
  
  <entry>
    <title>Core Animation Essentials(Core Animation Programming Guide)</title>
    <link href="http://example.com/2019/02/24/wwdc-2011-421/"/>
    <id>http://example.com/2019/02/24/wwdc-2011-421/</id>
    <published>2019-02-24T04:08:38.000Z</published>
    <updated>2021-05-24T15:33:13.506Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.apple.com/videos/play/wwdc2011/421/">Core Animation Essentials</a>，主要讲了 Core Animation 的一些基础知识。</p><p>讲了一个点击图片 item 有各种效果的 demo 。 </p><ol><li>点击动画变大 (change bound)</li><li>shrink and grow (UIKit 定时器改变 bound ， CA 可以用 CAMedia timing protocol and repeated animation) </li><li>边框闪烁，颜色变化 (layer.border color is animation property, repeated animation)</li><li>flip 到中心然后回到原处 (2.5D perspective transform)</li><li>边框粒子闪烁效果 </li></ol><p>然后后面就是讲 Core Animation 一些基础，所以下面就把<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004514">Core Animation Programming Guide</a>的内容大致过一下。</p><a id="more"></a><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Core Animation 是 iOS 和 OS X 上<strong>可用的图形渲染和动画基础结构</strong>，可用于为视图和应用程序的其他可视元素设置动画。  使用它，绘制动画的每个帧所需的大部分工作，都是它完成的。 我们所要做的就是配置一些动画参数（例如起点和终点）并告诉 Core Animation 启动。 Core Animation 完成剩下的工作，将大部分<strong>实际绘图工作交给</strong>图形硬件以加速渲染。 这种自动图形加速可以实现高帧速率和流畅的动画，而不会给 CPU 带来负担并降低应用程序的速度。 它大致有以下相关功能。</p><ul><li>Core Animation Manages Your App’s Content,  Core Animation 本身不是绘图系统。 它是一种<strong>用于在硬件中合成和操作应用内容的基础架构</strong>。 此基础结构的核心是图层对象(layer objects)，可以使用它来管理和操作内容。  <strong>layer 将内容捕获到可以由图形硬件轻松操作的位图(bitmap)中</strong>。 在大多数应用程序中，图层用作管理视图内容的方式，但也可以根据需要创建独立图层。</li><li>Layer Modifications Trigger Animations, layer 相关属性的改变会导致创建隐式动画。 如果我们想要更好的控制，可以使用显式动画。</li><li>Layers Can Be Organized into Hierarchies,  可以像 UIView 一样排列创建父子关系(parent-child relationships)。  附加到 view 的一组 layer 的层次结构**镜像(mirror)**出相应的 view 层次结构； 也可以将独立 layer 添加到 layer 层次结构中。</li><li>Actions Let You Change a Layer’s Default Behavior,  隐式动画是由操作对象(action objects)实现的，它是实现预定义接口的通用对象。 Core Animation 使用操作对象来实现通常与图层关联的<strong>默认动画集</strong>。 我们可以创建自己的操作对象来实现自定义动画，也可以使用它们来实现其他类型的行为。 然后，将操作对象分配给图层的某个属性。<strong>当该属性更改时，Core Animation 将检索操作对象并告诉它执行其操作</strong>。(ps: session 2011.421 P25 也有讲到)</li></ul><h1 id="Core-Animation-Basics"><a href="#Core-Animation-Basics" class="headerlink" title="Core Animation Basics"></a>Core Animation Basics</h1><p>Core Animation 提供了一个通用系统，用于<strong>动画</strong>视图和应用程序的其他可视元素。 它不是取代应用程序的视图。相反，它是一种与视图集成的技术，可为动画内容提供更好的性能和支持。 它通过<strong>将视图内容缓存到可以由图形硬件直接操作的位图</strong>来实现此行为。 在某些情况下，此缓存行为可能需要我们<strong>重新考虑</strong>如何呈现和管理应用程序的内容，但大多数时候使用 Core Animation 时却不知道它存在。<strong>除了缓存视图内容之外，它还可以动画</strong>。</p><h2 id="Layers-Provide-the-Basis-for-Drawing-and-Animations"><a href="#Layers-Provide-the-Basis-for-Drawing-and-Animations" class="headerlink" title="Layers Provide the Basis for Drawing and Animations"></a>Layers Provide the Basis for Drawing and Animations</h2><p>图层对象(layer object)是在 3D 空间中的 2D 表面，是使用 Core Animation 的核心。跟视图一样，它管理有关其曲面几何，内容和视觉属性的信息。<strong>但跟视图不同的是，图层不会定义自己的外观，仅管理位图周围的状态信息。位图本身可以是视图绘制本身的结果，或者是指定的固定图像的结果。</strong> 因此，在应用中使用的主要图层被视为模型对象(model objects)，因为它们主要<strong>管理数据</strong>。 这个概念很重要，因为它会影响动画的行为。 (ps: layer 管理位图相关的状态信息)</p><h3 id="The-Layer-Based-Drawing-Model"><a href="#The-Layer-Based-Drawing-Model" class="headerlink" title="The Layer-Based Drawing Model"></a>The Layer-Based Drawing Model</h3><p>大多数图层都不会在应用中进行任何实际绘图。 <strong>相反，图层会捕获应用提供的内容，并将其缓存在位图中，有时也称为后备存储(backing store)。</strong> 当随后更改图层的属性时，所做的<strong>只是更改</strong>与图层对象关联的状态信息。 当更改触发动画时， Core Animation 会将图层的位图和状态信息传递给图形硬件，图形硬件会使用新信息渲染位图，如下图所示：</p><p><img src="https://sat02pap001files.storage.live.com/y4mdiXRM-Ek8YeyYoOs02P8EGghahbcWIZ0SeHatXlJkIIMcSv7i5OThV8FgSquFPjsEnd6yIvlse3rY1p_4j-q5wTYkM-5fH7PS2tr8oENc6Iio4m_WO-LVDLMk_5oifmegqZxTmEV3Tyi3T5ZjzQ8efJJwvflhDybl2mZsR3Q-Hp4d-vJDE5nqQMFzseLWCgo?width=1467&height=456&cropmode=none" alt="Figure 1-1  How Core Animation draws content"> </p><p>在<strong>硬件中</strong>操作位图会产生比在软件中更快。 (ps: 更改 layer 的属性或者触发动画时， Core Animation 只会更改相关联的状态信息，而不是图层，更高效。)</p><p>因为它操纵静态位图，所以基于图层(layer-based)的绘图与更传统的基于视图的绘图技术显着不同。 使用基于视图的绘图时，对视图本身的更改通常会导致调用视图的 <code>drawRect:</code> 方法以使用新参数<strong>重绘内容</strong>。 但是以这种方式绘制是很昂贵的，因为它是在主线程上使用 CPU 完成的。 Core Animation 通过在硬件中操纵缓存的位图来实现相同或类似的效果，尽可能避免这种费用。 (ps: <code>drawRect:</code> 会比较耗时，相对于 Layer-Based 操作静态位图)</p><h3 id="Layer-Based-Animations"><a href="#Layer-Based-Animations" class="headerlink" title="Layer-Based Animations"></a>Layer-Based Animations</h3><p>图层对象的数据和状态信息 与 屏幕上该图层内容的可视化表示 <strong>分离</strong>。这种解耦使 Core Animation 成为一种介入自身的方法，并将从旧状态值到新状态值的变化设置为动画。</p><p>在动画过程中， Core Animation 会在硬件中完成所有逐帧绘图(frame-by-frame drawing)。 (ps: 硬件中绘制，这里应该是讲的 Render Server 中的 Core Animation 在 GPU 中绘制， session 2014.419 P34 也有讲到)</p><h2 id="Layer-Objects-Define-Their-Own-Geometry"><a href="#Layer-Objects-Define-Their-Own-Geometry" class="headerlink" title="Layer Objects Define Their Own Geometry"></a>Layer Objects Define Their Own Geometry</h2><p>图层的一个工作就是<strong>管理其内容的可视几何体</strong>。 可视几何体包含有关该内容边界，其在屏幕上的位置以及该层是否以任何方式旋转，缩放或变换的信息。(ps: 只要跟位置、大小相关的都与可视几何有关。) 与视图一样，图层具有 frame 和 bounds 属性，可以使用它们来定位图层及其内容。 图层还具有视图不具有的其他属性，例如 anchor point ，用于<strong>定义操作发生的点</strong>。 指定图层几何图形的某些方面的方式也与为视图指定信息的方式不同（ps: 这里应该主要就是讲 anchor point 吧）。</p><h3 id="Layers-Use-Two-Types-of-Coordinate-Systems"><a href="#Layers-Use-Two-Types-of-Coordinate-Systems" class="headerlink" title="Layers Use Two Types of Coordinate Systems"></a>Layers Use Two Types of Coordinate Systems</h3><p>图层使用基于点(point-based)的坐标系和单位(unit)坐标系来指定内容的位置。 使用哪种坐标系<strong>取决于</strong>所传达的信息类型。 指定直接映射到屏幕坐标的值 或 必须相对于另一个图层指定的值时使用基于点的坐标，例如图层的 position 属性。 当值<strong>不应与屏幕坐标相关联时</strong>使用单位坐标，因为它与<strong>某个其他值</strong>相关(ps: 后面紧接着一句有提到)。 例如，图层的 anchorPoint 属性指定<strong>相对于图层本身边界的点</strong>，它可以更改。</p><p>基于点的坐标最常见的用途是指定图层的大小和位置，使用图层的 bounds 和 position 属性。尽管图层还有 frame 属性，它实际上 bounds 和 position 属性的值派生的，并且使用频率较低。</p><p>图层 bounds 和 frame 的方向始终与底层平台的默认方向匹配。</p><ul><li>iOS(top-left corner)</li><li>OS X(bottom-left corner)</li></ul><p>如图<br><img src="https://sat02pap001files.storage.live.com/y4mH2HRXYqZnb1WstVwwbp3IHrwmJH1o0FxCGm2UJ-9Dxm45hUKeleD7u1XLJAm6iFIdvgX_vNFaoXP92D3FV-q0oTTSHP0eaLWgBFARKtzzpHB2vTb72BU5Xp-mLYXPzrGuaVhEdUcgE6O6YXIjG-3lUQ82jUwT6CbAGoBlShGuj6jw_s8sYPan09xz_xkVOO-?width=1133&height=445&cropmode=none" alt="The default layer geometries for iOS and OS X"></p><p>anchorPoint 是使用单位坐标系指定的几个属性之一。 Core Animation 使用单位坐标 来表示 在图层 size 更改时其值<strong>可能会更改的属性</strong>。 可以将单位坐标视为指定总可能值的百分比。 单位坐标空间中的每个坐标的范围都为 0.0 到 1.0 。 例如，沿 x 轴，左边缘位于坐标 0.0 ，右边缘位于坐标 1.0 。 沿 y 轴，单位坐标值的方向根据平台而变化，如图</p><p><img src="https://sat02pap001files.storage.live.com/y4mYLCD3EJkaogucfbQr6TlfRGikIl99lGZvI1ARL8n-ehy8xerqghM8fO-Ujr7L5Z_rkS5Kids2wuWNC2QkJjZZEVPANL4Tlz5okdnRIKWd0ZsBicSiB43oKrXF1BeKB7o5aCg9RlJx9nnFDupKm-Q2-vYg_dZQJP-L6JamQZtG1XB2CigxzXJfx2eURnWACss?width=947&height=400&cropmode=none" alt="The default unit coordinate systems for iOS and OS X"></p><p>所有坐标值（无论是点还是单位坐标）都指定为浮点数。 使用浮点数可以指定可能介于正常坐标值之间的<strong>精确位置</strong>。 使用浮点值很方便，特别是在打印期间或绘制到 Retina 显示器时，其中一个点可能由多个像素表示。 浮点值允许您忽略基础设备分辨率，只需以您需要的精度指定值。 (ps: 浮点值的好处)</p><h3 id="Anchor-Points-Affect-Geometric-Manipulations"><a href="#Anchor-Points-Affect-Geometric-Manipulations" class="headerlink" title="Anchor Points Affect Geometric Manipulations"></a>Anchor Points Affect Geometric Manipulations</h3><p>position 和 transform 都受到 anchorPoint 的影响。</p><p>见下图<br><img src="https://sat02pap001files.storage.live.com/y4mnUnXVApXrufKbOgcwwIn6Y2DoQPzAvIRDVjOu3IRGfU0uTIL_DuEDd58luXBet5tgOVdeP8NUtoGth_NVqHoOAcPUHWmrlfQqt03JwsuXvUu0vdueu9hGy-SbCJM9HdHtbaxaQNV2h9Ym70BmhszLAyUd15JP7fCeZlebGS8lEsgK-m44VfrygvHt5MoKiTw?width=1338&height=1485&cropmode=none" alt="How the anchor point affects the layer’s position property"></p><p><img src="https://sat02pap001files.storage.live.com/y4mLQFZ7UN3pLuqRozSXgGpSGtmSLA81bHPoa57EWPFQFqCjkNPDFSZLvR0h4ZmhigSIsQVodwo3DurVbACqQ3qXmioNy6DkVKYKH2u0un7K1fBcvmI0bj_dKxAEzKZS58mXe9RXYxjiw_7E6lklL9qMJWIlHyMHTttU87Msy1DXnw20blPB-UmyMJ-50-WlpPd?width=1338&height=1302&cropmode=none" alt="How the anchor point affects layer transformations"></p><h3 id="Layers-Can-Be-Manipulated-in-Three-Dimensions"><a href="#Layers-Can-Be-Manipulated-in-Three-Dimensions" class="headerlink" title="Layers Can Be Manipulated in Three Dimensions"></a>Layers Can Be Manipulated in Three Dimensions</h3><p>每个图层都有两个变换矩阵，可以使用它们来操纵图层及其内容。</p><ul><li>transform, 指定要应用于图层及其嵌入子图层的变换。</li><li>sublayerTransform, 仅适用于子图层的其他转换，最常用于向场景内容添加透视视觉效果。</li></ul><p>通过将坐标值乘以数字矩阵来做变换工作，以获得表示原始点的变换版本的新坐标。 如图<br><img src="https://sat02pap001files.storage.live.com/y4m8gZTdmc4e0StYmp8Z4MIA19bTmY1MSeRhF0i8SHwXlGfevS3QJl0qE5zNPFXKGEeUxAg_8a2DtjhXO2u3HgLtVJBrFt03QzkU2FbciJNMH0aj7lQEfwWX8bZrGUmfQkm1d57sf1Z0lYmNcQty1h86rQoLh_Mgf2EynNVH44P61KFxqcJ0O5PTkFUf9uWSRX7?width=617&height=219&cropmode=none" alt="Converting a coordinate using matrix math"></p><p>还列举了各种常用的变换矩阵。如图<br><img src="https://sat02pap001files.storage.live.com/y4mvvO9GI0Fhpsay0VFTkZCBQZg3KTH-g9b3dr8d40GHH03w6b-xripjBLR4bhadmiYuZisP2RMBBBQL4q79yPMhzrF4v5Gxx2qocdXNVFRR0Cu6M6lzyR_SQEFI-s6P_x1T0MiuapzyAZC6O_ogvUKutWb6h2FoulismmnfKpXZwFeg2Kscy15iqJmQzFMGV0d?width=543&height=595&cropmode=none" alt="Matrix configurations for common transformations"></p><h2 id="Layer-Trees-Reflect-Different-Aspects-of-the-Animation-State"><a href="#Layer-Trees-Reflect-Different-Aspects-of-the-Animation-State" class="headerlink" title="Layer Trees Reflect Different Aspects of the Animation State"></a>Layer Trees Reflect Different Aspects of the Animation State</h2><p>使用 Core Animation 的应用程序有三组图层对象。 每组图层对象在使应用内容显示在屏幕上时具有不同的作用：</p><ul><li>layer tree(图层树), 应用与之交互的对象，它存储动画的目标值，当更改 layer 的属性内容时，就是用的它。</li><li>presentation tree(呈现树), 正在运行的动画的 in-flight values(时刻都会变换的，它表示动画的当前值)，我们不应该改变它的值，相反而是获取这些值，然后开始新的动画。</li><li>render tree(渲染树), 它执行实际动画，并且是 Core Animation 的私有动画。</li></ul><p>每组图层对象都组织成一个分层结构，就像应用程序中的视图一样，这是伴随着视图的。 </p><p>可以将与视图无关的图层添加到图层层次中，好处就是针对不需要视图的所有开销的内容，优化应用程序的性能(Q: 具体是指哪些开销呢？)。</p><p>对于图层树中的每个对象，在呈现树和渲染树中都有一个匹配的对象。 应用程序主要使用图层树中的对象，但有时可能访问呈现树中的对象(用 presentationLayer 属性获取)，因为我们想获取动画的当前值。</p><p>注意：只有动画在进行中(in flight)时，才应该访问呈现树中的对象。不然没有意义。此行为与图层树不同，图层树始终反映代码设置的最后一个值，并且等效于动画的最终状态。(因为它实时反映当前的值，所以 explicit animation 的时候要设置最终的值，不然动画完成以后会回到初始值，以为没做任何改变。)</p><h2 id="The-Relationship-Between-Layers-and-Views"><a href="#The-Relationship-Between-Layers-and-Views" class="headerlink" title="The Relationship Between Layers and Views"></a>The Relationship Between Layers and Views</h2><p>图层<strong>不能替代</strong>应用程序的视图 - 也就是说，无法仅基于图层对象创建可视化界面。 图层为视图提供<strong>基础结构</strong>。 具体而言，在执行此操作时，图层可以更轻松、更有效地绘制视图内容并为其设置动画并保持较高的帧速率。 但是，图层有很多事情没有做。 图层<strong>不处理事件，绘制内容(draw content)，参与响应链或执行许多其他操作</strong>。 出于这个原因，每个应用程序必须仍然有一个或多个视图来处理这些类型的交互。</p><p>在 iOS 中，每个视图都由相应的图层对象支持(backed)，被称为图层支持的视图(layer-backed view)。在图层支持的视图中，系统负责创建底层图层对象并保持该图层与视图同步。</p><p>注意：对于图层支持的视图，建议尽可能操纵视图而不是其图层。 在 iOS 中，视图只是图层对象的一个<strong>薄包装</strong>，因此对图层所做的任何操作通常都可以正常工作。 但是在 iOS 和 OS X 中都存在这样的情况：操纵图层而不是视图可能无法产生预期的结果。 只要有可能，本文档指出了这些陷阱，并试图提供方法来帮助您解决这些问题。 (ps: 操作视图，而是图层。)</p><p>除了与视图关联的图层外，还可以创建没有相应视图的图层对象。可以将这些独立图层对象嵌入到应用程序中的任何其他图层对象中，包括与视图关联的对象。 通常使用独立层对象作为特定优化路径的一部分。 例如，如果要在多个位置使用相同的图像，可以将图像加载一次，并将其与多个独立图层对象关联，然后将这些对象添加到图层树。 然后，每个层都<strong>引用源图像，而不是</strong>尝试在内存中创建自己的图像副本。</p><h1 id="Setting-Up-Layer-Objects"><a href="#Setting-Up-Layer-Objects" class="headerlink" title="Setting Up Layer Objects"></a>Setting Up Layer Objects</h1><p>图层对象是使用 Core Animation 执行的所有操作的核心。 <strong>图层管理应用程序的可视内容，并提供 用于修改该内容的样式和视觉外观的 选项</strong>。</p><h2 id="Enabling-Core-Animation-Support-in-Your-App"><a href="#Enabling-Core-Animation-Support-in-Your-App" class="headerlink" title="Enabling Core Animation Support in Your App"></a>Enabling Core Animation Support in Your App</h2><p>在 iOS 应用程序中，始终启用 Core Animation ，每个视图都由一个图层支持。</p><h2 id="Changing-the-Layer-Object-Associated-with-a-View"><a href="#Changing-the-Layer-Object-Associated-with-a-View" class="headerlink" title="Changing the Layer Object Associated with a View"></a>Changing the Layer Object Associated with a View</h2><p>默认情况下，图层支持的视图会创建 CALayer 类的实例，在大多数情况下，可能不需要不同类型的图层对象。  选择不同的图层类可能会以简单的方式<strong>提高性能或支持特定类型的内容</strong>。 例如， CATiledLayer 类被优化用于以有效的方式显示大图像。(ps:专人专项)</p><h3 id="Changing-the-Layer-Class-Used-by-UIView"><a href="#Changing-the-Layer-Class-Used-by-UIView" class="headerlink" title="Changing the Layer Class Used by UIView"></a>Changing the Layer Class Used by UIView</h3><p>可以通过覆盖视图的 layerClass 方法并返回不同的类对象来更改 iOS 视图使用的图层类型。默认是 CALayer 对象。 但是可能在某些情况下，不同的图层类更合适。比如：</p><ul><li>视图使用 Metal 或 OpenGL ES 绘制内容，在这种情况下，应该使用 CAMetalLayer 或 CAEAGLLayer 对象。</li><li>有一个专门的图层类可以提供更好的性能。(专人专项)</li><li>希望利用一些专门的 Core Animation 图层类，例如粒子发射器(particle emitters)或复制器(replicators)。</li></ul><p>改变图层的代码如下，在显示之前，视图调用 layerClass 方法并使用返回的类为自己创建新的图层对象。 创建后，<strong>无法更改</strong>视图的图层对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (Class) layerClass &#123;</span><br><span class="line">   return [CAMetalLayer class];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Different-Layer-Classes-Provide-Specialized-Behaviors"><a href="#Different-Layer-Classes-Provide-Specialized-Behaviors" class="headerlink" title="Different Layer Classes Provide Specialized Behaviors"></a>Different Layer Classes Provide Specialized Behaviors</h3><p>列举了不同的 Layer 类型提供的特定行为。</p><ul><li>CAEmitterLayer,  用于实现基于Core Animation的粒子发射器系统。 </li><li>CAGradientLayer, 颜色渐变。</li><li>CAMetalLayer,  Metal 渲染内容。</li><li>CAEAGLLayer/CAOpenGLLayer, OpenGL ES (iOS) or OpenGL (OS X) 渲染内容。</li><li>CAReplicatorLayer, 复制器。</li><li>CAScrollLayer, 滚动。</li><li>CAShapeLayer, 用于绘制立方贝塞尔样条曲线。形状图层有利于绘制基于路径的形状，因为它们总是会<strong>产生清晰的路径，而不是</strong>绘制到图层的后备存储中的路径，这在缩放时看起来不太好。 但是，清晰的结果确实涉及在主线程上呈现形状并缓存结果。</li><li>CATextLayer,  纯/富 文本。</li><li>CATiledLayer,  用于管理大图像，可以将其划分为较小的图块并单独渲染，并支持放大和缩小内容。</li><li>CATransformLayer,  用于呈现<strong>真正的 3D 图层</strong>层次结构，而不是由其他图层类实现的展平图层层次结构。</li><li>QCCompositionLayer,  用于渲染Quartz Composer合成。 (仅限OS X)</li></ul><h2 id="Providing-a-Layer’s-Contents"><a href="#Providing-a-Layer’s-Contents" class="headerlink" title="Providing a Layer’s Contents"></a>Providing a Layer’s Contents</h2><p><strong>图层是 管理应用提供内容的 数据对象</strong>。 图层的内容由 包含要显示的可视数据的位图 组成。 </p><ul><li>将图像对象(image object)直接分配给图层对象的 contents 属性。 （此技术最适用于从未或很少更改的图层内容。）</li><li>将委托对象(delegate object)分配给图层，让委托绘制图层的内容。 （此技术最适用于可能会定期更改并可由外部对象（如视图, UIView ）提供的图层内容。）</li><li>定义图层子类(layer subclass)并覆盖其绘图方法之一以自己提供图层内容。 （如果必须创建自定义图层子类或者如果要更改图层的基本绘图行为，则此技术是合适的。）</li></ul><p>自己创建图层对象时，唯一需要担心为图层提供内容<strong>的时间</strong>。 如果应用程序只包含图层支持的视图，则不必担心使用上述任何技术来提供图层内容，图层支持的视图<strong>以最有效的方式</strong>自动提供其关联图层的内容。</p><h3 id="Using-an-Image-for-the-Layer’s-Content"><a href="#Using-an-Image-for-the-Layer’s-Content" class="headerlink" title="Using an Image for the Layer’s Content"></a>Using an Image for the Layer’s Content</h3><p><strong>由于图层只是用于管理位图图像的容器</strong>，因此可以将图像直接指定给图层的内容属性。<br>图层使用我们直接提供的图像对象，不会尝试创建<strong>自己的图像副本</strong>。 如果在应用的多个位置使用相同的图像，此行为可以节省内存。</p><p>赋值的时候 CGImageRef 类型，记得提供一个分辨率与本机设备分辨率相匹配的图像（调整 contentsScale 属性）。 </p><h3 id="Using-a-Delegate-to-Provide-the-Layer’s-Content"><a href="#Using-a-Delegate-to-Provide-the-Layer’s-Content" class="headerlink" title="Using a Delegate to Provide the Layer’s Content"></a>Using a Delegate to Provide the Layer’s Content</h3><p>使用委托对象在显示时，图层调用委托的方法来提供所需的内容：</p><ul><li>如果委托对象实现了 <code>displayLayer:</code> 方法，那么它实现负责创建位图并将其分配给图层的 contents 属性。</li><li>如果委托对象实现了 <code>drawLayer:inContext:</code> 方法，则 Core Animation 会创建一个位图，创建一个图形上下文(graphics context)以绘制到该位图，然后调用委托方法来填充该位图。 所有委托方法都要<strong>绘制到提供的图形上下文中</strong>。</li></ul><p>委托对象实现了 <code>displayLayer:</code> 或者 <code>drawLayer:inContext:</code> 方法，如果两者都实现了，只会调用 <code>displayLayer:</code> 方法。</p><p>覆盖 <code>displayLayer:</code> 方法 最适合 应用程序<strong>更喜欢加载或创建它想要显示的位图的情况</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Setting the layer contents directly</span><br><span class="line">- (void)displayLayer:(CALayer *)theLayer &#123;</span><br><span class="line">    &#x2F;&#x2F; Check the value of some state property</span><br><span class="line">    if (self.displayYesImage) &#123;</span><br><span class="line">        &#x2F;&#x2F; Display the Yes image</span><br><span class="line">        theLayer.contents &#x3D; [someHelperObject loadStateYesImage];</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        &#x2F;&#x2F; Display the No image</span><br><span class="line">        theLayer.contents &#x3D; [someHelperObject loadStateNoImage];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有预渲染图像或辅助对象来<strong>创建位图</strong>，则委托可以使用 <code>drawLayer:inContext:</code> 方法动态绘制内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Drawing the contents of a layer</span><br><span class="line">- (void)drawLayer:(CALayer *)theLayer inContext:(CGContextRef)theContext &#123;</span><br><span class="line">    CGMutablePathRef thePath &#x3D; CGPathCreateMutable();</span><br><span class="line"> </span><br><span class="line">    CGPathMoveToPoint(thePath,NULL,15.0f,15.f);</span><br><span class="line">    CGPathAddCurveToPoint(thePath,</span><br><span class="line">                          NULL,</span><br><span class="line">                          15.f,250.0f,</span><br><span class="line">                          295.0f,250.0f,</span><br><span class="line">                          295.0f,15.0f);</span><br><span class="line"> </span><br><span class="line">    CGContextBeginPath(theContext);</span><br><span class="line">    CGContextAddPath(theContext, thePath);</span><br><span class="line"> </span><br><span class="line">    CGContextSetLineWidth(theContext, 5);</span><br><span class="line">    CGContextStrokePath(theContext);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Release the path</span><br><span class="line">    CFRelease(thePath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于具有自定义内容的图层支持视图，应该继续覆盖视图的方法来进行绘制。 图层支持的视图自动<strong>使其自身成为其图层的委托</strong>，并实现所需的委托方法，不应更改该配置。 相反，应该实现视图的 <code>drawRect:</code> 方法来绘制内容。 (ps: layer-backed custom view 就是其 layer 的代理)。</p><h3 id="Providing-Layer-Content-Through-Subclassing"><a href="#Providing-Layer-Content-Through-Subclassing" class="headerlink" title="Providing Layer Content Through Subclassing"></a>Providing Layer Content Through Subclassing</h3><p>如果要实现自定义图层类，则可以覆盖图层类的<strong>绘图方法</strong>以执行任何绘图。 图层对象本身生成自定义内容的情况并不常见，但图层当然可以<strong>管理内容的显示</strong>。例如， CATiledLayer 类通过将大图像分成可以单独管理和呈现的较小图块 来管理大图像。因为<strong>只有图层具有关于在任何给定时间需要渲染哪些图块的信息，所以它直接管理绘图行为</strong>。</p><p>子类化时，可以使用以下任一技术绘制图层的内容：</p><ul><li>覆盖图层的 <code>display</code> 方法，并使用它直接设置图层的 contents 属性。</li><li>覆盖图层的 <code>drawInContext:</code> 方法，并使用它绘制到提供的图形上下文中。</li></ul><p>覆盖哪种方法取决于在绘图过程中的控制程度。 display 方法是更新图层内容的<strong>主要入口点</strong>，因此覆盖该方法可以<strong>完全控制</strong>该过程。覆盖 display 方法还意味着我们负责创建要分配给 contents 属性的 CGImageRef 。如果只想绘制内容（或让图层管理绘图操作），可以改写 <code>drawInContext:</code> 方法，让图层创建后备存储。</p><h3 id="Tweaking-the-Content-You-Provide"><a href="#Tweaking-the-Content-You-Provide" class="headerlink" title="Tweaking the Content You Provide"></a>Tweaking the Content You Provide</h3><p>将图像指定给图层的 contents 属性时，图层的 contentsGravity 属性确定如何处理该图像以适合当前边界。 默认情况下，如果图像大于或小于当前边界，则图层对象会缩放图像以适合可用空间。 如果图层边界的宽高比不同于图像的宽高比，则可能导致图像失真。 可以使用 contentsGravity 属性来确保以尽可能最佳的方式呈现内容。</p><p>分配给 contentsGravity 属性的值分为两类：</p><ul><li>position-based gravity constants, 基于位置的重力常数允许将图像固定到图层边界矩形的特定边或角，而不缩放图像。(见下图 Position-based gravity constants for layers)</li><li>scaling-based gravity constants, 基于缩放的重力常数允许使用多个选项之一来拉伸图像，其中一些选项保留宽高比，而其中一些选项不保留。(见下图 Scaling-based gravity constants for layers)</li></ul><p><img src="https://sat02pap001files.storage.live.com/y4mc1ojWJzj7ZimFJvSkvwxC3eTdG7F-k0nD8EcaE3mBd3fBUguaBW_DhEg8C_E9HCvnkG8uek0TMavoPeSEOeu-YfaDX-7lnzQZXuBVy903QDipT7SAkoQPX-AbfOiht8TBr4POqwUPp4aMwmDdzJ0XUGaHv_QFwRlH64Neiu6Na38V6U2RrS4yt_kdgxcEcig?width=1095&height=679&cropmode=none" alt="Position-based gravity constants for layers"></p><p><img src="https://sat02pap001files.storage.live.com/y4m5fJbUyvK3LzZdW7Z6RyWHZuGlD28Qa6ZBNof-8GI_9Ezmv1peih6rROZmgkk-l1a71fXIWIDEdyrW5AijnIVKjGGxb0t3yFrm547e9IWGte_5CBCyyAwNUv_0ttfGQjYubexIw8blzKnKhpgEeM63CAC32TgAfADnXl6l-7MnKPi-s_hu-JGeAl5oTsLN9_V?width=944&height=510&cropmode=none" alt="Scaling-based gravity constants for layers"></p><p>只有 kCAGravityResize 不保留原图像的宽高比。</p><h3 id="Working-with-High-Resolution-Images"><a href="#Working-with-High-Resolution-Images" class="headerlink" title="Working with High-Resolution Images"></a>Working with High-Resolution Images</h3><p><strong>图层对底层设备屏幕的分辨率没有任何固有的了解，图层只是存储指向位图的指针，并在给定可用像素的情况下以最佳方式显示它</strong>。如果将图像指定给图层的内容属性，则必须通过将图层的 contentsScale 属性设置为适当的值来告知 Core Animation 图像的分辨率。该属性的默认值为 1.0，适用于要在标准分辨率屏幕上显示的图像。如果图像用于 Retina 显示，请将此属性的值设置为 2.0 。</p><p><strong>只有在直接为图层指定位图时，才需要更改 contentsScale 属性的值</strong>。 UIKit 和 AppKit 中的 图层支持的视图 会根据屏幕分辨率和视图管理的内容 <strong>自动</strong>将其图层的比例因子设置为适当的值。</p><h2 id="Adjusting-a-Layer’s-Visual-Style-and-Appearance"><a href="#Adjusting-a-Layer’s-Visual-Style-and-Appearance" class="headerlink" title="Adjusting a Layer’s Visual Style and Appearance"></a>Adjusting a Layer’s Visual Style and Appearance</h2><p>图层对象内置了视觉装饰(visual adornments)，例如边框和背景颜色，可用于补充图层的主要内容。 由于这些视觉装饰<strong>不需要进行任何渲染，因此可以在某些情况下将图层用作独立实体</strong>。 我们所要做的就是在图层上设置属性，图层处理必要的图形，包括任何动画。 有关这些视觉装饰如何影响图层外观的其他说明，请参阅”#Layer Style Property Animations#”。</p><h3 id="Layers-Have-Their-Own-Background-and-Border"><a href="#Layers-Have-Their-Own-Background-and-Border" class="headerlink" title="Layers Have Their Own Background and Border"></a>Layers Have Their Own Background and Border</h3><p><img src="https://sat02pap001files.storage.live.com/y4mZtcLVtUvscU2EY89MNsCRlh3-LzbU3WJIJokv1b3O-UxkIPs3XV5olOn9-Z8Amaj8ofgr0keiXz5DJ4XSJ9W2NPmH5zkuMIHEX7drfcYOI4iXyT31IQcEByA67St33rHBgiWugClW68n1FHL1l0wtvUpDFLLVuU7bQUnknuTxAabo3S6d9QsIU5qz8XwpDPZ?width=759&height=579&cropmode=none" alt="Adding a border and background to a layer"><br>background color 在图层的内容图像后面呈现， border 呈现在该图像的顶部。</p><p>注意：请注意 Core Graphics 处理图案图像(pattern images)的渲染，并使用其标准坐标系进行处理，该坐标系与 iOS 中的默认坐标系不同。 (ps: 注意 Core Graphics 使用的坐标系与 iOS 中的 y 轴相反。)</p><p>如果将图层的背景颜色设置为不透明颜色(opaque color)，请考虑将图层的 opaque 属性设置为 YES 。 这样做可以在屏幕上<strong>合成图层时提高性能</strong>，并且无需图层的<strong>后备存储来管理 Alpha 通道</strong>。 <strong>但是</strong>，如果图层也具有非零角半径(nonzero corner radius)，则<strong>不能将</strong>图层标记为不透明。</p><h3 id="Layers-Support-a-Corner-Radius"><a href="#Layers-Support-a-Corner-Radius" class="headerlink" title="Layers Support a Corner Radius"></a>Layers Support a Corner Radius</h3><p>角半径(corner radius)是一种视觉装饰，可以**遮盖(mask)**图层边界矩形的一部分角落，以允许底层内容显示，如下图所示。</p><p><img src="https://sat02pap001files.storage.live.com/y4mxyvtoauyJ85JUNrs-uwua7n_iOjREbp3aNkbJHW739lbATfWEXsNRuzS2E-No-BbZBQ9M1TghFQmZ-XRZZFN27d7oU9nh0v00oTruhu5IEh8B34D_djzYGOI5yFPLgNXcVdRs0-s4VmH_dCOzvVs8hhcA252WTLPTbr5MaWD7tef8WuGMA73Hug4V5XfuJcf?width=1015&height=694&cropmode=none" alt="A corner radius on a layer"></p><p>因为它涉及应用透明蒙版，所以角半径<strong>不会影响图层</strong>内容属性中的图像，<strong>除非</strong> masksToBounds 属性设置为 YES 。但是，角半径始终会影响图层的 Background 和 Border 的绘制方式。 </p><p>设置 layer.cornerRadius 即可完成这种效果。</p><h3 id="Layers-Support-Built-In-Shadows"><a href="#Layers-Support-Built-In-Shadows" class="headerlink" title="Layers Support Built-In Shadows"></a>Layers Support Built-In Shadows</h3><p>CALayer 类有几个用于配置阴影效果的属性。 阴影使图层看起来好像浮在其底层内容之上，从而增加了图层的深度。 默认情况下，图层阴影的不透明度值设置为 0 ，这有效地隐藏了阴影。将不透明度更改为非零值会导致 Core Animation 绘制阴影。由于默认情况下阴影直接位于图层下方，因此可能还需要先更改阴影的偏移量，然后才能看到它。但重要的是要记住，为阴影指定的偏移量是使用图层的原生坐标系统应用的，这在 iOS 和 OS X 上是不同的。</p><p><img src="https://sat02pap001files.storage.live.com/y4mT_Cl_oVEDeLc4b_huquuXlt9CHbtFmaRsgUW4cWchBDwysZJ4Oo0SWXHUWS7BRxGwd_mkKNJ6_EoZtnwRwigqP78ehj15LtmSePtD8PwXEd9xyQJbWunUOZzuzbu6X77Z_mTlVhtgtuOHQzDoD3ZWFL0p5AXBwF3Du1XTTKlxLVRYRImeglNArBBxQLn3Eb_?width=691&height=437&cropmode=none" alt="Applying a shadow to a layer"></p><p>实现向下的阴影， iOS y 为正值，而 OS X 则为负值。</p><p>向图层添加阴影时，阴影是<strong>图层内容的一部分</strong>，但实际上是在图层的<strong>边界矩形之外</strong>。 因此，如果为图层启用 masksToBounds 属性，则会在<strong>边缘周围剪切阴影效果</strong>， 如果图层包含任何透明内容，这可能会导致奇怪的效果，即图层正下方的阴影部分仍然可见，但超出图层的部分则不会。 如果想要阴影但又想使用边界遮罩，则使用两个图层而不是一个图层。 将蒙版应用于包含内容的图层，然后将该图层嵌入到启用了阴影效果的完全相同大小的第二层内。 (ps: 阴影嵌套圆角，需要写个 demo 处理玩一下)</p><h2 id="Adding-Custom-Properties-to-a-Layer"><a href="#Adding-Custom-Properties-to-a-Layer" class="headerlink" title="Adding Custom Properties to a Layer"></a>Adding Custom Properties to a Layer</h2><p>CAAnimation 和 CALayer 类都扩展了 键值编码(key-value coding)约定以支持自定义属性。 可以使用此行为将<strong>数据</strong>添加到图层，并使用自定义键检索它。 甚至可以将<strong>操作</strong>与自定义属性关联，以便在更改属性时执行相应的动画。 可以看 “#Key-Value Coding Compliant Container Classes#” 和 “#Changing a Layer’s Default Behavior#”。</p><h2 id="Printing-the-Contents-of-a-Layer-Backed-View"><a href="#Printing-the-Contents-of-a-Layer-Backed-View" class="headerlink" title="Printing the Contents of a Layer-Backed View"></a>Printing the Contents of a Layer-Backed View</h2><p>在打印期间，层根据需要重新绘制其内容以适应打印环境。 Core Animation 在渲染到屏幕时通常依赖于缓存的位图，而在打印时会重绘该内容。 特别是，如果图层支持的视图使用 <code>drawRect:</code> 方法提供图层内容，则 Core Animation 会在打印期间再次调用 <code>drawRect:</code> 以生成打印的图层内容。 </p><h1 id="Animating-Layer-Content"><a href="#Animating-Layer-Content" class="headerlink" title="Animating Layer Content"></a>Animating Layer Content</h1><p>Core Animation 提供的基础架构可以轻松创建应用层的复杂动画，并通过扩展创建拥有这些层的任何视图。 示例包括更改图层框架矩形的大小(frame)，更改其在屏幕上的位置(position)，应用旋转变换(rotation transform)或更改其不透明度(opacity)。 使用 Core Animation ，启动动画通常只需更改属性即可(隐式动画)，但也可以创建动画并明确设置动画参数(显式动画)。</p><p>关于创建更高级的动画，情况”#Advanced Animation Tricks#”。</p><h2 id="Animating-Simple-Changes-to-a-Layer’s-Properties"><a href="#Animating-Simple-Changes-to-a-Layer’s-Properties" class="headerlink" title="Animating Simple Changes to a Layer’s Properties"></a>Animating Simple Changes to a Layer’s Properties</h2><p>可以根据需要<strong>隐式或显式地</strong>执行简单的动画。 <strong>隐式动画使用默认的计时和动画属性来执行动画</strong>，而显式动画则要求使用动画对象<strong>自己配置</strong>这些属性。 因此，隐式动画非常适合想要在没有大量代码的情况下进行更改的情况，并且默认时间适合业务需求。</p><p>简单的动画涉及更改图层的属性，让 Core Animation 随时间动画显示这些更改。 图层定义了许多影响图层可见外观的属性。 更改其中一个属性是一种为外观更改设置动画的方法。 例如，将图层的不透明度从 1.0 更改为 0.0 会导致图层淡出并变为透明。</p><p>要触发隐式动画，所要做的就是<strong>更新图层对象的属性</strong>。 在图层树中修改图层对象时，这些对象会立即反映这些更改。 但是，图层对象的视觉外观<strong>不会立即</strong>更改(ps: 应该是需要等待下个 runloop)。 相反， Core Animation 使用所做的更改<strong>作为触发器来创建和安排</strong>一个或多个隐式动画以供执行。 因此，进行类似于代码清单 3-1 中的更改会导致 Core Animation 创建动画对象，并安排该动画从<strong>下一个更新周期</strong>开始运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-1  Animating a change implicitly</span><br><span class="line">theLayer.opacity &#x3D; 0.0;</span><br></pre></td></tr></table></figure><p>若要使用动画对象显式进行相同更改，请创建 CABasicAnimation 对象并使用该对象配置动画参数。 可以在将动画添<strong>加到图层之前</strong>设置动画的开始和结束值，更改持续时间或更改任何其他动画参数。 代码清单 3-2 显示了如何使用动画对象淡出图层。 创建对象时，指定要设置动画的属性的键路径(key path)，然后设置动画参数。 要执行动画，可以使用 <code>addAnimation:forKey:</code> 方法将其添加到要设置动画的图层。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-2  Animating a change explicitly</span><br><span class="line">CABasicAnimation* fadeAnim &#x3D; [CABasicAnimation animationWithKeyPath:@&quot;opacity&quot;];</span><br><span class="line">fadeAnim.fromValue &#x3D; [NSNumber numberWithFloat:1.0];</span><br><span class="line">fadeAnim.toValue &#x3D; [NSNumber numberWithFloat:0.0];</span><br><span class="line">fadeAnim.duration &#x3D; 1.0;</span><br><span class="line">[theLayer addAnimation:fadeAnim forKey:@&quot;opacity&quot;];</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Change the actual data value in the layer to the final value.</span><br><span class="line">theLayer.opacity &#x3D; 0.0;</span><br></pre></td></tr></table></figure><p>提示：创建显式动画时，建议始终为动画对象的 <strong>fromValue</strong> 属性指定值。 如果未指定此属性的值， Core Animation 将使用图层的当前值作为起始值。 如果已将属性更新为其最终值，则可能无法获得所需的结果。</p><p>与<strong>更新图层对象的数据值的</strong>隐式动画不同，<strong>显式动画不会修改图层树中的数据，显式动画仅生成动画</strong>。在动画结束时， Core Animation 从图层中<strong>移除</strong>动画对象，并使用<strong>其当前数据值重绘图层</strong>。如果希望显式动画的更改是永久性的，则还必须更新图层的属性，如上例所示。 </p><p>隐式和显式动画通常在当前运行循环(run loop)周期<strong>结束后开始执行</strong>，并且当前线程<strong>必须具有运行循环</strong>才能执行动画。如果更改多个属性，或者向图层添加多个动画对象，则会<strong>同时对</strong>所有这些属性更改进行动画处理。例如，可以通过同时配置两个动画来淡化图层，同时将其移出屏幕。但是，还可以将动画对象配置为在特定时间启动。有关修改动画定时的更多信息，请参阅”#Customizing the Timing of an Animation#”。 (session 2011.421 P20 也有提到)</p><h2 id="Using-a-Keyframe-Animation-to-Change-Layer-Properties"><a href="#Using-a-Keyframe-Animation-to-Change-Layer-Properties" class="headerlink" title="Using a Keyframe Animation to Change Layer Properties"></a>Using a Keyframe Animation to Change Layer Properties</h2><p>基于属性的动画(property-based animation)将属性从起始值更改为结束值，而 CAKeyframeAnimation 对象允许以不是线性的方式设置一组目标值的动画。 关键帧动画由一组目标数据值和每个值到达的时间组成。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-3  Creating a bounce keyframe animation (用 path 来处理)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; create a CGPath that implements two arcs (a bounce)</span><br><span class="line">CGMutablePathRef thePath &#x3D; CGPathCreateMutable();</span><br><span class="line">CGPathMoveToPoint(thePath,NULL,74.0,74.0);</span><br><span class="line">CGPathAddCurveToPoint(thePath,NULL,74.0,500.0,</span><br><span class="line">                                   320.0,500.0,</span><br><span class="line">                                   320.0,74.0);</span><br><span class="line">CGPathAddCurveToPoint(thePath,NULL,320.0,500.0,</span><br><span class="line">                                   566.0,500.0,</span><br><span class="line">                                   566.0,74.0);</span><br><span class="line"> </span><br><span class="line">CAKeyframeAnimation * theAnimation;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Create the animation object, specifying the position property as the key path.</span><br><span class="line">theAnimation&#x3D;[CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];</span><br><span class="line">theAnimation.path&#x3D;thePath;</span><br><span class="line">theAnimation.duration&#x3D;5.0;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Add the animation to the layer.</span><br><span class="line">[theLayer addAnimation:theAnimation forKey:@&quot;position&quot;];</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Specifying-Keyframe-Values"><a href="#Specifying-Keyframe-Values" class="headerlink" title="Specifying Keyframe Values"></a>Specifying Keyframe Values</h3><p>api 的相关用法，具体看文档吧。</p><h3 id="Specifying-the-Timing-of-a-Keyframe-Animation"><a href="#Specifying-the-Timing-of-a-Keyframe-Animation" class="headerlink" title="Specifying the Timing of a Keyframe Animation"></a>Specifying the Timing of a Keyframe Animation</h3><p>api 的相关用法，具体看文档吧。</p><h2 id="Stopping-an-Explicit-Animation-While-It-Is-Running"><a href="#Stopping-an-Explicit-Animation-While-It-Is-Running" class="headerlink" title="Stopping an Explicit Animation While It Is Running"></a>Stopping an Explicit Animation While It Is Running</h2><p>动画通常会一直运行直到完成，但如果需要，可以使用以下技术之一提前停止：</p><ul><li>要从图层中删除单个动画对象，请调用图层的 <code>removeAnimationForKey:</code> 方法以删除动画对象。此方法使用传递给 <code>addAnimation:forKey:</code> 方法的键来标识动画。 key 不能为 nil。</li><li>要从图层中删除所有动画对象，请调用图层的 <code>removeAllAnimations</code> 方法。 此方法<strong>立即删除所有正在进行的</strong>动画，并使用其当前状态信息重新绘制图层。</li></ul><p><strong>注意</strong>：无法直接从图层中删除隐式动画。</p><p>从图层中删除动画时， Core Animation 会通过使用当前值重新绘制图层。因为当前值通常是动画的结束值，这可能导致图层的外观<strong>突然跳跃</strong>。如果希望图层的外观保持在动画<strong>最后一帧的</strong>位置，则可以使用呈现树中的对象检索这些最终值并将其设置在图层树中的对象上。</p><h2 id="Animating-Multiple-Changes-Together"><a href="#Animating-Multiple-Changes-Together" class="headerlink" title="Animating Multiple Changes Together"></a>Animating Multiple Changes Together</h2><p>如果要同时将多个动画应用于图层对象，可以使用 CAAnimationGroup 对象将它们组合在一起。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 3-4  Animating two animations together (同时修改边框宽度和颜色)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Animation 1</span><br><span class="line">CAKeyframeAnimation* widthAnim &#x3D; [CAKeyframeAnimation animationWithKeyPath:@&quot;borderWidth&quot;];</span><br><span class="line">NSArray* widthValues &#x3D; [NSArray arrayWithObjects:@1.0, @10.0, @5.0, @30.0, @0.5, @15.0, @2.0, @50.0, @0.0, nil];</span><br><span class="line">widthAnim.values &#x3D; widthValues;</span><br><span class="line">widthAnim.calculationMode &#x3D; kCAAnimationPaced;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Animation 2</span><br><span class="line">CAKeyframeAnimation* colorAnim &#x3D; [CAKeyframeAnimation animationWithKeyPath:@&quot;borderColor&quot;];</span><br><span class="line">NSArray* colorValues &#x3D; [NSArray arrayWithObjects:(id)[UIColor greenColor].CGColor,</span><br><span class="line">            (id)[UIColor redColor].CGColor, (id)[UIColor blueColor].CGColor,  nil];</span><br><span class="line">colorAnim.values &#x3D; colorValues;</span><br><span class="line">colorAnim.calculationMode &#x3D; kCAAnimationPaced;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Animation group</span><br><span class="line">CAAnimationGroup* group &#x3D; [CAAnimationGroup animation];</span><br><span class="line">group.animations &#x3D; [NSArray arrayWithObjects:colorAnim, widthAnim, nil];</span><br><span class="line">group.duration &#x3D; 5.0;</span><br><span class="line"> </span><br><span class="line">[myLayer addAnimation:group forKey:@&quot;BorderChanges&quot;];</span><br></pre></td></tr></table></figure><p><strong>将动画分组在一起的更高级方法是使用事务对象</strong>(transaction object)。 事务提供了更大的灵活性，通过允许创建嵌套的动画集并为每个动画分配不同的动画参数。 有关如何使用事务对象的信息，请参阅”#Explicit Transactions Let You Change Animation Parameters#”。</p><h2 id="Detecting-the-End-of-an-Animation"><a href="#Detecting-the-End-of-an-Animation" class="headerlink" title="Detecting the End of an Animation"></a>Detecting the End of an Animation</h2><p>Core Animation 支持检测动画开始或结束的时间。这些通知是进行与动画相关的任何内务(housekeeping)处理任务的好时机。例如，可以使用开始通知来设置一些相关的状态信息，并使用相应的结束通知来拆除该状态。</p><p>有两种不同的方式可以通知动画的状态：</p><ul><li>使用 setCompletionBlock: 方法将完成块(completion block)添加到当前事务。当事务中的所有动画完成后，事务将执行完成块。</li><li>将委托分配给 CAAnimation 对象并实现 animationDidStart: 和 animationDidStop:finished: 委托方法。</li></ul><p>如果要将两个动画链接在一起，以便在另一个完成时启动另外一个动画，<strong>请不要使用动画通知</strong>。而是使用动画对象的 beginTime 属性在所需的时间启动每个属性。要将两个动画链接在一起，请将第二个动画的开始时间设置为第一个动画的结束时间。有关动画和计时值的更多信息，请参阅”#Customizing the Timing of an Animation#”。 (session 2011.421 P51 也有讲到。三个气球依次跳的例子)</p><h2 id="How-to-Animate-Layer-Backed-Views"><a href="#How-to-Animate-Layer-Backed-Views" class="headerlink" title="How to Animate Layer-Backed Views"></a>How to Animate Layer-Backed Views</h2><p>如果图层属于图层支持的视图，则建议创建动画的方法是使用 UIKit 或 AppKit 提供的基于视图的动画接口(view-based animation interfaces)。 有一些方法可以使用 Core Animation 接口直接为图层设置动画，但是如何创建这些动画取决于目标平台。</p><h3 id="Rules-for-Modifying-Layers-in-iOS"><a href="#Rules-for-Modifying-Layers-in-iOS" class="headerlink" title="Rules for Modifying Layers in iOS"></a>Rules for Modifying Layers in iOS</h3><p>由于 iOS 视图始终具有图层，因此 UIView 类本身直接从层对象派生其大部分数据。因此，<strong>对图层所做的更改也会自动反映在视图对象中</strong>(ps: 前面 “The Relationship Between Layers and Views” 也有提到)。 此行为意味着可以使用 Core Animation 或 UIView 接口进行更改。</p><p>如果要使用 Core Animation 类来启动动画，则<strong>必须从基于视图的动画块中</strong>发出所有 Core Animation 调用。 <strong>UIView 类默认禁用图层动画，但在动画块内重新启用它们</strong>。因此，在动画块之外所做的任何更改都不会生成动画。代码清单3-5显示了如何隐式更改图层的不透明度及其显式位置的示例。在此示例中， myNewPosition 变量预先计算并由块捕获。两个动画同时开始，但不透明度动画以默认时序运行，而位置动画以其动画对象中指定的时间运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; Listing 3-5  Animating a layer attached to an iOS view</span><br><span class="line"></span><br><span class="line">[UIView animateWithDuration:1.0 animations:^&#123;</span><br><span class="line">   &#x2F;&#x2F; Change the opacity implicitly.</span><br><span class="line">   myView.layer.opacity &#x3D; 0.0;</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; Change the position explicitly.</span><br><span class="line">   CABasicAnimation* theAnim &#x3D; [CABasicAnimation animationWithKeyPath:@&quot;position&quot;];</span><br><span class="line">   theAnim.fromValue &#x3D; [NSValue valueWithCGPoint:myView.layer.position];</span><br><span class="line">   theAnim.toValue &#x3D; [NSValue valueWithCGPoint:myNewPosition];</span><br><span class="line">   theAnim.duration &#x3D; 3.0;</span><br><span class="line">   [myView.layer addAnimation:theAnim forKey:@&quot;AnimateFrame&quot;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="Rules-for-Modifying-Layers-in-OS-X"><a href="#Rules-for-Modifying-Layers-in-OS-X" class="headerlink" title="Rules for Modifying Layers in OS X"></a>Rules for Modifying Layers in OS X</h3><p>OS X 先不管。</p><h3 id="Remember-to-Update-View-Constraints-as-Part-of-Your-Animation"><a href="#Remember-to-Update-View-Constraints-as-Part-of-Your-Animation" class="headerlink" title="Remember to Update View Constraints as Part of Your Animation"></a>Remember to Update View Constraints as Part of Your Animation</h3><p>如果使用基于约束(constraint-based layout)的布局规则来管理视图的位置，则必须删除可能会影响动画的任何约束，尤其是作为配置该动画的那一部分。 约束会影响对视图的位置或大小所做的任何更改。 它们还会影响视图与其子视图之间的关系。 如果要为这些项中的任何项设置动画，则可以删除约束，进行更改，然后应用所需的任何新约束。 (ps: 先移除约束，进行改变后，在添加新的约束) 具体的去看 <a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/index.html#//apple_ref/doc/uid/TP40010853">Auto Layout Guide</a></p><h1 id="Building-a-Layer-Hierarchy"><a href="#Building-a-Layer-Hierarchy" class="headerlink" title="Building a Layer Hierarchy"></a>Building a Layer Hierarchy</h1><p>大多数情况下，在应用中使用图层的<strong>最佳方法是将它们与视图对象结合使用</strong>。 但是，有时可能需要通过向其添加其他图层对象来增强视图层次结构。 可以在使用图层时<strong>使用图层提供更好的性能</strong>，或者让实现仅使用视图难以执行的功能。 在这些情况下，需要知道如何管理您创建的图层层次结构。 </p><h2 id="Arranging-Layers-into-a-Layer-Hierarchy"><a href="#Arranging-Layers-into-a-Layer-Hierarchy" class="headerlink" title="Arranging Layers into a Layer Hierarchy"></a>Arranging Layers into a Layer Hierarchy</h2><p>Layer 层次结构在许多方面类似于 View 层次结构。 将一个图层嵌入另一个图层中，以在嵌入的图层（称为子图层）和父图层（称为超级图层）之间创建父子关系。 这种父子关系影响子层的各个方面。 例如，其内容位于其父级的内容之上，其位置相对于其父级的坐标系指定，并且它受应用于父级的任何变换的影响。</p><h3 id="Adding-Inserting-and-Removing-Sublayers"><a href="#Adding-Inserting-and-Removing-Sublayers" class="headerlink" title="Adding, Inserting, and Removing Sublayers"></a>Adding, Inserting, and Removing Sublayers</h3><ul><li>Adding layers, “addSublayer:” 方法, “zPosition” 属性</li><li>Inserting layers, “insertSublayer:above:   insertSublayer:atIndex:   insertSublayer:below:” 方法,</li><li>Removing layers, “removeFromSuperlayer”方法，</li><li>Exchanging layers, “replaceSublayer:with:”方法，</li></ul><p>在处理自己创建的图层对象时，可以使用上述方法。 <strong>不能用在图层支持的视图的图层</strong>。 但是，图层支持的视图的图层可以作为己创建的图层对象的父级。</p><h3 id="Positioning-and-Sizing-Sublayers"><a href="#Positioning-and-Sizing-Sublayers" class="headerlink" title="Positioning and Sizing Sublayers"></a>Positioning and Sizing Sublayers</h3><p>添加和插入子图层时，必须先设置子图层在屏幕上显示之前的大小和位置。 将子图层添加到图层层次结构后，可以修改子图层的大小和位置，但在创建图层时应养成设置这些值的<strong>习惯</strong>。 (ps: 养成先设置值再添加的好习惯)</p><p>重要：图层的宽高值一直用整数。</p><h3 id="How-Layer-Hierarchies-Affect-Animations"><a href="#How-Layer-Hierarchies-Affect-Animations" class="headerlink" title="How Layer Hierarchies Affect Animations"></a>How Layer Hierarchies Affect Animations</h3><p>某些父图层属性<strong>可能会影响</strong>应用于其子图层的任何动画的行为。一个这样的属性是 speed 属性，它是动画速度的乘数。默认情况下，此属性的值设置为 1.0 ，但将其更改为 2.0 会导致动画以原始速度的两倍运行，从而在一半的时间内完成。此属性不仅会影响为其设置的图层，<strong>还会</strong>影响该图层的子图层。这种变化也是倍增的，如果子层及其父层都具有 2.0 的速度，则子层上的动画以其原始速度的四倍运行。(ps: 父层的值影响子层。)</p><p>大多数其他图层更改 以可预测的方式 影响任何包含的子图层。例如，将<strong>旋转变换</strong>应用于图层会旋转该图层及其所有子图层。同样，更改图层的<strong>不透明度</strong>会更改其子图层的不透明度。 对图层大小的更改遵循”#Adjusting the Layout of Your Layer Hierarchies#”。</p><h2 id="Adjusting-the-Layout-of-Your-Layer-Hierarchies"><a href="#Adjusting-the-Layout-of-Your-Layer-Hierarchies" class="headerlink" title="Adjusting the Layout of Your Layer Hierarchies"></a>Adjusting the Layout of Your Layer Hierarchies</h2><p>Core Animation 支持多种选项，用于调整子层的大小和位置以响应其超层的更改。 在 iOS 中，图层支持的视图的普遍使用使得层次结构的创建不那么重要；仅支持手动布局更新。 对于 OS X ，还有其他几个选项可以更轻松地管理图层层次结构。</p><p>仅当使用创建的独立图层对象构建图层层次结构时，图层级布局(Layer-level layout)才有意义。 如果应用的图层都与视图相关联，请使用基于视图的布局支持来更新视图的大小和位置以响应更改。 (ps: 只对独立的图层形成的图层关系才有意义，所以这一节对 iOS 意义不大，都忽略掉。)</p><h3 id="Using-Constraints-to-Manage-Your-Layer-Hierarchies-in-OS-X"><a href="#Using-Constraints-to-Manage-Your-Layer-Hierarchies-in-OS-X" class="headerlink" title="Using Constraints to Manage Your Layer Hierarchies in OS X"></a>Using Constraints to Manage Your Layer Hierarchies in OS X</h3><h3 id="Setting-Up-Autoresizing-Rules-for-Your-OS-X-Layer-Hierarchies"><a href="#Setting-Up-Autoresizing-Rules-for-Your-OS-X-Layer-Hierarchies" class="headerlink" title="Setting Up Autoresizing Rules for Your OS X Layer Hierarchies"></a>Setting Up Autoresizing Rules for Your OS X Layer Hierarchies</h3><h3 id="Manually-Laying-Out-Your-Layer-Hierarchies"><a href="#Manually-Laying-Out-Your-Layer-Hierarchies" class="headerlink" title="Manually Laying Out Your Layer Hierarchies"></a>Manually Laying Out Your Layer Hierarchies</h3><h2 id="Sublayers-and-Clipping"><a href="#Sublayers-and-Clipping" class="headerlink" title="Sublayers and Clipping"></a>Sublayers and Clipping</h2><p>与视图不同，父图层不会自动剪切位于其边界矩形之外的子图层的内容。 相反，父层允许其子层默认显示完整。 但是，可以通过将图层的 masksToBounds 属性设置为 YES ，来重新启用剪切。</p><p>图层的剪切蒙版的形状包括图层的角半径（如果指定了一个，就是说裁剪的时候角半径还是留着的）。 下图显示了一个图层，该图层演示了 masksToBounds 属性如何影响具有圆角的图层。 当属性设置为 NO 时，即使子图层超出其父图层的边界，也会完整显示子图层。 将属性更改为 YES 会导致其内容被剪裁。<br><img src="https://sat02pap001files.storage.live.com/y4m86FPkvdLWmhKLBqUSImFqSk5MzYho90X31EGmrAKsnh7FX21je1DAkfQgWpabXN5fLpW7MxF_zqCSAl9MAHQuVGIdxV_vx8-ULd7GXb721jXy8sRkqrVOOKRajeN7sH8oeb2mnePJiqWg6-BybcVnHfiMRZVpA11hEajpb1R1Xaxm1oszSTBVl4phvBS7RwQ?width=930&height=769&cropmode=none" alt="Clipping sublayers to the parent’s bounds"></p><h2 id="Converting-Coordinate-Values-Between-Layers"><a href="#Converting-Coordinate-Values-Between-Layers" class="headerlink" title="Converting Coordinate Values Between Layers"></a>Converting Coordinate Values Between Layers</h2><p>有时，可能需要将一个图层中的坐标值转换为另一个图层中<strong>同一屏幕位置</strong>的坐标值。 CALayer 类提供了一组简单的转换例程，可以将它们用于此目的：</p><ul><li>convertPoint:fromLayer:</li><li>convertPoint:toLayer:</li><li>convertRect:fromLayer:</li><li>convertRect:toLayer:</li></ul><p>除了转换 Point 和 Rect 值之外，还可以使用 <code>convertTime:fromLayer:</code> 和 <code>convertTime:toLayer:</code> 方法在图层之间转换时间值。 每个层定义自己的本地时间空间，并使用该时间空间将动画的开始和结束与系统的其余部分同步。 这些时间空间默认是同步的；但是，如果更改一组图层的<strong>动画速度</strong>，则这些图层的时间空间会相应更改。 可以使用时间转换(time conversion)方法来考虑任何此类因素，并确保两个图层的时间同步。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 参考代码， self.view 是 button 的 superView.superView....</span><br><span class="line">var buttonInViewPoint &#x3D; button.convert(self.view.frame.origin, to: self.view)</span><br></pre></td></tr></table></figure><h1 id="Advanced-Animation-Tricks"><a href="#Advanced-Animation-Tricks" class="headerlink" title="Advanced Animation Tricks"></a>Advanced Animation Tricks</h1><p>有许多方法可以配置基于属性(property-based)或关键帧(keyframe)的动画，以便完成更多操作。 需要一起或按顺序执行多个动画的应用程序，可以使用更高级的行为来同步这些动画的时序或将它们链接(chain)在一起。 还可以使用<strong>其他类型的动画对象</strong>来创建视觉过渡和其他有趣的动画效果。</p><h2 id="Transition-Animations-Support-Changes-to-Layer-Visibility"><a href="#Transition-Animations-Support-Changes-to-Layer-Visibility" class="headerlink" title="Transition Animations Support Changes to Layer Visibility"></a>Transition Animations Support Changes to Layer Visibility</h2><p><strong>顾名思义，过渡动画对象为图层创建动画视觉过渡</strong>。过渡对象(transition objects)最常见的用途是以协调的方式(coordinated manner)为一个图层的显示和另一个图层的消失设置动画。与基于属性的动画（动画更改图层的一个属性）不同，过渡动画<strong>操纵图层的缓存图像</strong>以创建 通过单独更改属性而难以或无法完成的 视觉效果。标准的过渡类型允许执行 reveal, push, move 或 crossfade 动画。在 OS X 上，还可以使用 Core Image 过滤器创建使用其他类型效果。</p><p>要执行过渡动画，要创建 CATransition 对象并将其添加到过渡中涉及的层上。 可以使用过渡对象指定要执行的<strong>过渡类型</strong>以及过渡动画的<strong>起点和终点</strong>。也不需要使用整个过渡动画，过渡对象允许动画时指定要使用的开始和结束进度值。这些值允许在其中点处开始或结束动画。</p><p>代码清单 5-1 显示了用于在两个视图之间创建动画 push 过渡的代码。在示例中， myView1 和 myView2 都位于同一父视图中的相同位置，但当前只能看到 myView1 。 push 过渡导致 myView1 向左滑动并淡出，直到隐藏，而 myView2 从右侧滑入并变为可见。更新两个视图的隐藏属性可确保在<strong>动画结束时</strong>两个视图的可见性都是正确的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 5-1  Animating a transition between two views in iOS</span><br><span class="line"></span><br><span class="line">CATransition* transition &#x3D; [CATransition animation];</span><br><span class="line">transition.startProgress &#x3D; 0;</span><br><span class="line">transition.endProgress &#x3D; 1.0;</span><br><span class="line">transition.type &#x3D; kCATransitionPush;</span><br><span class="line">transition.subtype &#x3D; kCATransitionFromRight;</span><br><span class="line">transition.duration &#x3D; 1.0;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Add the transition animation to both layers</span><br><span class="line">[myView1.layer addAnimation:transition forKey:@&quot;transition&quot;];</span><br><span class="line">[myView2.layer addAnimation:transition forKey:@&quot;transition&quot;];</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Finally, change the visibility of the layers.</span><br><span class="line">myView1.hidden &#x3D; YES;</span><br><span class="line">myView2.hidden &#x3D; NO;</span><br></pre></td></tr></table></figure><p>当两个图层涉及同一个过渡时，可以为两个图层使用相同的过渡对象。 使用相同的转换对象还可以简化必须编写的代码。 但是，也可以使用不同的过渡对象，如果每个层的过渡参数不同，则肯定需要这样做。</p><h2 id="Customizing-the-Timing-of-an-Animation"><a href="#Customizing-the-Timing-of-an-Animation" class="headerlink" title="Customizing the Timing of an Animation"></a>Customizing the Timing of an Animation</h2><p>时序(timing)是动画的重要组成部分，通过 Core Animation, 可以通过 CAMediaTiming 协议的方法和属性为动画指定<strong>精确的时序信息</strong>。两个核心动画类采用此协议。  CAAnimation 类采用它，以便可以在动画<strong>对象中指定</strong>时序信息。  CALayer 也采用它，以便可以<strong>为隐式动画配置</strong>一些与时序相关的功能，尽管包装这些动画的隐式事务对象通常提供<strong>优先的默认时序信息</strong>。</p><p>在考虑时间和动画时，了解图层对象如何随时间工作非常重要。每个图层都有自己的<strong>本地时间</strong>，用于管理动画计时。通常，两个不同层的本地时间足够接近，可以为每个层指定相同的时间值，用户可能不会注意到任何内容。但是，图层的本地时间可以通过其父层或其自己的时序参数进行修改。例如，更改图层的速度(speed)属性会导致该图层（及其子图层）上的动画持续时间按比例更改。</p><p>为了帮助确保时间值适合给定图层， CALayer 类定义 <code>convertTime:fromLayer:</code> 和 <code>convertTime:toLayer:</code> 方法。可以使用这些方法将固定时间值转换为图层的本地时间，或将时间值从一个图层转换为另一个图层。这些方法会考虑可能影响图层本地时间的媒体计时属性(media timing properties), 并返回可与其他图层一起使用的值。代码清单5-3显示了一个示例，应该定期使用该示例来获取图层的当前本地时间。 CACurrentMediaTime 函数是一个便捷函数，它返回计算机当前的时钟时间，该方法采用该时间并转换为图层的本地时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFTimeInterval localLayerTime &#x3D; [myLayer convertTime:CACurrentMediaTime() fromLayer:nil];</span><br></pre></td></tr></table></figure><p>一旦在图层的本地时间中有时间值后，可以使用该值更新动画对象或图层的 与时序相关的 属性。使用这些时序属性，可以实现一些有趣的动画行为，包括：</p><ul><li>使用 beginTime 属性设置动画的开始时间。通常，<strong>动画在下一个更新周期开始</strong>。可以使用 beginTime 参数将动画开始时间延迟几秒钟。将两个动画链接在一起的方法是，将一个动画的开始时间设置为与另一个动画的结束时间相匹配。 如果要 延迟 动画的开始，可能还需要将 fillMode 属性设置为 kCAFillModeBackwards 。即使图层树中的图层对象包含不同的值，此填充模式也会使<strong>图层显示动画的起始值</strong>。如果没有此填充模式，将看到在动画开始执行之前跳转到<strong>最终值</strong>。其他填充模式也可用。</li><li>autoreverses 属性使动画在指定的持续时间内执行，然后返回到动画的起始值。可以将此属性与 repeatCount 属性组合，以在起始值和结束值之间来回动画。将 repeatCount 设置为自动回转动画的整数（例如 1.0）会导致动画停止在其起始值上。添加额外的半步（例如为1.5）会导致动画停止在其结束值上。</li><li>将 timeOffset 属性与组动画一起使用，可以在以后的时间启动某些动画。 (ps: 见下面的代码清单 5-4 ，有用到 timeOffset)</li></ul><h2 id="Pausing-and-Resuming-Animations"><a href="#Pausing-and-Resuming-Animations" class="headerlink" title="Pausing and Resuming Animations"></a>Pausing and Resuming Animations</h2><p>要暂停动画，可以利用层 采用 CAMediaTiming 协议并将图层动画的速度设置为 0.0。 将速度设置为零会暂停动画，直到将值更改回非零值。 代码清单5-4显示了一个简单的示例，说明如何在以后暂停和恢复动画。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 5-4  Pausing and resuming a layer’s animations</span><br><span class="line"></span><br><span class="line">-(void)pauseLayer:(CALayer*)layer &#123;</span><br><span class="line">   CFTimeInterval pausedTime &#x3D; [layer convertTime:CACurrentMediaTime() fromLayer:nil];</span><br><span class="line">   layer.speed &#x3D; 0.0;</span><br><span class="line">   layer.timeOffset &#x3D; pausedTime;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">-(void)resumeLayer:(CALayer*)layer &#123;</span><br><span class="line">   CFTimeInterval pausedTime &#x3D; [layer timeOffset];</span><br><span class="line">   layer.speed &#x3D; 1.0;</span><br><span class="line">   layer.timeOffset &#x3D; 0.0;</span><br><span class="line">   layer.beginTime &#x3D; 0.0;</span><br><span class="line">   CFTimeInterval timeSincePause &#x3D; [layer convertTime:CACurrentMediaTime() fromLayer:nil] - pausedTime;</span><br><span class="line">   layer.beginTime &#x3D; timeSincePause;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Explicit-Transactions-Let-You-Change-Animation-Parameters"><a href="#Explicit-Transactions-Let-You-Change-Animation-Parameters" class="headerlink" title="Explicit Transactions Let You Change Animation Parameters"></a>Explicit Transactions Let You Change Animation Parameters</h2><p><strong>对图层所做的每项更改都必须是事务(transaction)的一部分。 CATransaction 类在适当的时间管理动画的创建和分组及其执行。</strong> 在大多数情况下，不需要创建自己的事务。 每当向其中一个图层添加显式或隐式动画时，Core Animation 都会<strong>自动创建</strong>隐式事务。但是，还可以创建显式事务以更精确地管理这些动画。(ps: 事务是管理动画的，很重要，下面禁用隐式动画也用到了显式事务；见 wwdc-2011-121 “CATransaction and when views get rendered”)</p><p>可以使用 CATransaction 类的方法创建和管理事务。 要启动（并隐式创建）新事务，请调用 begin 类方法; 要结束该事务，请调用 commit 类方法。 想 在这些调用之间的更改 成为事务的一部分。 例如，要更改图层的两个属性，可以使用代码清单5-5中的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 5-5  Creating an explicit transaction</span><br><span class="line"></span><br><span class="line">[CATransaction begin];</span><br><span class="line">theLayer.zPosition&#x3D;200.0;</span><br><span class="line">theLayer.opacity&#x3D;0.0;</span><br><span class="line">[CATransaction commit];</span><br></pre></td></tr></table></figure><p>使用事务的主要原因之一，是在显式事务的<strong>范围内，可以更改</strong>持续时间，计时功能和其他参数。 还可以为整个事务分配完成块(completion block)，以便在动画组完成时通知应用。 更改动画参数需要使用 <code>setValue:forKey:</code> 方法修改事务字典中的相应键。 例如，要将默认持续时间更改为 10 秒，将更改 kCATransactionAnimationDuration 键，如代码清单5-6所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 5-6  Changing the default duration of animations</span><br><span class="line"></span><br><span class="line">[CATransaction begin];</span><br><span class="line">[CATransaction setValue:[NSNumber numberWithFloat:10.0f]</span><br><span class="line">                 forKey:kCATransactionAnimationDuration];</span><br><span class="line">&#x2F;&#x2F; Perform the animations</span><br><span class="line">[CATransaction commit];</span><br></pre></td></tr></table></figure><p>还可以嵌套处理。 只有在为最外层事务提交更改后， Core Animation 才会开始关联的动画。 (ps: begin 和 commit 方法一定要相匹配)</p><h2 id="Adding-Perspective-to-Your-Animations"><a href="#Adding-Perspective-to-Your-Animations" class="headerlink" title="Adding Perspective to Your Animations"></a>Adding Perspective to Your Animations</h2><p>应用程序可以在三维空间中操作图层，但为了简单起见，Core Animation 使用平行投影显示图层，该投影基本上将场景展平为二维平面。 修改场景的透视图时，需要修改包含正在查看的图层的<strong>父层的</strong> sublayerTransform 矩阵。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 5-8  Adding a perspective transform to a parent layer</span><br><span class="line"></span><br><span class="line">CATransform3D perspective &#x3D; CATransform3DIdentity;</span><br><span class="line">perspective.m34 &#x3D; -1.0&#x2F;eyePosition;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Apply the transform to a parent layer.</span><br><span class="line">myParentLayer.sublayerTransform &#x3D; perspective;</span><br></pre></td></tr></table></figure><p>eyePosition 值越大，场景越平坦，而值越小，层间的视觉差异越大。 配置父图层后，可以<strong>更改任何</strong>子图层的 zPosition 属性，并根据它们与眼睛位置的相对距离观察它们的大小如何变化。 (ps: 三维默认是关闭的，要设置父图层的 sublayerTransform 属性后，再设置子图层的 zPosition 才会起作用)</p><h1 id="Changing-a-Layer’s-Default-Behavior"><a href="#Changing-a-Layer’s-Default-Behavior" class="headerlink" title="Changing a Layer’s Default Behavior"></a>Changing a Layer’s Default Behavior</h1><p><strong>Core Animation 使用操作对象(action object)为图层实现其隐式动画行为</strong>。 操作对象是符合 CAAction 协议的对象，它定义了要在图层上执行的某些相关<strong>行为</strong>。 所有 CAAnimation 对象都实现了该协议，并且通常会分配这些对象，以便在图层属性发生更改时执行。 (ps: session 2011.421 P26 也有讲到。)</p><p>动画属性(animating properties)是一种操作类型，但可以使用我们<strong>想要的几乎任何行为</strong>来定义操作。但是，要做到这一点，必须定义操作对象并将它们与应用程序的图层对象相关联。</p><h2 id="Custom-Action-Objects-Adopt-the-CAAction-Protocol"><a href="#Custom-Action-Objects-Adopt-the-CAAction-Protocol" class="headerlink" title="Custom Action Objects Adopt the CAAction Protocol"></a>Custom Action Objects Adopt the CAAction Protocol</h2><p>要创建自己的操作对象，采用 CAAction 协议并实现 <code>runActionForKey:object:arguments:</code> 方法。在该方法中，使用可用信息执行要在图层上执行的任何操作。可以使用该方法将动画对象添加到图层，也可以使用它来执行其他任务。(ps: 动画、图层)</p><p>定义操作对象时，必须确定要如何触发该操作。操作的触发器 定义用于稍后注册该操作的 键。可以通过以下任何一种情况触发操作对象：</p><ul><li>其中一个图层属性的值<strong>已更改</strong>。这可以是图层的任何属性，而不仅仅是可动画的属性。 （还可以将操作与添加到图层的<strong>自定义</strong>属性相关联。）标识此操作的键是属性的名称。</li><li>图层变为可见或已添加到图层层次结构中。标识此操作的关键是 kCAOnOrderIn 。</li><li>该图层已从图层层次结构中删除。标识此操作的关键是 kCAOnOrderOut 。</li><li>该图层即将参与过渡动画。标识此操作的关键是 kCATransition 。</li></ul><h2 id="Action-Objects-Must-Be-Installed-On-a-Layer-to-Have-an-Effect"><a href="#Action-Objects-Must-Be-Installed-On-a-Layer-to-Have-an-Effect" class="headerlink" title="Action Objects Must Be Installed On a Layer to Have an Effect"></a>Action Objects Must Be Installed On a Layer to Have an Effect</h2><p>在可以执行操作之前，该图层需要找到要执行的相应操作对象。 与层相关的操作的关键是要修改的属性的名称或标识操作的特殊字符串。 会调用 actionForKey: 方法来查找，具体请见官方文档。 (ps: session 2011.421 P26 也有讲到。)</p><p>如果在任何适当的搜索点提供操作对象，则图层将停止其搜索<strong>并执行返回的</strong>操作对象。 当它找到一个动作对象时，该层调用该对象的 runActionForKey:object:arguments: 方法来执行该动作。 如果为给定键定义的操作已经是 CAAnimation 类的实例，则可以使用该方法的<strong>默认实现</strong>来执行动画。 如果要定义符合 CAAction 协议的自定义对象，则必须使用对象的该方法实现来采取适当的操作。</p><p>安装操作对象的位置取决于我们打算如何修改图层，具体请见官方文档。(ps: 跟上面的查找方法类似，请注意自定义属性(custom properties)的处理。)</p><h2 id="Disable-Actions-Temporarily-Using-the-CATransaction-Class"><a href="#Disable-Actions-Temporarily-Using-the-CATransaction-Class" class="headerlink" title="Disable Actions Temporarily Using the CATransaction Class"></a>Disable Actions Temporarily Using the CATransaction Class</h2><p>可以使用 CATransaction 类临时禁用图层操作(layer actions)。 更改图层的属性时， Core Animation <strong>通常会创建一个隐式事务</strong>对象来为更改设置动画。 如果不想为更改设置动画，可以通过创建显式事务并将其 kCATransactionDisableActions 属性设置为 true 来禁用隐式动画。 清单6-2显示了一个代码片段，它在从图层树中删除指定图层时禁用动画。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Listing 6-2  Temporarily disabling a layer’s actions</span><br><span class="line"></span><br><span class="line">[CATransaction begin];</span><br><span class="line">[CATransaction setValue:(id)kCFBooleanTrue</span><br><span class="line">                 forKey:kCATransactionDisableActions];</span><br><span class="line">[aLayer removeFromSuperlayer];</span><br><span class="line">[CATransaction commit];</span><br></pre></td></tr></table></figure><p>(ps: session 2011.421 P25 也有讲到 <code>[CATransaction setDisableActions:YES]</code> 禁用隐式动画。)</p><p>有关使用事务对象管理动画行为的更多信息，请参阅”#Explicit Transactions Let You Change Animation Parameters#”。</p><h1 id="Improving-Animation-Performance"><a href="#Improving-Animation-Performance" class="headerlink" title="Improving Animation Performance"></a>Improving Animation Performance</h1><p>Core Animation 是提高基于应用程序的<strong>动画的帧速率</strong>的好方法，但它的使用<strong>并不能</strong>保证提高性能。 特别是在 OS X 中，仍然必须选择使用 Core Animation 行为的最有效方法。 与所有与性能相关的问题一样，应该使用 Instruments 来<strong>衡量和跟踪</strong>应用程序的性能，以便确保性能得到改善而不是回归。</p><h2 id="Choose-the-Best-Redraw-Policy-for-Your-OS-X-Views"><a href="#Choose-the-Best-Redraw-Policy-for-Your-OS-X-Views" class="headerlink" title="Choose the Best Redraw Policy for Your OS X Views"></a>Choose the Best Redraw Policy for Your OS X Views</h2><p>OS X 先不管。</p><h2 id="Update-Layers-in-OS-X-to-Optimize-Your-Rendering-Path"><a href="#Update-Layers-in-OS-X-to-Optimize-Your-Rendering-Path" class="headerlink" title="Update Layers in OS X to Optimize Your Rendering Path"></a>Update Layers in OS X to Optimize Your Rendering Path</h2><p>OS X 先不管。</p><h2 id="General-Tips-and-Tricks"><a href="#General-Tips-and-Tricks" class="headerlink" title="General Tips and Tricks"></a>General Tips and Tricks</h2><p>有几种方法可以提高图层实现的效率。 但是，与任何此类优化一样，在<strong>尝试优化之前</strong>，应始终<strong>测量代码的当前性能</strong>。 这为提供了一个基线，可用于确定优化是否有效。</p><h3 id="Use-Opaque-Layers-Whenever-Possible"><a href="#Use-Opaque-Layers-Whenever-Possible" class="headerlink" title="Use Opaque Layers Whenever Possible"></a>Use Opaque Layers Whenever Possible</h3><p>将图层的 opaque 属性设置为 YES ，可让 Core Animation 知道它<strong>不需要为图层维护</strong> alpha 通道。 没有 Alpha 通道<strong>意味着合成器(compositor)**不需要将图层的内容与其背景内容混合，这样可以在渲染过程中</strong>节省时间<strong>。 但是，此属性</strong>主要与<strong>作为图层支持视图一部分的图层 或 Core Animation 创建基础图层位图的情况相关。 如果</strong>将图像直接指定<strong>给图层的 contents 属性，则</strong>无论** opaque 属性中的值如何，都<strong>会保留</strong>该图像的 Alpha 通道。</p><h3 id="Use-Simpler-Paths-for-CAShapeLayer-Objects"><a href="#Use-Simpler-Paths-for-CAShapeLayer-Objects" class="headerlink" title="Use Simpler Paths for CAShapeLayer Objects"></a>Use Simpler Paths for CAShapeLayer Objects</h3><p>CAShapeLayer 类通过<strong>在复合(composite)时</strong>将我们提供的路径渲染到位图图像来创建其内容。<strong>优点</strong>是该层总是以尽可能好的分辨率绘制路径，但这种优势是以额外的渲染时间<strong>为代价</strong>的。如果提供的路径很复杂，那么栅格化(rasterizing)该路径可能会过于昂贵。如果图层的大小<strong>经常变化</strong>（因此必须经常重绘），绘制所花费的时间可能会增加并成为<strong>性能瓶颈</strong>。</p><p>优化形状层的绘制时间的一种方法，是将复杂形状<strong>分解为更简单</strong>的形状。使用更简单的路径并在合成器中将多个 CAShapeLayer 对象叠加在一起可以<strong>比</strong>绘制一个大的复杂路径<strong>快得多</strong>。这是因为绘图操作发生在 CPU 上，而合成发生在 GPU 上。与此类性质的任何简化一样，潜在的性能提升<strong>取决于</strong>内容。<strong>因此，在优化之前测量代码的性能尤为重要，这样就可以使用基线进行比较。(优化的准则)</strong> (ps: 分割就是减少 CPU 的工作量，把工作转移到 GPU 上。)</p><h3 id="Set-the-Layer-Contents-Explicitly-for-Identical-Layers"><a href="#Set-the-Layer-Contents-Explicitly-for-Identical-Layers" class="headerlink" title="Set the Layer Contents Explicitly for Identical Layers"></a>Set the Layer Contents Explicitly for Identical Layers</h3><p>如果在多个图层对象中<strong>使用相同的图像</strong>，请自行加载图像并将其<strong>直接指定</strong>给这些图层对象的 contents 属性。 将图像分配给 contents 属性<strong>可防止图层为后备存储分配内存。 相反，该图层使用我们提供的图像作为其后备存储</strong>。 当多个图层使用相同的图像时，这意味着所有这些图层共享相同的内存，而不是为自己分配图像的<strong>副本</strong>。</p><h3 id="Always-Set-a-Layer’s-Size-to-Integral-Values"><a href="#Always-Set-a-Layer’s-Size-to-Integral-Values" class="headerlink" title="Always Set a Layer’s Size to Integral Values"></a>Always Set a Layer’s Size to Integral Values</h3><p>为获得最佳效果，请始终将图层对象的宽度和高度设置为整数值。 虽然使用浮点数指定图层边界的宽度和高度，但图层边界(layer bounds)<strong>最终用于</strong>创建位图图像。 指定宽度和高度的整数值<strong>可简化</strong> Core Animation 在创建和管理<strong>后备存储</strong>和其他图层信息时必须执行的工作。 (ps: bitmap 位图，最终都是加载位图。)</p><h3 id="Use-Asynchronous-Layer-Rendering-As-Needed"><a href="#Use-Asynchronous-Layer-Rendering-As-Needed" class="headerlink" title="Use Asynchronous Layer Rendering As Needed"></a>Use Asynchronous Layer Rendering As Needed</h3><p>在委托的 <code>drawLayer:inContext:</code> 方法或视图的 <code>drawRect:</code> 方法中执行的任何绘图，通常在应用程序的<strong>主线程上同步发生</strong>。 但在某些情况下，同步绘制内容可能<strong>无法提供最佳性能</strong>。 如果注意到动画效果不佳，可以尝试在图层上启用 <code>drawAsynchronously</code> 属性，将这些操作<strong>移动到后台线程</strong>。 如果这样做，请确保绘图代码是<strong>线程安全的</strong>。 和往常一样，在将其放入生产代码<strong>之前，应始终</strong>测量异步绘图的性能。</p><h3 id="Specify-a-Shadow-Path-When-Adding-a-Shadow-to-Your-Layer"><a href="#Specify-a-Shadow-Path-When-Adding-a-Shadow-to-Your-Layer" class="headerlink" title="Specify a Shadow Path When Adding a Shadow to Your Layer"></a>Specify a Shadow Path When Adding a Shadow to Your Layer</h3><p>让 Core Animation <strong>确定阴影的形状(shape)可能很昂贵并影响应用程序的性能</strong>。 不要让 Core Animation 确定阴影的形状，而是使用 CALayer 的 shadowPath 属性显式指定阴影形状。 为此属性指定路径对象时， Core Animation 使用该形状<strong>绘制和缓存</strong>阴影效果。 对于形状<strong>永不变化或很少更改</strong>的图层，可以通过<strong>减少</strong> Core Animation 完成的<strong>渲染量</strong>来大大提高性能。</p><h1 id="Layer-Style-Property-Animations"><a href="#Layer-Style-Property-Animations" class="headerlink" title="Layer Style Property Animations"></a>Layer Style Property Animations</h1><p>在渲染过程中， Core Animation 采用图层的不同属性并按<strong>特定顺序</strong>呈现它们。 此顺序确定图层的最终外观。 本章说明通过设置不同的图层样式属性实现的渲染结果。 </p><h2 id="Geometry-Properties"><a href="#Geometry-Properties" class="headerlink" title="Geometry Properties"></a>Geometry Properties</h2><p>几何相关属性。 frame 是从 bounds 和 position 计算而来的，它是不可以动画的。</p><h2 id="Background-Properties"><a href="#Background-Properties" class="headerlink" title="Background Properties"></a>Background Properties</h2><p>最开始渲染的背景。 (Q: 是不是可以认为，先背景，然后从下往上渲染，也就是下面内容的顺序)</p><p>在 iOS 中的， CALayer.backgroundFilters 设置 filters 是会被忽略的。</p><h2 id="Layer-Content"><a href="#Layer-Content" class="headerlink" title="Layer Content"></a>Layer Content</h2><p>所以有内容的话，会在背景上上面渲染内容。 “#Providing a Layer’s Contents#” 中有提到三种设置内容的方式。</p><h2 id="Sublayers-Content"><a href="#Sublayers-Content" class="headerlink" title="Sublayers Content"></a>Sublayers Content</h2><p>子图层内容是会循环递归渲染的。</p><h2 id="Border-Attributes"><a href="#Border-Attributes" class="headerlink" title="Border Attributes"></a>Border Attributes</h2><p>border 在 content 和 Sublayers Content 的上面。</p><h2 id="Filters-Property"><a href="#Filters-Property" class="headerlink" title="Filters Property"></a>Filters Property</h2><p>只有 OS X 才有用。</p><h2 id="Shadow-Properties"><a href="#Shadow-Properties" class="headerlink" title="Shadow Properties"></a>Shadow Properties</h2><p>没背景颜色的情况下， Shadow 是添加到图层内容上的。</p><h2 id="Opacity-Property"><a href="#Opacity-Property" class="headerlink" title="Opacity Property"></a>Opacity Property</h2><p>不透明度。</p><h2 id="Mask-Properties"><a href="#Mask-Properties" class="headerlink" title="Mask Properties"></a>Mask Properties</h2><p>可以使用 Mask 来遮盖图层内容的全部或部分内容。Mask 本身就是一个图层对象，其 alpha 通道用于确定阻塞和传输的内容。Mask 层内容的<strong>不透明部分允许</strong>底层图像内容透过，而透明部分部分或完全<strong>遮盖</strong>底层内容。</p><h1 id="Animatable-Properties"><a href="#Animatable-Properties" class="headerlink" title="Animatable Properties"></a>Animatable Properties</h1><p>主要是讲了可动画属性的相关默认值。 都是 CABasicAnimation(0.25) 或者 CATransition(0.25) 0.0-1.0 。</p><h1 id="Key-Value-Coding-Extensions"><a href="#Key-Value-Coding-Extensions" class="headerlink" title="Key-Value Coding Extensions"></a>Key-Value Coding Extensions</h1><p>Core Animation 通过 CAAnimation 和 CALayer 扩展了 NSKeyValueCoding 协议。</p><h2 id="Key-Value-Coding-Compliant-Container-Classes"><a href="#Key-Value-Coding-Compliant-Container-Classes" class="headerlink" title="Key-Value Coding Compliant Container Classes"></a>Key-Value Coding Compliant Container Classes</h2><p>你可以设置任意的 key ，就算是 CALayer 没有的也行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 赋值</span><br><span class="line">[theLayer setValue:[NSNumber numberWithInteger:50] forKey:@&quot;someKey&quot;];</span><br><span class="line">&#x2F;&#x2F; 取值</span><br><span class="line">someKeyValue&#x3D;[theLayer valueForKey:@&quot;someKey&quot;];</span><br></pre></td></tr></table></figure><h2 id="Default-Value-Support"><a href="#Default-Value-Support" class="headerlink" title="Default Value Support"></a>Default Value Support</h2><p>子类的话，然后重载 <code>defaultValueForKey:</code> 方法。</p><h2 id="Wrapping-Conventions"><a href="#Wrapping-Conventions" class="headerlink" title="Wrapping Conventions"></a>Wrapping Conventions</h2><p>结构体或者常量值记得包裹和解包。这里例举了一些属性，记得看看。</p><h2 id="Key-Path-Support-for-Structures"><a href="#Key-Path-Support-for-Structures" class="headerlink" title="Key Path Support for Structures"></a>Key Path Support for Structures</h2><p>支持 key path 。注意看这一小节里面的相关 keypath 的含义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setValue:forKeyPath:</span><br><span class="line">valueForKeyPath:</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2011/421/&quot;&gt;Core Animation Essentials&lt;/a&gt;，主要讲了 Core Animation 的一些基础知识。&lt;/p&gt;
&lt;p&gt;讲了一个点击图片 item 有各种效果的 demo 。 &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;点击动画变大 (change bound)&lt;/li&gt;
&lt;li&gt;shrink and grow (UIKit 定时器改变 bound ， CA 可以用 CAMedia timing protocol and repeated animation) &lt;/li&gt;
&lt;li&gt;边框闪烁，颜色变化 (layer.border color is animation property, repeated animation)&lt;/li&gt;
&lt;li&gt;flip 到中心然后回到原处 (2.5D perspective transform)&lt;/li&gt;
&lt;li&gt;边框粒子闪烁效果 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然后后面就是讲 Core Animation 一些基础，所以下面就把&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004514&quot;&gt;Core Animation Programming Guide&lt;/a&gt;的内容大致过一下。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="WWDC" scheme="http://example.com/tags/WWDC/"/>
    
      <category term="AppleDocument" scheme="http://example.com/tags/AppleDocument/"/>
    
  </entry>
  
  <entry>
    <title>Understanding UIKit Rendering(View Programming Guide for iOS)</title>
    <link href="http://example.com/2019/02/24/wwdc-2011-121/"/>
    <id>http://example.com/2019/02/24/wwdc-2011-121/</id>
    <published>2019-02-24T02:23:28.000Z</published>
    <updated>2021-05-24T15:33:13.503Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WWDC"><a href="#WWDC" class="headerlink" title="WWDC"></a>WWDC</h1><p><a href="https://developer.apple.com/videos/play/wwdc2011/121/">Understanding UIKit Rendering</a> 主要讲了显示青蛙的一个 demo ，讲了 round rotate anti-aliased shadow 等效果，先讲了之前做的为什么会错误，后面讲了正确的做法，这个 session 比较简单，相关内容，后续关于渲染的 session 都有讲到。</p><a id="more"></a><h2 id="UIView-and-CALayer"><a href="#UIView-and-CALayer" class="headerlink" title="UIView and CALayer"></a>UIView and CALayer</h2><p>在 iOS 中，每个视图(UIView)都由相应的图层(CALayer)对象支持，被称为图层支持的视图(layer-backed view)。对于不同的绘制要求，我们可以用不同类型的 layer 。 layer 决定视图在屏幕哪里显示。</p><h3 id="Geometry"><a href="#Geometry" class="headerlink" title="Geometry"></a>Geometry</h3><p>frame 包含视图的最小矩形。 不管进行了 transform or scale or rotation 等操作， bound 都不会变，变的是 frame 。因为 frame 不是 layer 的存储属性(store) , 而是计算(computed)属性 , 而是由其他两个属性计算而来的(center(基于父坐标系)、bound(基于自己的坐标系))。 可以有下面的两张图来表示，黄色字体代表 bound ， 白色字体代表 frame 。</p><p><img src="https://github.com/JoakimLiu/BlogPhoto/blob/master/wwdc/2011/121/rotation.png?raw=true" alt="rotation"><br><img src="https://github.com/JoakimLiu/BlogPhoto/blob/master/wwdc/2011/121/scale.png?raw=true" alt="rotation"></p><p>所以，在 view 中， frame 是由 bounds.size、center、transform 组成的。而在 layer 中，则由 bounds.size、position、affineTransform、transform(这是三维的变换)、anchorPoint 组成的。</p><p>bound 也是可以改变的，用来显示大区域视图的部分内容， bound 区域外面的内容是不会渲染的，用 clipsToBounds 属性控制。</p><p>绘制的内容可以来自于：</p><ul><li>view.layer.contents (这是 iOS 的底层绘制机制，很少几乎不会直接设置，所以 UIKit 有提供下面两种方法)</li><li>UIImageView (推荐用)</li><li>drawRect:</li></ul><p>UIImageView vs. drawRect: (主要指内存消耗)</p><ul><li>Stretch: UIImageView 0 内存消耗， UIImageView 放大的时候还可以动画， drawRect 也可以，但是看起来可能会很糟糕。</li><li>Tile: 尽管 UIImageView 让 GPU 去处理最终的 tile 从而填充整个屏幕，会有一点点消耗，但是相对于 drawRect: 来说，这一点开销还是可以忽略的。</li></ul><h2 id="CATransaction-and-when-views-get-rendered"><a href="#CATransaction-and-when-views-get-rendered" class="headerlink" title="CATransaction and when views get rendered"></a>CATransaction and when views get rendered</h2><p>有一种情况，你可能改变了 frame 和 transform ，但它们并没有同时显示，而是只显示了其中一个变化。想知道为什么，就得知道视图<strong>什么时候</strong>开始渲染。 设置属性的时候就会在 runloop 中创建<strong>隐式事务(implicit transaction)</strong>, 此时隐式事务是<strong>打开</strong>的，随后你设置的相关改变都会被<strong>放入</strong>这个隐式事务，然后一起提交，一旦 runloop 开启下个循环， Core animation 就会<strong>提交</strong>这个隐式事务，然后就能在屏幕上显示了。</p><p>有的时候，你可能设置了属性，但是没有显示，可能是<strong>阻塞</strong>了主线程， runloop 下个循环没法开启，所以 Core animation 没有提交事务，也就没渲染成功。</p><p>有隐式事务，那肯定就有显式(implicit)事务，我们尽量使用隐式事务，除非是做动画或者想控制时间。</p><p>我们 lldb 调试时候，经常会看到<br><img src="https://github.com/JoakimLiu/BlogPhoto/blob/master/wwdc/2012/238/callstack1.png?raw=true" alt="CA::Transaction::commint"></p><h2 id="Quality-and-Performance"><a href="#Quality-and-Performance" class="headerlink" title="Quality and Performance"></a>Quality and Performance</h2><p>发现渲染问题，让想要提高它的最普遍的方法是寻找 <code>offscreen rendering</code>, 然后避免它。</p><h3 id="Avoid-Offscreen-Rendering"><a href="#Avoid-Offscreen-Rendering" class="headerlink" title="Avoid Offscreen Rendering"></a>Avoid Offscreen Rendering</h3><p>不是离屏渲染(offscreen rendering)的情况下， core animation 会在屏幕上开始渲染最底层的视图，然后渲染相应的子视图<strong>（从下到上）</strong>。<br>如果一个视图的是离屏渲染的，那么它的子视图也是离屏渲染的。离屏渲染大概有两个问题吧</p><ul><li>额外的 memory, 创建 off-screen buffer</li><li>额外的时间，在 off-screen 和 on-screen 切换</li></ul><p>如果 core animation 每一帧都得做这样的事情，是很昂贵的。<br>ps: <a href="https://www.jianshu.com/p/ca51c9d3575b">离屏渲染优化详解：实例示范+性能测试</a> 有讲很多优化的例子。</p><h4 id="Layer-Rasterization"><a href="#Layer-Rasterization" class="headerlink" title="Layer Rasterization"></a>Layer Rasterization</h4><p>图层光栅化，可以减少离屏渲染的影响，它会<strong>缓存</strong>渲染的位图，减少了 <code>off-screen</code> 和 <code>on-screen</code> 切换的时间。当然它<strong>只适应于上下两帧内容一样</strong>的情况，如果不一样，还是跟之前一样，还是会有性能问题。<strong>但是</strong>，如果你没有离屏渲染，而去使用光栅化，会损耗性能，<strong>因为</strong>它不能重用缓存，每一帧还是在 <code>off-screen</code> 和 <code>on-screen</code> 切换。(切记，出现问题的时候，一定要记录当前的数据，然后再去做调试优化，再拿当前的数据和之前的作对比。)</p><h3 id="Clipping-and-masking"><a href="#Clipping-and-masking" class="headerlink" title="Clipping and masking"></a>Clipping and masking</h3><p><code>corner</code> 和 <code>gradient mask</code> 也会引发离屏渲染。可以用以下方法：</p><ul><li>[CALayer contentsRect], 使用大图片时可以考虑用一下，比 corner 性能要好。</li><li>[UIView drawRect:], 提前渲染好。</li><li>Transparent overlay, 遮罩来处理。</li></ul><h3 id="Group-opacity"><a href="#Group-opacity" class="headerlink" title="Group opacity"></a>Group opacity</h3><p>在父视图上设置，父视图和它的子视图都有同样的 alpha 效果，它也会产生离屏渲染。可以用以下方法：</p><ul><li>drawRect: 方法中提前渲染好。</li><li>光栅化， <code>shouldRasterize = YES</code></li></ul><h3 id="Shadows"><a href="#Shadows" class="headerlink" title="Shadows"></a>Shadows</h3><p>设置阴影方法不当也会引起离屏渲染。</p><p>不要用</p><ul><li>[CALayer shadowOffset]</li><li>[CALayer shadowColor]</li></ul><p>而用</p><ul><li>[CALayer shadowPath]</li><li>CoreGraphics shadows</li></ul><h3 id="Edge-anti-aliasing"><a href="#Edge-anti-aliasing" class="headerlink" title="Edge anti-aliasing"></a>Edge anti-aliasing</h3><p>当位图的分辨率<strong>明显低于</strong>设备的分辨率时，会出现锯齿状边缘。为了使得看起来更加平滑(smooth)。我们可以对围绕形状轮廓的像素使用不同的颜色。通过以这种方式混合颜色，形状看起来光滑。<br><img src="https://sat02pap001files.storage.live.com/y4mvL9zxZfXLveK3GYqwqGPIOwAFtAky2W0xYzzdgl2UHkBmOFA0PfbXTgJfYagDkssKFPKAvaq6mp8KDJRmxez3R1CtRavG2ryTtrVjgV5xVZW-VHB-umAjTS1o7HwbqAzMDnB9IW8gUgBmJd1ZaycHi1ijfYdtytwBdRicFEpCFLQU1Hb1w-bq6mC90hJIk-y?width=414&height=435&cropmode=none" alt="A comparison of aliased and anti-aliasing drawing"></p><h1 id="Apple-Document"><a href="#Apple-Document" class="headerlink" title="Apple Document"></a>Apple Document</h1><p><a href="https://developer.apple.com/library/archive/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009503-CH1-SW2">View Programming Guide for iOS</a></p><h2 id="About-Windows-and-Views"><a href="#About-Windows-and-Views" class="headerlink" title="About Windows and Views"></a>About Windows and Views</h2><p>在 iOS 下，我们用 View 和 Window 在屏幕上面呈现 App 的内容， Window 不会直接呈现可视化的内容，只是为程序的 View 提供一个 container <strong>载体</strong>。<br>(ps: 所以，用 Xcode Debug 展示最下面是黑色的，还有用 Xcode 创建新的工程，single view controller 也是黑色的)</p><h3 id="At-a-Glance"><a href="#At-a-Glance" class="headerlink" title="At a Glance"></a>At a Glance</h3><p>每一个 App 至少有一个 window 和一个用于显示其内容的 View, UIKit 为我们提供系统控件。当然，当系统控件满足不了我们需求的时候，我们可以<strong>自定义控件并管理绘图和事件处理</strong>。</p><h4 id="Views-Manage-Your-Application’s-Visual-Content"><a href="#Views-Manage-Your-Application’s-Visual-Content" class="headerlink" title="Views Manage Your Application’s Visual Content"></a>Views Manage Your Application’s Visual Content</h4><p>view 或者它的子类对象在 App 的 Window 上管理着 App 的<strong>矩形区域</strong>(<code>Views are responsible for drawing content, handling multitouch events, and managing the layout of any subviews.</code>)。 drawing 涉及到 Core Graphics, OpenGL ES, UIKit 等绘制技术在矩形区域里面绘制物体、图片、文本等。 视图通过手势识别器(gesture recognizers)或者直接处理触摸事(touch events)来响应其矩形区域中的触摸事件。 在 View 的层级里面，父视图有责任去定位和调整子视图的位置，并且能够动态的改变它们，使它们自适应旋转、动画等一些改变条件。 我们可以假想多个 View 堆积成我们的用户界面，每个 View 都呈现着不同的内容。</p><h4 id="Windows-Coordinate-the-Display-of-Your-Views"><a href="#Windows-Coordinate-the-Display-of-Your-Views" class="headerlink" title="Windows Coordinate the Display of Your Views"></a>Windows Coordinate the Display of Your Views</h4><p>Window 处理着 App <strong>整个的用户界面</strong>（它与 view 或者 vc 一起工作，去管理可视化 view 的交互和改变），大多数情况下，App 的 Window 不会改变。当 window 创建好后，它不会改变，只通过改变 View 现实。每一个应用至少有一个 Window 在主屏幕呈现 App 的用户界面。当外部显示器连接到设备时， App 会创建第二个 Window 去显示内容。 </p><h4 id="Animations-Provide-the-User-with-Visible-Feedback-for-Interface-Changes"><a href="#Animations-Provide-the-User-with-Visible-Feedback-for-Interface-Changes" class="headerlink" title="Animations Provide the User with Visible Feedback for Interface Changes"></a>Animations Provide the User with Visible Feedback for Interface Changes</h4><p>animation 在当前 View 的层级上为用户提供可视的变化。可以改变 View 的透明度<code>transparency</code>、位置、大小、背景颜色或者其他属性。 Core Animation layer object, 能够更好的做好动画。(ps: <code>Core Animation Programming Guide</code> 有讲。)</p><h4 id="The-Role-of-Interface-Builder"><a href="#The-Role-of-Interface-Builder" class="headerlink" title="The Role of Interface Builder"></a>The Role of Interface Builder</h4><p>用户界面就是一个 App 去形象化的组织和配置 Window 和 View 。(ps: 这里 Apple 又推荐用 xib 了)</p><h2 id="View-and-Window-Architecture"><a href="#View-and-Window-Architecture" class="headerlink" title="View and Window Architecture"></a>View and Window Architecture</h2><p>view 和 window 用来呈现内容和处理与界面的交互，自定义的视图也得继承自它们。理解它们这些基础控件是怎么操作的会很有好处。</p><h3 id="View-Architecture-Fundamentals"><a href="#View-Architecture-Fundamentals" class="headerlink" title="View Architecture Fundamentals"></a>View Architecture Fundamentals</h3><p><strong>视图对象</strong>在屏幕上定义矩形区域，并处理<strong>该区域中的绘图和触摸事件</strong>。 视图还可以充当其他视图的父级，并协调这些视图的位置和大小调整。 UIView 类完成了管理视图之间这些关系的大部分工作，但我们也可以根据需要自定义默认行为。</p><p>视图与核心动画层结合使用，以处理<strong>视图内容的渲染和动画</strong>。 UIKit 中的每个视图都有一个图层对象（通常是CALayer类的一个实例）支持，<strong>该图层对象管理视图的后备存储并处理与视图相关的动画</strong>。 我们执行的大多数操作都应该通过 UIView 接口。 但是，在需要更多控制视图的渲染或动画行为的情况下，可以通过其图层执行操作。</p><p>背后的 layer 对象是 Core Animation 的渲染对象，<strong>最终用于管理屏幕上实际位图的硬件缓冲区</strong>。</p><p>Core Animation layer objects 的使用对性能有重要的影响。 view 对象的实际绘图代码越少越好，当你绘制的时候， Core Animation <strong>将会缓存结果</strong>，以便后面能够尽量的重用。重用已经渲染后的内容能够消除昂贵的绘制周期去更新视图，重用在动画的时候也非常重要。(ps: Core Animation layer object 的相关东西，<code>Core Animation Programming Guide</code> 有讲。)</p><h4 id="View-Hierarchies-and-Subview-Management"><a href="#View-Hierarchies-and-Subview-Management" class="headerlink" title="View Hierarchies and Subview Management"></a>View Hierarchies and Subview Management</h4><p>View 除了提供自己的内容以外，还能作为其他 View 的容器，这就是 subView superView 的关系。 subView 的内容能够掩盖全部或部分它 superView 的内容，即有<strong>层级关系</strong>。</p><p>如果 subview 部分透明，那么 subview 、superview 它们两个的内容就会混合在一起显示在屏幕上面。</p><p>视图有一个有序的数组来存储它的子视图，后添加的在最顶层。改变父视图的大小会使子视图的大小和位置改变（这里 autoresize 等属性就能处理这些事情）。视图的层级结构也决定了 App 去响应事件，当 touch 触摸事件发生在某个特定的视图上，系统就会直接发送一个包含 touch information 的 event object 给该视图去处理。它是向上传递的，如果父视图处理不了，就丢给它的父视图，一直沿着响应链 responder chain 传递，一直会传递到 application object ，不过它一般会丢弃它（这里就涉及到了响应链的知识）。</p><h4 id="The-View-Drawing-Cycle"><a href="#The-View-Drawing-Cycle" class="headerlink" title="The View Drawing Cycle"></a>The View Drawing Cycle</h4><p>视图类采取按需绘图模型来展示内容（即<strong>按需处理绘制</strong>）。当视图<strong>首次</strong>出现在屏幕上时，系统会要求它绘制其内容，系统会捕获<strong>此内容的快照</strong>，然后用这个快照去展示视图的视觉效果。如果你不改变视图的内容，那么视图的绘制代码就不会再次执行。这个快照图片(snapshot image)对于所涉及的视图的大部分操作是<strong>可以重用</strong>的。如果确实更改了内容，<strong>则通知</strong>系统视图已更改。然后，视图重复绘制视图并捕获新结果的快照的过程。</p><p>当视图内容改变的时候，你不用直接去重新绘制这些改变。你只需调用 <code>setNeedsDisplay</code> 或者 <code>setNeedsDisplayInRect</code> 系统方法，这些方法会告诉系统在<strong>下一次循环会重新绘制。系统会等到这次循环结束才会开始任何绘制操作</strong>。 这个延时中，你有机会做各种事情，比如：使多个视图无效，在层次结构中添加或删除视图，隐藏视图，调整视图大小以及重新定位视图，这些所有的改变会在同时反应出来。(ps: 就是 implicit transaction)</p><p>注意：改变视图的<strong>几何构造</strong> geometry（在 view.h 文件里面，搜索 geometry 就会看到 geometry 的相关属性 frame、bounds、center 等等）<strong>不会自动使系统去重绘视图的内容</strong>。 contentMode 属性决定了 geometry 变化时，视图的内容怎么改变。大部分模式会在视图的边界里面拉伸或者重新放置已经存在的 snapshot, <strong>不会创建一个新的</strong>。</p><p>当渲染视图内容时，实际绘制过程会<strong>根据视图及其配置而有所不同</strong>。系统视图通常实现私有绘图方法来呈现其内容。 这些相同的系统视图通常会公开可用于配置视图实际外观的接口。 对于自定义视图子类，通常会覆盖视图的 <code>drawRect:</code> 方法，并使用该方法绘制视图的内容。还有其他方法可以提供视图的内容，例如直接设置底层的内容(layer.contents)，但是覆盖 <code>drawRect:</code> 方法是最常用的技术。(ps: <code>Core Animation Programming Guide</code> 中的 “Providing a Layer’s Contents” 有提到三种方法设置内容。)</p><p>有关如何为自定义视图绘制内容的详细信息，请参阅”#Implementing Your Drawing Code#”。</p><h3 id="Content-Modes"><a href="#Content-Modes" class="headerlink" title="Content Modes"></a>Content Modes</h3><p>每个视图都有一个内容模式，用于控制视图如何<strong>重新利用</strong>其内容以响应视图几何中的更改，以及是否重新利用其内容。 首次显示视图时，它会像往常一样呈现其内容，并在底层位图(bitmap)中捕获结果。 之后，<strong>对视图几何体的更改并不总是会导致重新创建位图</strong>。 相反， contentMode 属性中的值确定是否缩放位图以适应新边界，还是仅固定到视图的一个角或边缘。(ps: 最终都是位图去展示的)</p><p>content mode 作用于改变视图的 frame bounds transform 属性。见下图</p><p><img src="https://sat02pap001files.storage.live.com/y4m4H0CSxMBwS0AuvFfuSSN9jtGvtKOfqXaTB0ek6qapzf40uB8joOLQsEjHfueZem-WBpMO_D6rkqnQY_d5_G_icZVLokQMWEDWd9k0OlYYe4O8jDPutz5lnQFQr0Wuv8nvRN7q4DvSoBfvQ3BHM-UT0jrxhODa5Zk_gjUSeyOUFMjgOyMQbc7MW2XcjxdhuVm?width=441&height=709&cropmode=none" alt="Content mode comparisons"></p><p>内容模式适用于重新利用视图内容，但是特别希望自定义视图在缩放和调整大小操作期间重绘时，还可以将内容模式设置为 <code>UIViewContentModeRedraw</code> 。将视图的内容模式设置为此值，会强制系统调用视图的 <code>drawRect:</code> 方法以响应几何体更改。通常，应尽可能<strong>避免使用此值</strong>，并且当然<strong>不应将其与标准系统视图一起使用</strong>。</p><h3 id="Stretchable-Views"><a href="#Stretchable-Views" class="headerlink" title="Stretchable Views"></a>Stretchable Views</h3><p>可以将视图的一部分指定为可伸缩的，以便在视图大小发生变化时，只会影响可伸展部分中的内容。 <strong>通常将可伸展区域用于按钮或其他视图</strong>，其中视图的一部分定义了可重复(repeatable pattern)的模式。 指定的可伸展区域可以允许沿视图的一个或两个轴拉伸。 当然，沿两个轴拉伸视图时，视图的边缘也必须定义可重复的图案以避免变形(distortion)。 下图显示了这种失真如何在视图中显现出来。 原理就是，复制每个视图的原始像素的颜色以填充较大视图中的相应区域(ps: 跟抗锯齿差不多哈)。</p><p><img src="https://sat02pap001files.storage.live.com/y4mjoc7cVu7qdkWvsokJldvtRib0qslwzxvflIS5FCdsSInXjIS9MWDDIZk2IiUG9uCaxCZvglqMc9_SAwIohRtsIHvisSE-RzQt-Lg7AWcchmcR0FPcpNYc8jRer-tM-kQ4WKBSXBzuOZJUqFANQ54955WzHrA14zf0OeAkDTR37yy7rWfJF6gY8kvEcsJGTL9?width=395&height=442&cropmode=none" alt="Stretching the background of a button"></p><p>可以使用 contentStretch 属性指定视图的可伸展区域。 此属性接受一个矩形，它是标准值，其值的范围为 0.0-1.0 。 在拉伸视图时，系统会将这些标准化值<strong>乘以</strong>视图的当前边界和比例因子，以确定需要拉伸哪个或哪些像素。 使用标准化值可以<strong>减少每次视图边界更改时更新 contentStretch 属性的需要</strong>。</p><p>视图的内容模式(content mode)也在确定视图的可伸展区域(stretchable area)的使用方式方面发挥作用。 <strong>可伸缩区域仅在内容模式导致视图的内容缩放时使用</strong>。 这意味着仅使用 UIViewContentModeScaleToFill UIViewContentModeScaleAspectFit 和 UIViewContentModeScaleAspectFill 内容模式支持可伸展视图。 如果指定将内容固定到边缘或角落的内容模式则视图将忽略可伸展区域（因此实际上不会缩放内容，ps: 其实就是上面三种模式以外的内容模式，即内容模式大致分为两种，一种是缩放去适应视图，另外一种只是将内容移动到视图的一个边角。）。</p><p>注意：当指定为视图背景时，创建伸缩的 UIImage 对象时<strong>推荐用</strong> contentStretch 属性。 stretchable view 整个被用在 Core Animation layer, 能够提供更好的性能。</p><p>(ps: contentStretch 能够指定拉伸的区域，但是只适用于 ScaleToFill、ScaleAspectFit、ScaleAspectFill 这三种内容模式。)</p><h3 id="Built-In-Animation-Support"><a href="#Built-In-Animation-Support" class="headerlink" title="Built-In Animation Support"></a>Built-In Animation Support</h3><p><code>One of the benefits of having a layer object behind every view is that you can animate many view-related changes easily.</code> (在每个视图后面都有一个图层对象的好处之一是，可以<strong>轻松地为许多与视图相关的更改设置动画</strong>。)</p><p>用内置的动画支持，你只需做两件事，告诉 UIKit 你想要执行一个动画，然后改变相关属性的值</p><ul><li>Tell UIKit that you want to perform an animation.</li><li>Change the value of the property.</li></ul><p>视图的以下属性可以用于动画</p><ul><li>frame—Use this to animate position and size changes for the view.</li><li>bounds—Use this to animate changes to the size of the view.</li><li>center—Use this to animate the position of the view.</li><li>transform—Use this to rotate or scale the view.</li><li>alpha—Use this to change the transparency of the view.</li><li>backgroundColor—Use this to change the background color of the view.</li><li>contentStretch—Use this to change how the view’s contents stretch.</li></ul><p>下降到 layer 层，可以更多的控制时间以及动画属性。可以参考</p><ul><li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004514">Core Animation Programming Guide</a></li><li><a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/CoreAnimation_Cookbook/Introduction/Introduction.html#//apple_ref/doc/uid/TP40005406">Core Animation Cookbook</a></li></ul><h2 id="View-Geometry-and-Coordinate-Systems"><a href="#View-Geometry-and-Coordinate-Systems" class="headerlink" title="View Geometry and Coordinate Systems"></a>View Geometry and Coordinate Systems</h2><p>UIKit 默认的坐标系统是从左上角开始并且轴向右、向下延伸。坐标值用的是浮点类型的，它能使你更加<strong>精确的</strong>计算出位置和内容而不用管底层屏幕分辨率。当然每个view、window 都有属于自己的 local coordinate system ，即有的时候我们需要将在 view 上的坐标转换(convert)到 controller.view 上面显示(视图和窗口有提供相关的方法去转换，这点得注意)。</p><p>要点：一些 iOS 技术定义的坐标系统跟 UIKit 不同， Core Graphics 和 OpenGL ES 使用左下角为起始点， y 轴是向上的。</p><h3 id="The-Relationship-of-the-Frame-Bounds-and-Center-Properties"><a href="#The-Relationship-of-the-Frame-Bounds-and-Center-Properties" class="headerlink" title="The Relationship of the Frame, Bounds, and Center Properties"></a>The Relationship of the Frame, Bounds, and Center Properties</h3><p>frame 在其 superview 中指定位置大小， bounds 在自己的坐标系统中指定大小， center 在 superview 中的中心点。(ps: frame 是包裹视图内容的最小矩形区域。 session 2011.121 P23)</p><p>frame 和 center 主要是操作当前 view 的几何结构，主要是操作视图的大小和位置。如果你只改变视图的位置，推荐用 center ，尤其是在缩放或旋转的时候，即使已将缩放或旋转因子添加到视图的变换中，center 属性中的值也<strong>始终有效</strong>。 对于 frame 属性中的值也是如此，如果视图的变换<strong>不等于 identity 变换</strong>，则该属性<strong>被视为无效</strong>。<br>bounds 一般用于绘制的时候。</p><p>当 frame 改变时，center、bounds 会改变；center 改变时，frame 会改变；bounds 改变时，frame 会改变。 clipsToBounds 属性设置当 subview 超出 superview 时是否被裁剪，如果不被裁剪，那么超出部分不会响应事件。</p><p><img src="https://sat02pap001files.storage.live.com/y4miuulU-u2af7Gz0Vy2yJTqLJheX_AWMSSlzsFR9WZsCx7N08CQXmYPgE6jfvcJaU00Q7ZqYc9ycvBpvo57tGWtNVqXSmTg8uT2BQ3W2EAdlbPajvy5LdWdR_gCkS29k_ykPP7PRg3NxP1XFuXA8IBkfGWVXfxgIXmV3fGZBfPga74M-E5_wKZ8bfWz6C19I2-?width=540&height=309&cropmode=none" alt="Relationship between a view&#39;s frame and bounds"></p><p>ps: 还可以参考 <a href="http://stackoverflow.com/questions/1210047/cocoa-whats-the-difference-between-the-frame-and-the-bounds">http://stackoverflow.com/questions/1210047/cocoa-whats-the-difference-between-the-frame-and-the-bounds</a></p><h3 id="Coordinate-System-Transformations"><a href="#Coordinate-System-Transformations" class="headerlink" title="Coordinate System Transformations"></a>Coordinate System Transformations</h3><p>坐标系转换提供了一种快速轻松地更改视图（或其内容）的方法。 仿射变换(affine transform)是一种数学矩阵，它指定<strong>一个坐标系中的点如何映射到不同坐标系中的点</strong>。 我们可以将仿射变换应用于整个视图，以更改视图相对于其父视图的大小，位置或方向。 还可以在绘图代码中使用仿射变换对各个渲染内容执行相同类型的操作。 因此，<strong>如何应用仿射变换取决于上下文</strong>：</p><ul><li>要修改整个视图，请在视图的 transform 属性中修改仿射变换。</li><li>在 <code>drawRect:</code> 方法中修改视图的特定内容，修改活动图形上下文(active graphics context)关联的仿射变换。</li></ul><p>当然<strong>不要使用此属性对视图进行永久性更改</strong>，例如在其 superview 的坐标空间中修改其位置或调整视图大小。 对于这种类型的更改，应该修改视图的框架矩形。</p><p><strong>注意</strong>：当改变视图的 transform 属性时，所有的变化只是相对于视图的中心点(center)进行的。</p><p>当前变换矩阵(current transformation matrix, CTM)是在任何给定时间使用的仿射变换。 在操作整个视图的几何体时，CTM 是存储在视图的 transform 属性中的仿射变换。 在 <code>drawRect:</code> 方法中，CTM 是与活动图形上下文关联的仿射变换。</p><p>每个子视图的坐标系建立在其祖先的坐标系上。 因此，当修改视图的 transform 属性时，该更改会影响视图及其所有子视图。但是，这些更改仅影响屏幕上视图的最终呈现。因为每个视图都绘制其内容并相对于其自己的边界布置其子视图，所以它可以在绘制和布局期间忽略其父视图的变换。可以参考下图</p><p><img src="https://sat02pap001files.storage.live.com/y4mOeo_tCulrIyVWqIceEgQwQhnpMMLjudYX9aug_HTRR5vuKHtoKjNiNI-MQoq6xdwW6OjitGzficLl-NHDR05dBfjQEFrxO4oEOgMDjj75CxvkjaJHuW0byQ0kFOQct7oMtXsMVIJcbqtoZNjnnV9pDzUPhBuTD9x8Z5Jfxb0S3sovfmWgxEvT-l3s5s9eBB1?width=648&height=384&cropmode=none" alt="Rotating a view and its content"></p><p><strong>要点</strong>：如果视图的 transform 属性不是 identity 变换时，则该视图的 frame 属性的值是<strong>未定义的</strong>，必须忽略。 将变换应用于视图时，必须使用视图的 bounds 和 center 属性来获取视图的大小和位置。 任何子视图的 frame 仍然有效，因为它们相对于视图的 bounds 。</p><p>有关如何在绘图期间使用变换来定位内容的信息，请看 <a href="https://developer.apple.com/library/archive/documentation/2DDrawing/Conceptual/DrawingPrintingiOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40010156">Drawing and Printing Guide for iOS</a></p><h3 id="Points-Versus-Pixels"><a href="#Points-Versus-Pixels" class="headerlink" title="Points Versus Pixels"></a>Points Versus Pixels</h3><p>在 iOS 中，使用称为点(point)的单位的浮点值指定所有坐标值和距离。 一个点的可测量大小因设备而异，并且在很大程度上是无关紧要的。 关于点的主要理解是它们为绘图提供了固定的参考框架。</p><p>虽然用户坐标空间中的坐标有时会直接映射到设备屏幕上的像素，但绝不能认为是这种情况。相反，应该始终记住以下内容：</p><p><code>One point does not necessarily correspond to one pixel on the screen.</code> 跟分辨率来的。</p><p>在设备级别，在视图中指定的所有坐标(points)必须在某个时刻转换为像素(pixels)。 然而，<strong>用户坐标空间</strong>中的点到<strong>设备坐标空间</strong> 中的像素的映射通常由 <strong>系统</strong> 处理。 UIKit 和 Core Graphics 都使用主要基于矢量(vector-based)的绘图模型，其中所有坐标值都使用点指定。 因此，如果使用 Core Graphics 绘制曲线，则无论底层屏幕的分辨率如何，都使用相同的值指定曲线。</p><p>当需要使用图像或其他基于像素的技术(如OpenGL ES)时，iOS 可以帮助管理这些像素。 对于作为应用程序包中的资源存储的静态图像文件，iOS 定义了以不同像素密度(pixel densities)指定图像以及加载与当前屏幕分辨率最匹配的图像的转换约定。 视图还提供有关当前比例因子(scale factor)的信息，以便可以手动调整任何基于像素的绘图代码以适应更高分辨率的屏幕。 有关处理不同屏幕分辨率的基于像素的内容的技术，请参阅<br><a href="https://developer.apple.com/library/archive/documentation/2DDrawing/Conceptual/DrawingPrintingiOS/SupportingHiResScreensInViews/SupportingHiResScreensInViews.html#//apple_ref/doc/uid/TP40010156-CH15">Supporting High-Resolution Screens In Views</a>。</p><h3 id="The-Runtime-Interaction-Model-for-Views"><a href="#The-Runtime-Interaction-Model-for-Views" class="headerlink" title="The Runtime Interaction Model for Views"></a>The Runtime Interaction Model for Views</h3><p>每当用户与用户界面交互时，或者自己的代码以编程方式更改某些内容时， UIKit 内部都会发生复杂的事件序列来处理该交互。在该序列中的特定点，UIKit 会调用视图类，并让他们有机会代表应用程序做出响应。 了解这些标注点对于了解视图系统非常重要。 下图显示了以用户触摸屏幕开始并以图形系统更新屏幕内容作为响应而结束的事件的基本顺序。 对于任何以编程方式启动的操作，也会发生相同的事件序列。</p><p><img src="https://sat02pap001files.storage.live.com/y4mS_HQXyHyANPa_UGwQiRusJ31aAuVyK-j8gHJxOOvH60EOfa6viO0X1xZVZQ_rHvbiRseILkRF0EBwjbiVr5vSHXUU93Gy3N3AyBwZ07X_kK4K0D1zJYneEc51IVK1xTgeSBqxsSG4Yfkb3hzqChhqUB2kX2Oj1Aq-WhTq7XDRmt8rQUJdP_IrNjNyCugKgm-?width=574&height=298&cropmode=none" alt="Figure 1-7 UIKit interactions with your view objects"></p><ol><li>用户触摸屏幕；</li><li>硬件将触摸事件报告给 UIKit framework；</li><li>UIKit 包装 touch 成 UIEvent 对象，然后将它分发给相应的视图；（这就响应链了，更多细节，可以查看<a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009541">Event Handing Guide for iOS</a>）</li><li>视图的事件处理代码会响应事件(当然，这些操作取决于我们自己)。 例如：<ol><li>改变视图或者它子视图的属性：frame、bounds、alpha 等等；</li><li>调用 setNeedsLayout 方法将视图（或其子视图）标记为需要布局更新；</li><li>调用 setNeedsDisplay 或 setNeedsDisplayInRect: 方法将视图（或其子视图）标记为需要重绘；</li><li>通知控制器改变一些数据；</li></ol></li><li>如果视图的 geometry 因任何原因而发生了更改， UIKit 将根据以下规则更新其子视图：<ol><li>如果它的子视图配置了autoresizing，那么 UIKit 会处理，详情请看 <a href="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/CreatingViews/CreatingViews.html#//apple_ref/doc/uid/TP40009503-CH5-SW5">Handling Layout Changes Automatically Using Autoresizing Rules</a>； </li><li>如果视图实现了 layoutSubviews 方法，UIKit 会调用它；可以在自定义视图中覆盖此方法，并使用它来调整任何子视图的位置和大小。(ps: 这里列举了滚动显示大图各个细小部分的例子)。</li></ol></li><li>如果任何视图的任何部分被标记为需要重绘，UIKit 会要求视图重绘。 对于显式定义 <code>drawRect:</code> 方法的自定义视图， UIKit 会调用该方法。 对此方法的实现<strong>应该尽快重绘视图的指定区域</strong>，而不是其他任何内容。 此时不要进行其他布局更改，也不要对应用程序的数据模型进行其他更改。 此方法的目的是更新视图的可视内容。 标准系统视图<strong>通常不实现 drawRect: 方法，而是在此时管理其绘图</strong>。</li><li>任何更新的视图都与应用程序的其他可见内容合成，并发送到图形硬件。</li><li>图形硬件将渲染的内容传输到屏幕。</li></ol><p>(ps: 这里可以对照 session 2014.419 P5 来仔细看看)</p><p>注意：前面的更新模型主要适用于使用标准系统视图和绘图技术的应用程序。 使用 OpenGL ES 进行绘图的应用程序通常配置单个全屏视图并直接绘制到关联的 OpenGL ES 图形上下文。 在这种情况下，视图仍然可以处理触摸事件，但由于它是全屏的，因此不需要布置子视图。 有关使用OpenGL ES的更多信息，请参阅<a href="https://developer.apple.com/library/archive/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008793">OpenGL ES Programming Guide</a></p><p>在上面的一组步骤中，<strong>自定义视图的主要集成点是</strong>：</p><ol><li>事件处理方法：<ol><li>touchesBegan:withEvent:</li><li>touchesMoved:withEvent:</li><li>touchesEnded:withEvent:</li><li>touchesCancelled:withEvent:</li></ol></li><li>layoutSubviews方法</li><li>drawRect: 方法</li></ol><p>这些是最常被覆盖的视图方法，但可能不需要覆盖所有这些方法。 如果使用手势识别器来处理事件，则无需覆盖任何事件处理方法。 同样，如果视图不包含子视图或其大小未更改，则没有理由覆盖 layoutSubviews 方法。 最后，只有当视图的内容可以在运行时更改并且使用 native 技术(如 UIKit 或 Core Graphics)进行绘制时，才需要 <code>drawRect:</code> 方法。</p><p><strong>同样重要的是要记住，这些是主要的集成点，但不是唯一的集成点</strong>。 UIView类的几个方法被设计为子类的覆盖点。 我们应该查看<a href="https://developer.apple.com/documentation/uikit/uiview">UIView类</a>参考中的方法描述，以了解哪些方法可能适合在自定义实现中覆盖。</p><h2 id="Tips-for-Using-Views-Effectively"><a href="#Tips-for-Using-Views-Effectively" class="headerlink" title="Tips for Using Views Effectively"></a>Tips for Using Views Effectively</h2><p><code>Important: Before optimizing your drawing code, you should always gather data about your view’s current performance. Measuring the current performance lets you confirm whether there actually is a problem and, if there is, gives you a baseline measurement against which you can compare future optimizations.</code><br><strong>要点</strong>：优化绘图代码之前，你应该始终收集关于视图当前性能的数据。衡量当前的性能，以便知道问题在哪，并且给一个基准用于未来优化的对比。类似于 60fps 吧</p><h3 id="Views-Do-Not-Always-Have-a-Corresponding-View-Controller"><a href="#Views-Do-Not-Always-Have-a-Corresponding-View-Controller" class="headerlink" title="Views Do Not Always Have a Corresponding View Controller"></a>Views Do Not Always Have a Corresponding View Controller</h3><p>在 App 中， view 和 viewcontroller 一对一的关系是很少见的。所以这里得 <strong>明确 viewcontroller 的职责</strong>：改变 view 在屏幕上的位置、将 view 从屏幕上面移除、释放内存、旋转 view 等。如果避开这些行为会引起你的App行为错误或者在出乎意料的情况。</p><h3 id="Minimize-Custom-Drawing"><a href="#Minimize-Custom-Drawing" class="headerlink" title="Minimize Custom Drawing"></a>Minimize Custom Drawing</h3><p>减少自定义的绘图。只有当前系统不能提供你所需要的外表和能力时才自定义绘图。（如果当前视图组合能够完成你的效果时，你完全可以组合）</p><h3 id="Take-Advantage-of-Content-Modes"><a href="#Take-Advantage-of-Content-Modes" class="headerlink" title="Take Advantage of Content Modes"></a>Take Advantage of Content Modes</h3><p>内容模式可最大限度地 <strong>缩短重绘视图所花费的时间</strong> 。 默认情况下，视图使用 UIViewContentModeScaleToFill 内容模式，该模式缩放视图的现有内容以适合视图的框架矩形。 你可以根据需要更改此模式的不同方式去调整内容，但如果可以，则应避免使用 <code>UIViewContentModeRedraw</code> 内容模式。 <strong>无论哪种内容模式生效，都可以通过调用 setNeedsDisplay 或 setNeedsDisplayInRect: 来强制视图重绘其内容</strong>。</p><h3 id="Declare-Views-as-Opaque-Whenever-Possible"><a href="#Declare-Views-as-Opaque-Whenever-Possible" class="headerlink" title="Declare Views as Opaque Whenever Possible"></a>Declare Views as Opaque Whenever Possible</h3><p>UIKit 使用每个视图的 opaque 属性来确定视图是否可以优化合成操作。 对于自定义视图，将此属性的值设置为 YES 会告诉 UIKit 它不需要在视图后面呈现任何内容。<strong>较少的渲染可以提高绘图代码的性能</strong>，并且通常会受到鼓励。 当然，如果将 opaque 属性设置为 YES ，则视图<strong>必须使用完全不透明的内容完全填充其边界矩形</strong>。</p><h3 id="Adjust-Your-View’s-Drawing-Behavior-When-Scrolling"><a href="#Adjust-Your-View’s-Drawing-Behavior-When-Scrolling" class="headerlink" title="Adjust Your View’s Drawing Behavior When Scrolling"></a>Adjust Your View’s Drawing Behavior When Scrolling</h3><p>滚动可以在很短的时间内产生大量的视图更新。 如果视图的绘图代码未正确调整，则视图的滚动性能可能会很低(sluggish:迟钝)。 不要试图确保视图的内容始终保持原始状态，而是考虑在滚动操作开始时更改视图的行为。 例如，可以<strong>临时降低</strong>渲染内容的质量，或在滚动过程中<strong>更改</strong>内容模式。 滚动停止后，可以将视图返回到先前的状态，并根据需要更新内容。 (ps: 尽量减少滚动时的完全渲染)。 (ps: <a href="https://github.com/johnil/VVeboTableViewDemo">VVeboTableViewDemo</a> 有讲到)</p><p>ps: 滚动的时候减少绘图等相关耗时、耗资源的操作，滚动结束后再恢复先前状态。</p><h3 id="Do-Not-Customize-Controls-by-Embedding-Subviews"><a href="#Do-Not-Customize-Controls-by-Embedding-Subviews" class="headerlink" title="Do Not Customize Controls by Embedding Subviews"></a>Do Not Customize Controls by Embedding Subviews</h3><p>虽然从技术上讲可以将子视图添加到标准系统控件 - 从 UIControl 继承的对象 - 但是永远不应该以这种方式自定义它们。 <strong>支持自定义的控件，它本身中明确且文档说明的接口来实现</strong>。 例如，UIButton 类包含用于设置按钮的标题和背景图像的方法。通过在按钮内部嵌入自定义图像视图或标签来绕过这些方法，可能会导致应用程序现在或在将来某个时候因为按钮的实现发生更改而表现不正确(ps: 别到 UIButton 上添加 image 和 label 来完成你的需求，因为 UIButton 已经有内置的支持了；要多看系统控件接口说明)。</p><h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><p>每个至少需要一个 window（UIWindow类的实例对象）。有的甚至需要多个 window。一个 window 有几个责任</p><ul><li>It contains your application’s visible content.（包含App的可视内容）</li><li>It plays a key role in the delivery of touch events to your views and other application objects.（在touch event分发中起到非常重要的角色）</li><li>It works with your application’s view controllers to facilitate orientation changes.（与App的控制器合作，方便方向变化）</li></ul><p>在 iOS 中，window 没有 title bars, close box 或者其他可见的装饰。window 一直都是一个或者多个 view 的<strong>黑色容器</strong>（所以在Xcode的View debug中，最下层是黑色的）。同样的，App不会用新的window去展示新的内容，只需改变 window frontmost 最前面的 view 即可。大多数 App 在它的生命周期只会创建使用一个 window, 该 window 横跨设备的整个屏幕，在 App 生命周期用 nib 或者代码创建的。当然 App 也可以创建一个附加的window(external display)去显示其他的内容，比如来电话了，当然了其他所有的 window 一般都是系统创建的。</p><h2 id="Tasks-That-Involve-Windows"><a href="#Tasks-That-Involve-Windows" class="headerlink" title="Tasks That Involve Windows"></a>Tasks That Involve Windows</h2><p>对于许多应用程序，应用程序与其窗口交互的<strong>唯一时间是它在启动时创建窗口</strong>。 但是，可以使用应用程序的窗口对象执行一些与应用程序相关的任务：</p><ul><li>Use the window object to convert points and rectangles to or from the window’s local coordinate system. （坐标转换，特定view本地坐标系统于window对应坐标系统的转换，详情请参阅”#Converting Coordinates in the View Hierarchy#”）</li><li>Use window notifications to track window-related changes. （用window通知跟踪window相关的变化，详情请参阅”#Monitoring Window Changes#”）</li></ul><h2 id="Creating-and-Configuring-a-Window"><a href="#Creating-and-Configuring-a-Window" class="headerlink" title="Creating and Configuring a Window"></a>Creating and Configuring a Window</h2><p>当需要其他 window 时，应该<strong>按需创建</strong>。只要程序一启动就创建window，创建配置 window 不是一件耗资源的事情。当然，如果你的App一启动就直接进入后台，你应该让它到前台时才显示(visible)。</p><h3 id="Creating-Windows-in-Interface-Builder"><a href="#Creating-Windows-in-Interface-Builder" class="headerlink" title="Creating Windows in Interface Builder"></a>Creating Windows in Interface Builder</h3><p>要点：在 Interface Builder 中创建窗口时，建议在属性检查器中启用“启动时全屏”选项。 如果未启用此选项且窗口小于目标设备的屏幕，则某些视图将不会接收到触摸事件。 这是因为窗口（像所有视图一样）不会在其边界矩形之外接收触摸事件。 由于默认情况下视图不会剪切到窗口的边界，因此视图仍然显示为可见但它们不能接收到事件。 在启动时启用全屏选项可确保窗口的大小适合当前屏幕。 ps: bounds clip touch</p><h3 id="Creating-a-Window-Programmatically"><a href="#Creating-a-Window-Programmatically" class="headerlink" title="Creating a Window Programmatically"></a>Creating a Window Programmatically</h3><p><strong>创建的 window 大小应该和屏幕大小一样</strong>。你不应该为了适应状态栏或者其他的元素而改变window的大小。<strong>状态栏一直浮在 window 的上面，所有你要做的是使 window 上面的 view 的大小去适应状态栏</strong>，如果你 viewcontroller 的话，viewcontroller 会根据状态栏自动改变它 view 的大小。</p><h3 id="Adding-Content-to-Your-Window"><a href="#Adding-Content-to-Your-Window" class="headerlink" title="Adding Content to Your Window"></a>Adding Content to Your Window</h3><p>一般是 viewcontroller 的 view 去承载所有需要展示的内容。使用 root view object 简化改变界面的过程，<strong>如果要展示新内容，你只需替换它的root view object</strong> 。</p><p>用view、普通viewcontroller的view作为window的root view，<strong>需要减去状态栏的高度</strong>，而用tabbar or navigation or split-view controller的view提供的<strong>则不需要</strong>，因为这些viewcontroller会自动去改变。(ps: 主要讲了状态栏高度的相关问题)</p><h3 id="Changing-the-Window-Level"><a href="#Changing-the-Window-Level" class="headerlink" title="Changing the Window Level"></a>Changing the Window Level</h3><p>每一个window都会有一个windowLevel属性去决定与其他相关window的位置。 normal window level指示window呈现App相关的内容。高一点的window level是显示在App内容上面的，如系统system status或者alert messages。尽管你自己可以改变window level，但是系统会帮你做。比如，当你想要显示或隐藏状态栏，或者显示alert view时，系统会创建需要的window去显示这些内容。(ps: alert view的window层级比normal要高，写弹出popup view的时候可以注意一下)。</p><h2 id="Monitoring-Window-Changes"><a href="#Monitoring-Window-Changes" class="headerlink" title="Monitoring Window Changes"></a>Monitoring Window Changes</h2><p>UIWindowDidBecomeVisibleNotification、UIWindowDidBecomeHiddenNotification window 显示、隐藏。这个跟App在前台、后台<strong>没有关系</strong>，只跟App的内容是否显示有关系。</p><p>UIWindowDidBecomeKeyNotification、UIWindowDidResignKeyNotification 表面哪个是主 window。<br>可帮助应用程序跟踪哪个窗口<strong>是关键窗口 - 即哪个窗口当前正在接收键盘事件和其他非触摸相关事件</strong>。 触摸事件被传递到发生触摸的窗口，而没有相关坐标值的事件将被传递到应用程序的关键窗口。 一次只有一个窗口是关键窗口。(Q: 发生到主window上面的事件会丢弃掉？还有 没有相关坐标的事件？ A: 这里应该是指异常事件，如果触摸事件没被响应，不也会被丢弃)</p><h2 id="Displaying-Content-on-an-External-Display"><a href="#Displaying-Content-on-an-External-Display" class="headerlink" title="Displaying Content on an External Display"></a>Displaying Content on an External Display</h2><p>外部显示器显示内容，应该说的是视屏输出吧，即将手机的视屏投影到其他大屏幕上面观看(爱奇艺 mac app 有这个功能)。</p><h3 id="Handling-Screen-Connection-and-Disconnection-Notifications"><a href="#Handling-Screen-Connection-and-Disconnection-Notifications" class="headerlink" title="Handling Screen Connection and Disconnection Notifications"></a>Handling Screen Connection and Disconnection Notifications</h3><h3 id="Configuring-a-Window-for-an-External-Display"><a href="#Configuring-a-Window-for-an-External-Display" class="headerlink" title="Configuring a Window for an External Display"></a>Configuring a Window for an External Display</h3><h3 id="Configuring-the-Screen-Mode-of-an-External-Display"><a href="#Configuring-the-Screen-Mode-of-an-External-Display" class="headerlink" title="Configuring the Screen Mode of an External Display"></a>Configuring the Screen Mode of an External Display</h3><h1 id="Views"><a href="#Views" class="headerlink" title="Views"></a>Views</h1><p>view object是 App 与用户交互的主要途径，它有许多的责任。这里列举一些：</p><ul><li>布局和管理子视图：根据父视图定义自己的默认大小行为；管理它的子视图；在需要的时候布局子视图的大小位置；够将自己的坐标系统转换成其他view或者window的坐标系统。</li><li>绘图和动画：在它的矩形区域绘图；一些属性能够动画过渡到新的值。</li><li>事件处理：能够接收 touch events; 参与响应链。</li></ul><h2 id="Creating-and-Configuring-View-Objects"><a href="#Creating-and-Configuring-View-Objects" class="headerlink" title="Creating and Configuring View Objects"></a>Creating and Configuring View Objects</h2><h3 id="Creating-View-Objects-Using-Interface-Builde"><a href="#Creating-View-Objects-Using-Interface-Builde" class="headerlink" title="Creating View Objects Using Interface Builde"></a>Creating View Objects Using Interface Builde</h3><h3 id="Creating-View-Objects-Programmatically"><a href="#Creating-View-Objects-Programmatically" class="headerlink" title="Creating View Objects Programmatically"></a>Creating View Objects Programmatically</h3><h3 id="Setting-the-Properties-of-a-View"><a href="#Setting-the-Properties-of-a-View" class="headerlink" title="Setting the Properties of a View"></a>Setting the Properties of a View</h3><ul><li>alpha，hidden，opaque (这些属性改变view的的不透明度。alpha、hidden是直接影响view的不透明度。opaque属性告诉系统是否复合view，设为YES能够消除不必要的复合操作从而提升性能)</li><li>bounds，frame，center，transform (这些影响view的大小位置。如果当前的变换不是恒等的变换，那么frame属性是不确定的，并且会被忽略。(ps: 这应该就是有的动画里面需要定义一个唯一的字符串的意思吧，YYKit的CALayer+YYAdd文件里面有，类似于[self setValue:@(v) forKeyPath:@”transform.rotation.y”])</li><li>autoresizingMask, autoresizesSubviews (这些属性影响view以及其subviews自定改变大小的行为。autoresizingMask控制view响应父视图bounds的改变。autoresizesSubviews控制它的subviews是否resized。)</li><li>contentMode, contentStretch, contentScaleFactor (这些属性影响 view 内容的渲染，contentMode，contentStretch 属性决定当视图的宽高变化时它的内容怎样变化。 contentScaleFactor 只用于在高分辨率下你需要自定义重绘视图的情况)</li><li>gestureRecognizers, userInteractionEnabled, multipleTouchEnabled, exclusiveTouch (这些影响view的触摸事件处理)</li><li>backgroundColor, subviews, drawRect: method, layer, (layerClass method) (这些属性帮助你管理view的实际内容，为了更多先进的内容，你可以直接操作 view Core Animation layer 。如果想指定 view 整个不同类型的 layer，必须重载 layerClass 方法。)</li></ul><h3 id="Tagging-Views-for-Future-Identification"><a href="#Tagging-Views-for-Future-Identification" class="headerlink" title="Tagging Views for Future Identification"></a>Tagging Views for Future Identification</h3><p>tag值执行搜索是在运行时，<strong>它比遍历view的层级查找速度要快</strong>。 要搜索标记视图，请使用UIView的 <code>viewWithTag:</code> 方法。 此方法执行接收器及其子视图的深度优先搜索。 它不搜索视图层次结构的父视图或其他部分。 因此，从层次结构的根视图调用此方法将搜索层次结构中的所有视图，但是从特定子视图调用它仅搜索视图的子集。</p><h2 id="Creating-and-Managing-a-View-Hierarchy"><a href="#Creating-and-Managing-a-View-Hierarchy" class="headerlink" title="Creating and Managing a View Hierarchy"></a>Creating and Managing a View Hierarchy</h2><p>管理 View 的层级也非常重要，view的组织影响App的展示以及App怎么响应事件。</p><h3 id="Adding-and-Removing-Subviews"><a href="#Adding-and-Removing-Subviews" class="headerlink" title="Adding and Removing Subviews"></a>Adding and Removing Subviews</h3><p>用 <code>bringSubviewToFront:</code>, <code>sendSubviewToBack:</code>, or <code>exchangeSubviewAtIndex:withSubviewAtIndex:</code> 等方法管理层级，比直接移除后重新添加效率要高(ps: autolayout 的时候也推荐用 active ro deactive 而不是移除和添加)。</p><p><code>One place where you might add subviews to a view hierarchy is in the loadView or viewDidLoad methods of a view controller. If you are building your views programmatically, you put your view creation code in the loadView method of your view controller. Whether you create your views programmatically or load them from a nib file, you could include additional view configuration code in the viewDidLoad method.</code>  可以在视图控制器的 loadView 或 viewDidLoad 方法中，在视图层次结构中添加子视图。 如果以编程方式构建视图，则将视图创建代码放在视图控制器的 loadView方法中。 无论是以编程方式创建视图还是从nib文件加载视图，都可以在viewDidLoad方法中包含其他视图配置代码。 (ps: loadView 的官方介绍)。</p><p><a href="https://developer.apple.com/library/ios/samplecode/UICatalog/Introduction/Intro.html#//apple_ref/doc/uid/DTS40007710">Sample Code -&gt; UIKit Catalog (iOS): Creating and Customizing UIKit Controls</a></p><p>重要提示：父视图会自动保留持有其子视图，因此在嵌入子视图后，可以安全地释放该子视图。(ps: 我记得当时有一篇关于 addSubview 内存操作的博客<a href="http://codingtime.me/post/posts/leng-zhi-shi/viewcontrollerzhong-de-uiview_propertyyao-she-zhi-wei-weakhuan-shi-strong">VIEWCONTROLLER中的UIVIEW PROPERTY要设置为WEAK还是STRONG</a> 。原来 removeFromSuperview 在subview从superview remove之前会 autorelease)。</p><p>当添加view到其他view上的时候，UIKit会通知子视图和父视图关于它们的变化。所以我们在自定义 view 的时候<strong>得充分利用</strong>  <code>willMoveToSuperview:</code>, <code>willMoveToWindow:</code>, <code>willRemoveSubview:</code>, <code>didAddSubview:</code>, <code>didMoveToSuperview</code>, or <code>didMoveToWindow</code> 方法。view还有一个window属性<br>用来表明view当前展示内容的window。由于视图层次结构中的根视图没有父视图，因此其 superview 属性设置为nil。 对于当前在屏幕上的视图，窗口对象是视图层次结构的根视图。</p><h3 id="Hiding-Views"><a href="#Hiding-Views" class="headerlink" title="Hiding Views"></a>Hiding Views</h3><p>隐藏view，我们可以设置hidden属性为yes或者alpha属性为0.0。 hidden view<strong>不会接收系统touch event。但是它参与view的自动改变大小以及与当前view层级相关的布局操作</strong>。所以当你想移除view后在某个时候又想让它出现时 用hidden属性非常方便。(ps: 所以现在代码中 判断它是否有subview 然后又addSubview的代码 可以用hidden来处理?)。</p><p>重要说明：如果隐藏当前是第一个响应者的视图，则视图<strong>不会自动 resign 其第一个响应者状态</strong>。 针对第一响应者的事件仍然被传递到隐藏视图，为防止这种情况发生，应该强制视图在隐藏第一个响应者状态时 resign 。</p><p>hidden <strong>不是动画属性</strong>，如果想要动画隐藏/显示的话，请用 alpha 。</p><h3 id="Locating-Views-in-a-View-Hierarchy"><a href="#Locating-Views-in-a-View-Hierarchy" class="headerlink" title="Locating Views in a View Hierarchy"></a>Locating Views in a View Hierarchy</h3><p>这里有两种方法从view的层级里面定位到某个view:</p><ul><li>定义一个指针指向相关的view，其实就是定义一个属性或者私有的成员变量。</li><li>用 tag</li></ul><p>tag是减少硬编码以及更加动态、灵活的解决方案。这里还举例了：如果想要保存已经当前在App可见的view，可以将可见view的tag写进文件，这比archive归档要简单，尤其是在跟踪那些当前view是可见的。当App随后加载的时候，重新创建你的view，然后用保存的tag list来设置每个view的显示，这样App又返回到以前的层级状态了。(ps: 这里应该牵扯了 app 状态保存的情况)。</p><h3 id="Translating-Scaling-and-Rotating-Views"><a href="#Translating-Scaling-and-Rotating-Views" class="headerlink" title="Translating, Scaling, and Rotating Views"></a>Translating, Scaling, and Rotating Views</h3><p>每个view都有一个相关联的仿射矩阵，你可以用于翻转、缩放、旋转view的内容。 view的transforms属性影响view的最终渲染效果，通常用于滚动、动画或者其他的视觉效果。</p><p>当你给view添加多个转换，添加的顺序是非常重要的。比如：先旋转后翻转和先翻转后旋转 效果是不同的。rotation旋转跟中心点(center point)有关系，scaling会改变大小但是跟中心点没有关系。</p><h3 id="Converting-Coordinates-in-the-View-Hierarchy"><a href="#Converting-Coordinates-in-the-View-Hierarchy" class="headerlink" title="Converting Coordinates in the View Hierarchy"></a>Converting Coordinates in the View Hierarchy</h3><ul><li>convertPoint:fromView:</li><li>convertRect:fromView:</li><li>convertPoint:toView:</li><li>convertRect:toView:</li></ul><p>这些方法提供了到或者从本地坐标系的转换。 convert…:FromView: 相关方法是从其他view的坐标系中转换到当前view坐标系中的方法；convert…:toView: 是从当前view的坐标系统的位置转换到其他view的坐标系统的位置。 如果指定某个view为nil，那么转换的时候处理的就是 contain 包含该 view 的 window 。</p><p>当然window也有相应的转换方法：</p><ul><li>convertPoint:fromWindow:</li><li>convertRect:fromWindow:</li><li>convertPoint:toWindow:</li><li>convertRect:toWindow:</li></ul><p>在旋转视图中转换坐标时，a view在旋转后view的坐标和 outer view（parent）的坐标是不同的。在parent的坐标是包含自己坐标的<strong>最小矩阵</strong>，从图可以看出相对于outer view的坐标轴的方向线是平行的。</p><p><img src="https://sat02pap001files.storage.live.com/y4mGo9C1t2koREVcOXUvJdB2s6EvKMtrMdT5Ry_lsRodCdRihCb6nVMPBmeBfk8Xg7_0l7oAG-w02ARlPLhLMbxmQw58y4cPI8gQTr-F0_nH1aYtsU3VvZqfDwwL3hp2iJcecFUpHgZe67ZHX9bLjSY0iu5JwNlaeuop3rW_fPz1AEnSvDpnz8zukH7SaiJ4MNt?width=549&height=216&cropmode=none" alt="Converting values in a rotated view"></p><h2 id="Adjusting-the-Size-and-Position-of-Views-at-Runtime"><a href="#Adjusting-the-Size-and-Position-of-Views-at-Runtime" class="headerlink" title="Adjusting the Size and Position of Views at Runtime"></a>Adjusting the Size and Position of Views at Runtime</h2><p>无论view的大小怎么改变，它的subview的大小位置必须相应的改变。</p><h3 id="Being-Prepared-for-Layout-Changes"><a href="#Being-Prepared-for-Layout-Changes" class="headerlink" title="Being Prepared for Layout Changes"></a>Being Prepared for Layout Changes</h3><p>当下列事件发生时，布局会改变：</p><ul><li>The size of a view’s bounds rectangle changes. (当view的bounds发生改变时。)</li><li>An interface orientation change occurs, which usually triggers a change in the root view’s bounds rectangle.(当界面方向发生变化时，它通常会触发root view的bounds发生变化。)</li><li>The set of Core Animation sublayers associated with the view’s layer changes and requires layout.(与view layer相关的Core Animation sublayers发生改变 并且要求布局时。)</li><li>Your application forces layout to occur by calling the setNeedsLayout or layoutIfNeeded method of a view.(调用view的 setNeedsLayout 或者 layoutIfNeeded 方法时，App会强制布局。)</li><li>Your application forces layout by calling the setNeedsLayout method of the view’s underlying layer object.(当调用view下面layer的 layoutIfNeeded 方法时，App会强制布局。)</li></ul><h3 id="Handling-Layout-Changes-Automatically-Using-Autoresizing-Rules"><a href="#Handling-Layout-Changes-Automatically-Using-Autoresizing-Rules" class="headerlink" title="Handling Layout Changes Automatically Using Autoresizing Rules"></a>Handling Layout Changes Automatically Using Autoresizing Rules</h3><p>当view的大小发生变化时，它里面嵌入的subviews的大小位置一般会发生改变去适应view的新大小。view的 autoresizesSubviews 属性决定它的subview是否resize。当 autoresizesSubviews 为 YES时，并且每个subview的 autoresizingMask 会改变它们的大小位置。(即 parentview 的 autoresizesSubviews 属性和 subview 的 autoresizingMask 属性是相对应的。)<br>处理好 autoresizingMask 属性对于我们手动改变布局很重要。（如果不指定它的常量值时 当parentview的size发生变化时 它们始终维持着固定的值）</p><p><img src="https://sat02pap001files.storage.live.com/y4mxd97sB0zTkOonWadF6pz0dxep_YtT54B6d5Jb1cWLXc63jeN8Po0OLxZlh6JogO8JP2Xsp1F8e2DIogiEwScyFfQsvNtHLShe_1UhLIMEIRePEvb3KgEZMA_KlgCyRa0F9HEwdpGie06f4Q1h01XhVoUxUVndpZ0st0B3Yqnp9UVBtcvNb0mpHkLeA9mWIpU?width=925&height=525&cropmode=none" alt="Figure 3-4  View autoresizing mask constants"></p><p>Important: If a view’s transform property does not contain the identity transform, the frame of that view is undefined and so are the results of its autoresizing behaviors.（重要：如果view的 transform 属性不包含 identity transform，那么view的frame是不确定的，因为是它自动改变大小的结果。）</p><p>当automatic autoresizing适应已经在view上面处理后，UIKit会返回然后给每个view一个机会手动做相应的调整去适应它的superview. 请看下一节 Tweaking the Layout of Your Views Manually。(ps: 这根 autolayout 是一样的原理，它也会调用 layoutsubviews 。)</p><h3 id="Tweaking-the-Layout-of-Your-Views-Manually"><a href="#Tweaking-the-Layout-of-Your-Views-Manually" class="headerlink" title="Tweaking the Layout of Your Views Manually"></a>Tweaking the Layout of Your Views Manually</h3><p>当view的大小发生改变时，UIKit处理完subviews的autoresizing行为后，会调用 layoutSubviews 方法去做手动的处理。 你可以在自定义的view时做响应的处理当autoresizing行为不能产生你想要的结果时。实现这个方法 可以做下面的事情：</p><ul><li>Adjust the size and position of any immediate subviews.(改变任意直接子视图的大小位置)</li><li>Add or remove subviews or Core Animation layers.(添加或移除 subviews 或 Core Animation layers)</li><li>Force a subview to be redrawn by calling its setNeedsDisplay or setNeedsDisplayInRect: method. (通过调用 setNeedsDisplay 或者 setNeedsDisplayInRect 方法强制一个 subview 去重绘)</li></ul><p>app通常手动布局子视图的一个地方是实现大型可滚动区域。 因为为其可滚动内容提供单个大视图是不切实际的，所以应用程序通常实现包含许多较小的tile视图的根视图。 每个图块表示可滚动内容的一部分。 当滚动事件发生时，根视图调用其 setNeedsLayout 方法来启动布局更改。 然后，layoutSubviews 方法根据发生的滚动量重新定位切片视图。 当tile从视图的可见区域滚动出来时，layoutSubviews 方法会将tile移动到传入边缘(icoming edge)，替换其中的内容。<br>（这个跟tableview的处理方法差不多哈，可以处理用scrollView实现tableView的效果，详情可参看 Sample Code: <a href="https://developer.apple.com/legacy/library/samplecode/ScrollViewSuite/Introduction/Intro.html">ScorllViewSuite</a>）。</p><p>当写布局代码时，务必根据下面途径来测试你的代码：</p><ul><li>手机方向发生变化。</li><li><strong>打电话进来了</strong>，注意状态栏的变化。</li></ul><h2 id="Modifying-Views-at-Runtime"><a href="#Modifying-Views-at-Runtime" class="headerlink" title="Modifying Views at Runtime"></a>Modifying Views at Runtime</h2><p>App接受用户的输入，然后响应输入去调整用户界面。App可能会重新排列，改变大小位置，显示或隐藏它的view，或者重新加载一组新的view。会在一些地方或者相关的途径去执行一些操作：</p><ul><li>view controller: 在显示view之前创建view，在不需要的时候销毁它们；调整view的大小位置，显示或者隐藏一些views；管理可编辑的内容；</li><li>animation blocks: 在不同组之间做动画转换时，你在某个动画的block里面显示或隐藏它们；改变view的各种属性以实现特殊的效果；  </li><li>Other ways: touch event or gesture occur <a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009541">Event Handling Guide for iOS</a>; 用户与滚动视图交互时，一个大的滚动区域可能会隐藏显示相关的 tile subviews<a href="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/UIScrollView_pg/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008179">Scroll View Programming Guide for iOS</a>;  键盘事件发生时，相应相关的变化 <a href="https://developer.apple.com/library/ios/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009542">Text Programming Guide for iOS</a> </li></ul><p>(ps: 这个guide里面有相关字体的知识，可以看看这篇文章<a href="https://www.raizlabs.com/dev/2015/08/advanced-ios-typography/">iOS Typography: Stop Saying “No” to Designers</a>)</p><h2 id="Interacting-with-Core-Animation-Layers"><a href="#Interacting-with-Core-Animation-Layers" class="headerlink" title="Interacting with Core Animation Layers"></a>Interacting with Core Animation Layers</h2><p>每个view对象都有一个专门的Core Animation layer 管理view的呈现和动画在屏幕上。<strong>也就是说内容都是展示在layer上面的</strong>。尽管你能够操作 view 对象，当然你也可以在需要的时候直接操作相应的layer对象。</p><h3 id="Changing-the-Layer-Class-Associated-with-a-View"><a href="#Changing-the-Layer-Class-Associated-with-a-View" class="headerlink" title="Changing the Layer Class Associated with a View"></a>Changing the Layer Class Associated with a View</h3><p>（view关联的layer类型，在view创建后不能更改）layer的默认类型是CALayer，而唯一的改变layer类型的途径是继承它，继承相应的方法，然后返回不同的值。例如：你想要在大的滚动区域中平铺内容，你可以使用 <a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CATiledLayer_class/index.html#//apple_ref/occ/cl/CATiledLayer">CATiledLayer</a> (又是 tiling large scrollable area)。 </p><p>每个 view 的 layerClass 方法是在 initialization 初始化方法之前返回类型去创建它layer对象。此外，<strong>view通常把自己作为它layer对象的代理</strong>。在这点上，view拥有它的layer，并且view和layer之间的<strong>关系一定不能改变</strong>。同样的，你不能将同一个view作为其他任何的layer对象的代理。改变拥有关系和view的代理关系会引起绘制问题以及潜在的崩溃。</p><h3 id="Embedding-Layer-Objects-in-a-View"><a href="#Embedding-Layer-Objects-in-a-View" class="headerlink" title="Embedding Layer Objects in a View"></a>Embedding Layer Objects in a View</h3><p>如果更喜欢主要使用图层对象而不是视图，则可以根据需要将自定义图层对象合并到视图层次结构中。 <strong>自定义图层对象是不属于视图的CALayer的任何实例</strong>。 通常以编程方式创建自定义图层，并使用Core Animation例程(Core Animation routines)合并它们。 <strong>自定义图层不会接收事件或参与响应者链，但会根据核心动画规则自行绘制并响应其父视图或图层中的大小更改。</strong>(ps: 这就是 layer 和 view 的区别之一，不会响应事件)</p><h2 id="Defining-a-Custom-View"><a href="#Defining-a-Custom-View" class="headerlink" title="Defining a Custom View"></a>Defining a Custom View</h2><p>如果标准系统视图不能完全满足我们的需要，我们可以自定义视图。 自定义视图可以完全控制应用程序内容的外观以及如何处理与该内容的交互。</p><h3 id="Checklist-for-Implementing-a-Custom-View"><a href="#Checklist-for-Implementing-a-Custom-View" class="headerlink" title="Checklist for Implementing a Custom View"></a>Checklist for Implementing a Custom View</h3><p>自定义视图的<strong>工作是呈现内容并管理与该内容的交互</strong>。 但是，自定义视图的成功实现不仅仅涉及<strong>绘制和处理事件</strong>。 以下清单包括在实现自定义视图时可以覆盖的更重要的方法（以及我们可以提供的行为）：</p><ul><li>定义合适的初始化方法，<ul><li>手动创建，重载 <code>initWithFrame:</code> 或者自定义一个初始化方法；</li><li>打算从nib加载的话，重载 <code>initWithCoder:</code> 方法</li></ul></li><li>实现 <code>dealloc</code> 方法来处理任何自定义数据的清理。</li><li>处理自定义绘图的话，覆盖 <code>drawRect:</code> 方法并在那里进行绘制。</li><li>设置视图的 autoresizingMask 属性以定义其自动调整行为。</li><li>如果视图类管理一个或多个完整子视图，请执行以下操作：<ul><li>在视图的初始化序列中创建这些子视图；</li><li>在创建时设置每个子视图的 autoresizingMask 属性；</li><li>如果子视图需要自定义布局，请覆盖 layoutSubviews 方法并在那里实现布局代码；</li></ul></li><li>要处理基于触摸的事件，请执行以下操作：<ul><li>使用 <code>addGestureRecognizer:</code> 方法将任何合适的手势识别器附加到视图。</li><li>对于想自己处理触摸的情况，请覆盖 <code>touchesBegan:withEvent:</code>，<code>touchesMoved:withEvent:</code>，<code>touchesEnded:withEvent:</code> 和 <code>touchesCancelled:withEvent:</code> 方法。 （请记住，应该<strong>始终覆盖</strong> <code>touchesCancelled:withEvent:</code> 方法，无论覆盖哪些其他与触摸相关的方法。）</li></ul></li><li>如果希望视图的打印版本与屏幕版本不同，请实现 <code>drawRect:forViewPrintFormatter:</code> 方法。</li></ul><p>还可以设置 UIView 已有的属性， contentMode contentStretch 来控制绘制操作。</p><h3 id="Initializing-Your-Custom-View"><a href="#Initializing-Your-Custom-View" class="headerlink" title="Initializing Your Custom View"></a>Initializing Your Custom View</h3><p>nib 的话，用 NSCoding 协议中的 initWithCoder: 方法来处理的。即使你实现了NSCoding协议，<strong>IB 还是不知道你 custom view 的属性，所以不会 encode 这些属性到 nib 文件</strong>。所以，你需要在 <code>initWithCoder:</code> 方法里面执行各种初始化代码是视图它处于一个已知的状态。当然也可以事先 <code>awakeFromNib</code> 方法去执行一些额外的初始化工作。</p><h3 id="Implementing-Your-Drawing-Code"><a href="#Implementing-Your-Drawing-Code" class="headerlink" title="Implementing Your Drawing Code"></a>Implementing Your Drawing Code</h3><p>如果你要实现自定义的绘制，你需要去重载 <code>drawRect:</code> 方法去绘制。<strong>自定义绘制是推荐的最后一种手段。通常情况下，推荐使用其他的views去展示内容</strong>。 </p><p><code>drawRect:</code> 方法只做<strong>一件事：绘制内容</strong>。你不能在这个方法里面更新你APP的数据结构或者执行其他与绘制无关的任务。配置好环境后就开始绘制内容，尽可能快的退出该方法。如果你的 <code>drawRect:</code> 方法需要频繁的调用，你必须做任何能够优化绘制代码的事情并且每次尽可能的绘制一点点。<br>在调用<code>drawRect:</code>方法之前，<strong>UIKit 会配置 view 的基础绘制环境</strong>。明确来说，它会创建一个 graphics content, 并且自适应坐标系统，为了匹配 view 的可视化区域而裁剪相关区域。所以，当 <code>drawRect:</code> 方法调用后，你就可以开始绘制了。你可以用 UIGraphicsGetCurrentContext 方法获取 current graphics context 的指针。</p><p><strong>要点</strong>：当前图形上下文(current graphics context)仅在对视图的<code>drawRect:</code>方法的<strong>一次调用期间有效</strong>。 UIKit可能会为每个后续调用此方法创建不同的图形上下文，因此不应尝试缓存该对象并在以后使用它。</p><p>如果我们知道视图的绘图代码始终覆盖具有不透明内容的视图的整个表面，则可以通过<strong>将视图的opaque属性设置为YES来提高系统性能</strong>。 将视图标记为不透明时，UIKit会避免绘制位于视图后面的内容。 <strong>这不仅减少了绘图所花费的时间，而且最大限度地减少了将视图与其他内容合成所必须完成的工作</strong>。 但是，<strong>只有</strong>在知道视图的内容完全不透明时，才应将此属性设置为YES。 如果视图无法保证其内容始终不透明，则应将该属性设置为NO。 (ps: 自己确定完全不透明的情况下，将 opaque 置为 NO, 提升性能)</p><p><strong>另一种提高绘图性能的方法，特别是在滚动期间，是将视图的 clearsContextBeforeDrawing 属性设置为NO</strong>。 当此属性设置为YES时，UIKit会在调用方法之前<strong>使用透明黑色自动填充要由 <code>drawRect:</code> 方法更新的区域</strong>。 将此属性设置为NO可消除该填充操作的开销，但会给应用程序带来负担，将填充传递给带有内容的 <code>drawRect:</code> 方法的更新矩形。(“Setting this property to NO eliminates the overhead for that fill operation but puts the burden on your application to fill the update rectangle passed to your drawRect: method with content.”) (ps: clearsContextBeforeDrawing 置为 NO, 避免填充带来的开销，但是会传递给 drawRect: 方法)</p><h3 id="Responding-to-Events"><a href="#Responding-to-Events" class="headerlink" title="Responding to Events"></a>Responding to Events</h3><p>注意：UIView的动画方法通常<strong>在动画正在进行时禁用触摸事件</strong>。 可以通过适当地配置动画来覆盖此行为。 有关执行动画的更多信息，请参阅”#Animations#”。</p><p>当你处理触摸事件的时候，UIKit用 <code>hitTest:withEvent:</code> 和 <code>pointInside:withEvent:</code> 方法去决定该触摸事件是否发生在指定view的边界内。虽然很少需要去重载这些方法，你仍然可以用它去实现某些自定义view的自定义触摸事件。例如：你可以重载该方法去防止某些subview去处理触摸事件。</p><h3 id="Cleaning-Up-After-Your-View"><a href="#Cleaning-Up-After-Your-View" class="headerlink" title="Cleaning Up After Your View"></a>Cleaning Up After Your View</h3><p>不要在这个方法里面做其他事情，只做释放资源的事情。</p><h1 id="Animations"><a href="#Animations" class="headerlink" title="Animations"></a>Animations</h1><p>动画在用户界面切换不同状态时提供<strong>流动的视觉转换效果</strong>。在iOS动画中，一般会重置view的位置，改变它的大小，从view曾经中移除，隐藏它们。你可能会用动画传达反馈给用户或者实施有趣的视觉效果。 在iOS中，创建复杂的动画不需要编写任何绘图代码。 本章中描述的所有动画技术都使用 Core Animation 提供的内置支持。 所要做的就是触发动画并让Core Animation处理各个帧的渲染。</p><h2 id="What-Can-Be-Animated"><a href="#What-Can-Be-Animated" class="headerlink" title="What Can Be Animated?"></a>What Can Be Animated?</h2><p>在UIKit中，用UIView对象就能执行动画。<br>UIView支持animatable动画的属性有: frame、bounds、center、transform、alpha、backgroundcolor、contentstretch。<br>如果你想执行更加复杂的动画，可以使用Core Animation 用layer来创建动画。<strong>因为layer错综复杂联系在一起，改变view的layer能够改变view自己</strong>。使用Core Animation，你可以动画下面类型的改变：</p><ul><li>The size and position of the layer</li><li>The center point used when performing transformations</li><li>Transformations to the layer or its sublayers in 3D space</li><li>The addition or removal of a layer from the layer hierarchy</li><li>The layer’s Z-order relative to other sibling layers</li><li>The layer’s shadow</li><li>The layer’s border (including whether the layer’s corners are rounded)</li><li>The portion of the layer that stretches during resizing operations</li><li>The layer’s opacity</li><li>The clipping behavior for sublayers that lie outside the layer’s bounds</li><li>The current contents of the layer</li><li>The rasterization behavior of the layer</li></ul><p><strong>注意</strong>：如果视图承载自定义图层对象（即没有关联视图的图层对象），则必须使用 Core Animation 对其进行动画处理。</p><p>更多的核心动画，请看 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004514">About Core Animation</a> 和 <a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/CoreAnimation_Cookbook/Introduction/Introduction.html#//apple_ref/doc/uid/TP40005406">Core Animation Cookbook</a></p><h2 id="Animating-Property-Changes-in-a-View"><a href="#Animating-Property-Changes-in-a-View" class="headerlink" title="Animating Property Changes in a View"></a>Animating Property Changes in a View</h2><p>为了对UIView类的属性进行动画处理，必须将这些更改包装在动画块中。在iOS 4以及以后，用block-based来执行动画，在iOS3.2及以前用begining和end来处理，当然这两种技术支持同样的配置以前提供相同的动画执行，但是block-based更加优秀。 </p><h3 id="Starting-Animations-Using-the-Block-Based-Methods"><a href="#Starting-Animations-Using-the-Block-Based-Methods" class="headerlink" title="Starting Animations Using the Block-Based Methods"></a>Starting Animations Using the Block-Based Methods</h3><p>所以这里只讲block-based类型的动画。主要是以下这三个方法：</p><ul><li>animateWithDuration:animations:</li><li>animateWithDuration:animations:completion:</li><li>animateWithDuration:delay:options:animations:completion:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[UIView animateWithDuration:1.0 animations:^&#123;</span><br><span class="line">        firstView.alpha &#x3D; 0.0;</span><br><span class="line">        secondView.alpha &#x3D; 1.0;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>执行上述代码时，<strong>会立即在另一个线程上启动指定的动画，以避免阻塞当前线程或应用程序的主线程</strong>。</p><p><strong>要点</strong>：当一个属性的动画正在进行时，更改该属性的值不会停止当前动画。<strong>相反</strong>，当前动画将继续并动画显示刚刚分配给属性的新值。</p><p>“Whether touch events are delivered to views while the animations are in progress” (ps: 动画进行中，还能接受其他事件？如果真要这么处理，该怎么玩)</p><h3 id="Nesting-Animation-Blocks"><a href="#Nesting-Animation-Blocks" class="headerlink" title="Nesting Animation Blocks"></a>Nesting Animation Blocks</h3><p>大部分内嵌动画用自己的配置选项与父类（外面）<strong>同时开始执行</strong>。默认情况下，nested animations继承parent animations的时间与动画选项，但是这些选项在必须情况下是可以重载的。例如(UIViewAnimationOptionOverrideInheritedCurve  UIViewAnimationOptionOverrideInheritedDuration)</p><h3 id="Implementing-Animations-That-Reverse-Themselves"><a href="#Implementing-Animations-That-Reverse-Themselves" class="headerlink" title="Implementing Animations That Reverse Themselves"></a>Implementing Animations That Reverse Themselves</h3><p>可以用 repeat count 结合创建一个可逆的动画，考虑为了repeat count 指定一个非整形的值。对于autoreversing自动翻转的动画，某个完整的动画周期涉及到从原值到新值，然后再返回到原值。对于重复的动画，<strong>如果希望动画以新值结束</strong>，则向重复计数添加 0.5 会导致动画完成以新值结束所需的额外半周期。如果不包括此半步，则动画将设置为原始值的动画，然后快速捕捉到新值，这可能不是想要的视觉效果。</p><h2 id="Creating-Animated-Transitions-Between-Views"><a href="#Creating-Animated-Transitions-Between-Views" class="headerlink" title="Creating Animated Transitions Between Views"></a>Creating Animated Transitions Between Views</h2><p>视图过渡(view transition)会帮助你在你的view的层级里面隐藏关于添加、移除、隐藏、显示views的突然操作。即这些操作方法时不会一下子就发生了，会有个一个过渡效果。 你会用view transtions实现下列类型的改变：</p><ul><li>改变 subview 是否可见</li><li>将一个 subview 替换成另一个 subview </li></ul><p><strong>要点</strong>：视图过渡不应与视图控制器启动的过渡 混淆，例如模态视图控制器的显示或将新视图控制器推送到导航堆栈。 视图转换仅影响视图层次结构，而视图控制器转换也会更改活动视图控制器。因此，对于视图转换，在启动转换时处于活动状态的视图控制器在转换完成时也保持活动状态。</p><h3 id="Changing-the-Subviews-of-a-View"><a href="#Changing-the-Subviews-of-a-View" class="headerlink" title="Changing the Subviews of a View"></a>Changing the Subviews of a View</h3><p>在iOS 4及更高版本中，使用 <code>transitionWithView:duration:options:animations:completion:</code> 方法来启动视图的过渡动画。 在传递给此方法的动画块中，通常设置为动画的唯一更改是与显示，隐藏，添加或删除子视图相关联的更改。 将动画限制到此集合中，允许视图创建视图前后两个版本的<strong>快照图像，并在两个图像之间设置动画，这样更有效</strong>。 但是，如果需要动画其他改变，则可以在调用方法时包含 UIViewAnimationOptionAllowAnimatedContent 选项。包含该选项可<strong>防止</strong>视图直接创建快照并直接动画所有更改。 (ps: 快照 snapshot)</p><h3 id="Replacing-a-View-with-a-Different-View"><a href="#Replacing-a-View-with-a-Different-View" class="headerlink" title="Replacing a View with a Different View"></a>Replacing a View with a Different View</h3><p>这个技术能让你用一些标准的过渡效果快速的呈现一个新的内容。如果你不选择先移除后插入的方式，而是用隐藏的效果来处理，则可以用  UIViewAnimationOptionShowHideTransitionViews 关键字。</p><h2 id="Linking-Multiple-Animations-Together"><a href="#Linking-Multiple-Animations-Together" class="headerlink" title="Linking Multiple Animations Together"></a>Linking Multiple Animations Together</h2><p>completion handler 可以将多个animation连接起来，它们是<strong>相继</strong>发生的，而不是同时发生。 当然你还可以用nested animations使用不同的delay延时因素，因为<strong>nested animation是同时发生的</strong>，只能控制它们的delay延时时间来达到相继发生的效果。</p><h2 id="Animating-View-and-Layer-Changes-Together"><a href="#Animating-View-and-Layer-Changes-Together" class="headerlink" title="Animating View and Layer Changes Together"></a>Animating View and Layer Changes Together</h2><p>APP能够在需要的时候自由的混合 view-based 和 layer-based 的动画代码，但是配置动画属性的过程<strong>取决于谁拥有这个layer</strong>。改变 view-owned layer 跟改变 view 是同样的效果，并且你添加到 layer 属性的动画能够反应在当前 view-based animations 里面。同样的，<strong>它不适用于你自己创建的layer，custom layer会忽略掉view-based animations 参数，默认情况下适用 Core Animation 参数代替</strong>。 用 Core Animation 动画 layers 可以创建一个 CABasicAnimation 对象或者 CAAnimation 的子类。 用 Core Animation 做动画会更加容易，可以查看 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004514">Core Animation Programming Guide</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;WWDC&quot;&gt;&lt;a href=&quot;#WWDC&quot; class=&quot;headerlink&quot; title=&quot;WWDC&quot;&gt;&lt;/a&gt;WWDC&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2011/121/&quot;&gt;Understanding UIKit Rendering&lt;/a&gt; 主要讲了显示青蛙的一个 demo ，讲了 round rotate anti-aliased shadow 等效果，先讲了之前做的为什么会错误，后面讲了正确的做法，这个 session 比较简单，相关内容，后续关于渲染的 session 都有讲到。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="WWDC" scheme="http://example.com/tags/WWDC/"/>
    
      <category term="AppleDocument" scheme="http://example.com/tags/AppleDocument/"/>
    
  </entry>
  
  <entry>
    <title>从 Block 谈堆栈</title>
    <link href="http://example.com/2018/03/18/Block-heap-stack/"/>
    <id>http://example.com/2018/03/18/Block-heap-stack/</id>
    <published>2018-03-18T02:48:11.000Z</published>
    <updated>2021-01-22T14:55:23.845Z</updated>
    
    <content type="html"><![CDATA[<p>在面试的时候，我们会碰到 <code>Block</code> 相关的问题：<strong>MRC 下为什么要用 copy 修饰? 为什么 ARC 下就不要这样处理呢？</strong>，所以打算把堆栈的内容和 <code>Block</code> 一起讲解。</p><a id="more"></a><h1 id="堆栈存储域"><a href="#堆栈存储域" class="headerlink" title="堆栈存储域"></a>堆栈存储域</h1><ul><li><strong>堆</strong>   堆的空间需要程序员手动申请分配，它的内存是动态分配的，我们需要手动管理这部分内存，用完了要销毁掉，这部分内存属于<code>dirty memory</code>。简单点，就是 malloc 与 free。</li><li><strong>栈</strong>   栈的内存是系统编译管理，跟程序员无关，它一般用来存储局部变量等。</li></ul><p>在 <code>OC</code> 中我们创建一个对象，它最终会调用 <code>calloc</code> 方法在堆上创建内存。那有没有对象是创建在栈上的呢？先来看看栈对象的优缺点。</p><h2 id="栈对象"><a href="#栈对象" class="headerlink" title="栈对象"></a>栈对象</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><strong>快速</strong>   在栈上创建对象很快。因为很多东西在编译时就确定了，在运行时，需要做的事情很少，相对而言，在堆上创建对象就比较耗时。</li><li><strong>简单</strong>   它的声明周期是确定的，对象出栈以后就会被释放，不会发生内存泄露。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li><strong>生命周期固定</strong>   一旦函数返回，它的栈帧就会被摧毁，那么对象也会被释放。如果这个对象通过方法调用需要传递到别的方法里面去，那被释放掉了，会产生野指针，此时 <code>retain</code> 也不起作用，它不适合引用计数内存管理方法。</li><li><strong>大小固定</strong>   栈空间有限，创建时的长度是固定好的，没法扩展。</li></ul><h2 id="OC-中的栈对象"><a href="#OC-中的栈对象" class="headerlink" title="OC 中的栈对象"></a>OC 中的栈对象</h2><p>这就是我们今天的主角了: <strong>Block</strong>，它就是典型的栈对象。先从几段官方文档中获取相关信息</p><ul><li>“Blocks are Objective-C objects, which means they can be added to collections like NSArray or NSDictionary.”  得知 <code>Blocks</code> 是对象。</li><li> “As an optimization, block storage starts out on the stack—just like blocks themselves do. “ 和 “The initial allocation is done on the stack, but the runtime provides a Block_copy function which, given a block pointer, either copies the underlying block object to the heap, setting its reference count to 1 and returning the new block pointer, or (if the block object is already on the heap) increases its reference count by 1.”  得知 Block 对象与一般类的实例对象不同，它默认是分配在栈上的，一般类的实例对象则在堆上分配。 </li></ul><p>而在 <code>ARC</code> 下，<code>Block</code> 会被拷贝到堆中。所以下面的代码只有在 <code>ARC</code> 下才能正确执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef NSInteger (^blk)(NSInteger);</span><br><span class="line"></span><br><span class="line">blk func(NSInteger pram) &#123;</span><br><span class="line">    return ^(NSInteger count)&#123;return pram * count;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    blk blk1 &#x3D; func(2);</span><br><span class="line">    NSInteger result &#x3D; blk1(4);</span><br><span class="line">    printf(&quot;result:%ld&quot;, result);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h1><p>那什么是 <code>Block</code> 呢？它是带有自动变量（局部变量）的匿名函数。它的语法格式为<code>^ 返回值类型 参数列表 表达式</code>。它的申明可以查看 <a href="http://fuckingblocksyntax.com/">How Do I Declare A Block in Objective-C?</a>。我们一步步来看看它的实现，先看一个简单的 <code>Block</code>（这里会查看对应编译代码和汇编代码）。</p><h2 id="简单-Block"><a href="#简单-Block" class="headerlink" title="简单 Block"></a>简单 Block</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    dispatch_block_t blk &#x3D; ^&#123;printf(&quot;Block\n&quot;);&#125;;</span><br><span class="line">    blk();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; clang -rewrite-objc 后所得</span><br><span class="line">struct __block_impl &#123; </span><br><span class="line">  void *isa; &#x2F;&#x2F; isa指针，关于类与对象的，下次聊 runtime 讲解类和对象的时候再详解</span><br><span class="line">  int Flags; &#x2F;&#x2F; 标志位</span><br><span class="line">  int Reserved; &#x2F;&#x2F; 为以后升级保留的</span><br><span class="line">  void *FuncPtr; &#x2F;&#x2F; 函数指针</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl; &#x2F;&#x2F; Block 实现</span><br><span class="line">  struct __main_block_desc_0* Desc; &#x2F;&#x2F; Block 描述</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags&#x3D;0) &#123; &#x2F;&#x2F; 构造函数</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteStackBlock; &#x2F;&#x2F; 栈 Block</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;</span><br><span class="line">    Desc &#x3D; desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; &#x2F;&#x2F; Block 实现函数</span><br><span class="line">printf(&quot;Block\n&quot;);&#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123; &#x2F;&#x2F; Block 描述结构体</span><br><span class="line">  size_t reserved; &#x2F;&#x2F; 为以后升级保留的</span><br><span class="line">  size_t Block_size; &#x2F;&#x2F; Block 大小</span><br><span class="line">&#125; __main_block_desc_0_DATA &#x3D; &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123; &#x2F;&#x2F; main 函数</span><br><span class="line">    dispatch_block_t blk &#x3D; ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>变换后的源码，<code>Blocks</code> 变成了 C  函数<code>__main_block_func_0</code>，它有一个结构体指针的入参<code>struct __main_block_impl_0 *</code>，相关注释已经写在编译后的代码里面了。相关调用方法为 <code>blk() -&gt; ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk)</code>，去掉相关转换部分为 <code>(*blk-&gt;FuncPtr)(blk)</code>，这就是一个函数指针调用函数啊，而在初始化 <code>&amp;__main_block_impl_0</code> 时赋值给 <code>FuncPtr</code> 就是 <code>__main_block_func_0</code>，所以这里就是调用 <code>__main_block_func_0</code>，<code>Block</code>最终还是调用函数，打印  “Block”字符串。</p><h2 id="捕获自动变量"><a href="#捕获自动变量" class="headerlink" title="捕获自动变量"></a>捕获自动变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    NSInteger val &#x3D; 10;</span><br><span class="line">    dispatch_block_t blk &#x3D; ^&#123;printf(&quot;Block:%ld\n&quot;, (long)val);&#125;;</span><br><span class="line">    val &#x3D; 20;</span><br><span class="line">    blk();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; clang -rewrite-objc 后所得</span><br><span class="line">struct __block_impl &#123;</span><br><span class="line">  void *isa;</span><br><span class="line">  int Flags;</span><br><span class="line">  int Reserved;</span><br><span class="line">  void *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  NSInteger val; </span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, NSInteger _val, int flags&#x3D;0) : val(_val) &#123;</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;</span><br><span class="line">    Desc &#x3D; desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  NSInteger val &#x3D; __cself-&gt;val; &#x2F;&#x2F; bound by copy</span><br><span class="line">printf(&quot;Block:%ld\n&quot;, (long)val);&#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA &#x3D; &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    NSInteger val &#x3D; 10;</span><br><span class="line">    dispatch_block_t blk &#x3D; ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, val));</span><br><span class="line">    val &#x3D; 20;</span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h3><p>跟上面比，代码有点不同，<code>__main_block_impl_0</code> 多了一个成员变量 <code>val</code>（用来存储 <code>Block</code> 里面所使用的变量）。在 <code>__main_block_impl_0</code> 初始化的时候，将外部的变量值 <code>val</code> 赋值给 <code>__main_block_impl_0</code> 的 <code>val</code>（捕获自动变量的原理），然后调用 <code>Block</code> 的时候获取 <code>__main_block_impl_0</code> 的 <code>val</code> 再打印。</p><h2 id="block-修饰符"><a href="#block-修饰符" class="headerlink" title="__block 修饰符"></a>__block 修饰符</h2><p>如果在<code>Block</code>里面对所捕获的变量进行赋值时，编译时会报错，提示我们加上<code>__block</code>修饰符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    NSInteger val &#x3D; 10;</span><br><span class="line">    dispatch_block_t blk &#x3D; ^&#123;</span><br><span class="line">        val &#x3D; 30;</span><br><span class="line">        printf(&quot;Block:%ld\n&quot;, (long)val);</span><br><span class="line">    &#125;;</span><br><span class="line">    val &#x3D; 20;</span><br><span class="line">    blk();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 报错内容：Variable is not assignable (missing __block type specifier)</span><br></pre></td></tr></table></figure><p>记住，只是<strong>赋值</strong>才会有问题，调用变更对象的方法是没问题。例如，下面的代码就没问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    NSMutableArray *array &#x3D; [NSMutableArray array];</span><br><span class="line">    dispatch_block_t blk &#x3D; ^&#123;</span><br><span class="line">        NSObject *objc &#x3D; [[NSObject alloc] init];</span><br><span class="line">        [array addObject:objc];</span><br><span class="line">    &#125;;</span><br><span class="line">    blk();</span><br><span class="line">    NSLog(@&quot;array:%@&quot;, array);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>__block</code> 说明符类似于 <code>static</code>、<code>auto</code> 和 <code>register</code> 说明符，它们用于指定将变量的值设置在哪个存储域。例如，<code>auto</code> 表示自动变量存储在栈中，<code>static</code> 表示作为静态变量存储在数据区中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    __block NSInteger val &#x3D; 10;</span><br><span class="line">    dispatch_block_t blk &#x3D; ^&#123;</span><br><span class="line">        val &#x3D; 30;</span><br><span class="line">        printf(&quot;Block inner val:%ld\n&quot;, (long)val);</span><br><span class="line">    &#125;;</span><br><span class="line">    val &#x3D; 20;</span><br><span class="line">    blk();</span><br><span class="line">    printf(&quot;out val:%ld\n&quot;, (long)val);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出结果</span><br><span class="line">Block inner val:30</span><br><span class="line">out val:30</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; clang -rewrite-objc 后所得</span><br><span class="line">struct __block_impl &#123;</span><br><span class="line">  void *isa;</span><br><span class="line">  int Flags;</span><br><span class="line">  int Reserved;</span><br><span class="line">  void *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __Block_byref_val_0 &#123; &#x2F;&#x2F; 结构体</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_val_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> NSInteger val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_val_0 *val; &#x2F;&#x2F; by ref</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_val_0 *_val, int flags&#x3D;0) : val(_val-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;</span><br><span class="line">    Desc &#x3D; desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_val_0 *val &#x3D; __cself-&gt;val; &#x2F;&#x2F; bound by ref</span><br><span class="line"></span><br><span class="line">        (val-&gt;__forwarding-&gt;val) &#x3D; 30;</span><br><span class="line">        printf(&quot;Block inner val:%ld\n&quot;, (long)(val-&gt;__forwarding-&gt;val));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;val, (void*)src-&gt;val, 8&#x2F;*BLOCK_FIELD_IS_BYREF*&#x2F;);&#125; &#x2F;&#x2F; 拷贝函数，拷贝到堆上</span><br><span class="line"></span><br><span class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;val, 8&#x2F;*BLOCK_FIELD_IS_BYREF*&#x2F;);&#125; &#x2F;&#x2F; 销毁函数，销毁堆上的数据</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  void (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA &#x3D; &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_val_0 val &#x3D; &#123;(void*)0,(__Block_byref_val_0 *)&amp;val, 0, sizeof(__Block_byref_val_0), 10&#125;;</span><br><span class="line">    dispatch_block_t blk &#x3D; ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_val_0 *)&amp;val, 570425344));</span><br><span class="line">    (val.__forwarding-&gt;val) &#x3D; 20;</span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">    printf(&quot;out val:%ld\n&quot;, (long)(val.__forwarding-&gt;val));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>原本的 <code>__block</code> 变量竟然变成了一个结构体 <code>__Block_byref_val_0</code> 实例。这里的赋值操作比较怪异，明明直接 <code>val-&gt;val = 30</code> 就行了，为什么还要 <code>val-&gt;__forwarding-&gt;val) = 30</code>。这个 <code>__forwarding</code> 成员变量是用来指向堆上的结构体实例的，因为这里发生了拷贝行为，将 <code>__block</code> 变量从栈上拷贝到了堆上。Block 有三种类型，</p><ul><li>_NSConcreteStackBlock    该类的 Block 变量设置在栈上</li><li>_NSConcreteGlobalBlock   该类的 Block 变量设置在数据区域（.data区）上</li><li>_NSConcreteMallocBlock    该类的 Block 变量设置在有 malloc 函数分配的内存块（即堆）中</li></ul><p><code>_NSConcreteStackBlock</code> 类型如以下代码所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">dispatch_block_t blk &#x3D; ^&#123;</span><br><span class="line">    printf(&quot;Global Block&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    blk();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; clang -rewrite-objc 后所得</span><br><span class="line">struct __blk_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __blk_block_desc_0* Desc;</span><br><span class="line">  __blk_block_impl_0(void *fp, struct __blk_block_desc_0 *desc, int flags&#x3D;0) &#123;</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteGlobalBlock;</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;</span><br><span class="line">    Desc &#x3D; desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void __blk_block_func_0(struct __blk_block_impl_0 *__cself) &#123;</span><br><span class="line"></span><br><span class="line">    printf(&quot;Global Block&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct __blk_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __blk_block_desc_0_DATA &#x3D; &#123; 0, sizeof(struct __blk_block_impl_0)&#125;;</span><br><span class="line">static __blk_block_impl_0 __global_blk_block_impl_0((void *)__blk_block_func_0, &amp;__blk_block_desc_0_DATA);</span><br><span class="line">dispatch_block_t blk &#x3D; ((void (*)())&amp;__global_blk_block_impl_0);</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在只有 <code>_NSConcreteMallocBlock</code> 没有看到了，先看一段代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef NSInteger (^blk)(NSInteger);</span><br><span class="line"></span><br><span class="line">blk func(NSInteger pram) &#123;</span><br><span class="line">    return ^(NSInteger count)&#123;return pram * count;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    blk blk1 &#x3D; func(2);</span><br><span class="line">    NSInteger result &#x3D; blk1(4);</span><br><span class="line">    printf(&quot;result:%ld&quot;, result);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Xcode 运行输出</span><br><span class="line">result:8</span><br></pre></td></tr></table></figure><p>但是在终端用 clang 编译的时候会报错，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;var&#x2F;folders&#x2F;hn&#x2F;g9n1gw8d6p3655k44zsrnh_h0000gn&#x2F;T&#x2F;main-a7f5c2.mi:46504:12: error: returning block that lives on the local stack</span><br><span class="line">    return ^(NSInteger count)&#123;return pram * count;&#125;;</span><br></pre></td></tr></table></figure><p>报错信息表示 <code>func</code> 函数返回的是在栈上的 <code>Block</code> 对象，函数返回后，它的作用域结束，所以栈上的 <code>Block</code> 也被废弃，这样提示没毛病啊，但是 <code>Xcode</code> 运行确正常啊，说明系统（ARC 情况下）帮我们拷贝到了堆上，因为你把<code>main.m</code>文件编译的时候加上<code>-fno-objc-arc</code>，它就会报错上面一样的错误。那来看看它的汇编代码 <code>Xcode -&gt; Product -&gt; Perform Action -&gt; Assemble&quot;main.m&quot;</code>，汇编代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">.section__TEXT,__text,regular,pure_instructions</span><br><span class="line">.ios_version_min 8, 1</span><br><span class="line">.syntax unified</span><br><span class="line">.file1 &quot;&#x2F;Users&#x2F;Admin&#x2F;Documents&#x2F;Demo&#x2F;DatePicker&quot; &quot;&#x2F;Users&#x2F;Admin&#x2F;Documents&#x2F;Demo&#x2F;DatePicker&#x2F;DatePicker&#x2F;main.m&quot;</span><br><span class="line">.globl_func</span><br><span class="line">.align1</span><br><span class="line">.code16                      @ @func</span><br><span class="line">.thumb_func_func</span><br><span class="line">_func:</span><br><span class="line">Lfunc_begin0:</span><br><span class="line">.loc1 17 0                  @ &#x2F;Users&#x2F;Admin&#x2F;Documents&#x2F;Demo&#x2F;DatePicker&#x2F;DatePicker&#x2F;main.m:17:0</span><br><span class="line">.cfi_startproc</span><br><span class="line">@ BB#0:</span><br><span class="line">push&#123;r7, lr&#125;</span><br><span class="line">movr7, sp</span><br><span class="line">subsp, #28</span><br><span class="line">@DEBUG_VALUE: func:pram &lt;- [%SP+24]</span><br><span class="line">strr0, [sp, #24]</span><br><span class="line">.loc1 18 12 prologue_end    @ &#x2F;Users&#x2F;Admin&#x2F;Documents&#x2F;Demo&#x2F;DatePicker&#x2F;DatePicker&#x2F;main.m:18:12</span><br><span class="line">Ltmp0:</span><br><span class="line">movwr0, :lower16:(L__NSConcreteStackBlock$non_lazy_ptr-(LPC0_0+4))</span><br><span class="line">movtr0, :upper16:(L__NSConcreteStackBlock$non_lazy_ptr-(LPC0_0+4))</span><br><span class="line">LPC0_0:</span><br><span class="line">addr0, pc</span><br><span class="line">ldrr0, [r0]</span><br><span class="line">strr0, [sp]</span><br><span class="line">mov.wr0, #-1073741824</span><br><span class="line">strr0, [sp, #4]</span><br><span class="line">movsr0, #0</span><br><span class="line">strr0, [sp, #8]</span><br><span class="line">movwr0, :lower16:(___func_block_invoke-(LPC0_1+4))</span><br><span class="line">movtr0, :upper16:(___func_block_invoke-(LPC0_1+4))</span><br><span class="line">LPC0_1:</span><br><span class="line">addr0, pc</span><br><span class="line">strr0, [sp, #12]</span><br><span class="line">movwr0, :lower16:(___block_descriptor_tmp-(LPC0_2+4))</span><br><span class="line">movtr0, :upper16:(___block_descriptor_tmp-(LPC0_2+4)) </span><br><span class="line">LPC0_2:</span><br><span class="line">addr0, pc</span><br><span class="line">strr0, [sp, #16]</span><br><span class="line">.loc1 0 0                   @ &#x2F;Users&#x2F;Admin&#x2F;Documents&#x2F;Demo&#x2F;DatePicker&#x2F;DatePicker&#x2F;main.m:0:0</span><br><span class="line">ldrr0, [sp, #24]</span><br><span class="line">.loc1 18 12                 @ &#x2F;Users&#x2F;Admin&#x2F;Documents&#x2F;Demo&#x2F;DatePicker&#x2F;DatePicker&#x2F;main.m:18:12</span><br><span class="line">strr0, [sp, #20]</span><br><span class="line">movr0, sp</span><br><span class="line">bl_objc_retainBlock</span><br><span class="line">Ltmp1:</span><br><span class="line">.loc1 18 5 is_stmt 0        @ &#x2F;Users&#x2F;Admin&#x2F;Documents&#x2F;Demo&#x2F;DatePicker&#x2F;DatePicker&#x2F;main.m:18:5</span><br><span class="line">addsp, #28</span><br><span class="line">pop.w&#123;r7, lr&#125;</span><br><span class="line">b.w_objc_autoreleaseReturnValue</span><br><span class="line">Ltmp2:</span><br><span class="line">Lfunc_end0:</span><br><span class="line">.cfi_endproc</span><br><span class="line"></span><br><span class="line">.align1</span><br><span class="line">.code16                      @ @__func_block_invoke</span><br><span class="line">.thumb_func___func_block_invoke</span><br><span class="line">___func_block_invoke:</span><br><span class="line">Lfunc_begin1:</span><br><span class="line">.loc1 18 0 is_stmt 1        @ &#x2F;Users&#x2F;Admin&#x2F;Documents&#x2F;Demo&#x2F;DatePicker&#x2F;DatePicker&#x2F;main.m:18:0</span><br><span class="line">.cfi_startproc</span><br><span class="line">@ BB#0:</span><br><span class="line">subsp, #12</span><br><span class="line">strr0, [sp, #8]</span><br><span class="line">@DEBUG_VALUE: __func_block_invoke: &lt;- %R0</span><br><span class="line">.loc1 18 30 prologue_end    @ &#x2F;Users&#x2F;Admin&#x2F;Documents&#x2F;Demo&#x2F;DatePicker&#x2F;DatePicker&#x2F;main.m:18:30</span><br><span class="line">Ltmp3:</span><br><span class="line">movr2, r0</span><br><span class="line">strr1, [sp, #4]</span><br><span class="line">strr2, [sp]</span><br><span class="line">.loc1 18 38 is_stmt 0       @ &#x2F;Users&#x2F;Admin&#x2F;Documents&#x2F;Demo&#x2F;DatePicker&#x2F;DatePicker&#x2F;main.m:18:38</span><br><span class="line">Ltmp4:</span><br><span class="line">ldrr0, [r0, #20]</span><br><span class="line">Ltmp5:</span><br><span class="line">.loc1 18 45                 @ &#x2F;Users&#x2F;Admin&#x2F;Documents&#x2F;Demo&#x2F;DatePicker&#x2F;DatePicker&#x2F;main.m:18:45</span><br><span class="line">ldrr1, [sp, #4]</span><br><span class="line">.loc1 18 43                 @ &#x2F;Users&#x2F;Admin&#x2F;Documents&#x2F;Demo&#x2F;DatePicker&#x2F;DatePicker&#x2F;main.m:18:43</span><br><span class="line">mulsr0, r1, r0</span><br><span class="line">.loc1 18 31                 @ &#x2F;Users&#x2F;Admin&#x2F;Documents&#x2F;Demo&#x2F;DatePicker&#x2F;DatePicker&#x2F;main.m:18:31</span><br><span class="line">addsp, #12</span><br><span class="line">bxlr</span><br><span class="line">Ltmp6:</span><br><span class="line">Lfunc_end1:</span><br><span class="line">.cfi_endproc</span><br></pre></td></tr></table></figure><p>我们看到了 <code>_objc_retainBlock</code> 和 <code>_objc_autoreleaseReturnValue</code>，在 <code>runtime</code> 源码中，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id objc_retainBlock(id x) &#123;</span><br><span class="line">    return (id)_Block_copy(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说 <code>ARC</code> 帮我们进行了拷贝处理，将 <code>Block</code> 从栈上拷贝到了推上，返回了 <code>autorelease</code> 对象，所以 <code>Xcode</code> 运行才会没毛病。在<code>Objective-C Automatic Reference Counting (ARC) - Blocks</code> 里面也有提及。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">With the exception of retains done as part of initializing a __strong parameter variable or reading a __weak variable, whenever these semantics call for retaining a value of block-pointer type, it has the effect of a Block_copy. The optimizer may remove such copies when it sees that the result is used only as an argument to a call.</span><br></pre></td></tr></table></figure><p>现在，文章开头的问题解决了吧，但是，为什么我们现在声明 <code>Block</code> 属性的时候还是用 <code>copy</code> 修饰符呢？，算是为了解决历史遗留问题吧，给开发者提个醒吧。在<code>Programming with Objective-C : Working with Blocks</code> 苹果官方文档中，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">You should specify copy as the property attribute, because a block needs to be copied to keep track of its captured state outside of the original scope. This isn’t something you need to worry about when using Automatic Reference Counting, as it will happen automatically, but it’s best practice for the property attribute to show the resultant behavior。</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Blocks/Articles/00_Introduction.html#//apple_ref/doc/uid/TP40007502-CH1-SW1">Blocks Programming Topics</a></li><li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html">Programming with Objective-C : Working with Blocks</a></li><li><a href="https://clang.llvm.org/docs/AutomaticReferenceCounting.html">Clang 7 documentation : Objective-C Automatic Reference Counting (ARC)</a></li><li><a href="https://www.mikeash.com/pyblog/friday-qa-2010-01-15-stack-and-heap-objects-in-objective-c.html">Friday Q&amp;A 2010-01-15: Stack and Heap Objects in Objective-C</a></li><li><a href="https://www.amazon.cn/dp/B00DE60G3S/ref=sr_1_1?ie=UTF8&qid=1521383632&sr=8-1&keywords=Objective-C+%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B">Objective-C高级编程:iOS与OS X多线程和内存管理</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在面试的时候，我们会碰到 &lt;code&gt;Block&lt;/code&gt; 相关的问题：&lt;strong&gt;MRC 下为什么要用 copy 修饰? 为什么 ARC 下就不要这样处理呢？&lt;/strong&gt;，所以打算把堆栈的内容和 &lt;code&gt;Block&lt;/code&gt; 一起讲解。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="内存管理" scheme="http://example.com/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
      <category term="block" scheme="http://example.com/tags/block/"/>
    
  </entry>
  
  <entry>
    <title>内存优化</title>
    <link href="http://example.com/2018/03/17/Memory-optimization/"/>
    <id>http://example.com/2018/03/17/Memory-optimization/</id>
    <published>2018-03-17T13:21:40.000Z</published>
    <updated>2021-01-22T14:55:23.846Z</updated>
    
    <content type="html"><![CDATA[<p>**转载请注明出处！<a href="http://joakimliu.github.io/2018/03/17/Memory-optimization/">http://joakimliu.github.io/2018/03/17/Memory-optimization/</a> 谢谢！ **</p><p>使用了大量内存会降低性能。所以内存优化对于注重用户体验的 App 来说是比较重要的，本文讲讲内存优化中需要注意的点。</p><a id="more"></a><h2 id="提高内存相关性能的建议"><a href="#提高内存相关性能的建议" class="headerlink" title="提高内存相关性能的建议"></a>提高内存相关性能的建议</h2><ul><li><strong>延时创建</strong>      每个内存的创建都会有性能消耗，但是你又不得不申请创建内存，延时到你真正需要它的时候再去创建一个好方法。比如，为了避免启动程序变慢，我们可以将减少启动时的内存创建，只创建首先展示给用户看的相关内存。譬如，我们控制器里面经常会用到懒加载，个人觉得只要某个对象是必须出现的话，就没有必要使用懒加载。</li><li><strong>创建内存高效化</strong>       使用 <em>malloc</em> 函数，不会保证内存零初始化，当然你可以用 <em>memset</em> 去将内存设置为零，更好的方法是使用 <em>calloc</em> 去初始化内存页面，它能为内存保存所需的虚拟地址空间，还能保证所需要的页面初始化为零，它更加高效。</li><li><strong>重用一些临时对象</strong>  对一些常用的或者创建比较费时的对象，可以重用它们。例如: NSDateFormatter。</li><li><strong>释放不用的内存</strong>      如果没有释放不用的内存，这会引起内存泄露，这样会使 App 不能创建所需的内存。</li></ul><h2 id="创建内存"><a href="#创建内存" class="headerlink" title="创建内存"></a>创建内存</h2><p>APP 最终会调用 malloc library 去创建内存。ARC 下，只要有一个强引用指向创建的对象，这个对象就不会被释放。如果需要创建多个，同等大小的内存块，可以用 malloc_zone_batch_malloc 函数一次性创建。还可以用内存共享啊，但是不推荐用。</p><h2 id="内存警告"><a href="#内存警告" class="headerlink" title="内存警告"></a>内存警告</h2><p>在 iOS 中，没有 backing store，而是通过强引用去释放对象。当空闲内存(free memory)下降到某个门槛时，系统会释放掉没有改变的页面，然后向应用发送低内存通知(low-memory notification)。收到通知后，我们要做一些处理，比如释放相关对象的强引用（一定要处理，否则系统可能会终止你的程序）。收到低内存通知有以下三种途径：</p><ul><li>实现 application delegate 的 <code>applicationDidReceiveMemoryWarning:</code> 方法</li><li>在自定义的 UIViewController 里面重载<code>didReceiveMemoryWarning</code> 方法</li><li>注册接受<code>UIApplicationDidReceiveMemoryWarningNotification</code> 的通知</li></ul><p>以下三种类型内存会导致内存增加后无法得到释放，得避免</p><ul><li><strong>Leaked memory</strong>  Inaccessible—no more pointers to it; Can’t ever be used again (内存泄露)</li><li><strong>Abandoned memory</strong>  Still referenced, but wasted; Won’t ever be used again (循环引用)</li><li><strong>Cached memory</strong>   Referenced and waiting; May never be used again (缓存无用内存)</li></ul><p>那怎样检测呢？当重复某个操作时，内存不应该无限制增长。例如：</p><ul><li>Pushing and popping a view controller</li><li>Scrolling in a table view</li><li>Performing a database search</li></ul><p>我们可以用 Instruments 来跟踪分析</p><p><img src="http://wx1.sinaimg.cn/mw690/005IevIrgy1fpg78dlszjj30yn0lmacl.jpg" alt="Avoiding Memory Growth"></p><h2 id="缓存和可净化的内存"><a href="#缓存和可净化的内存" class="headerlink" title="缓存和可净化的内存"></a>缓存和可净化的内存</h2><p>缓存和可净化的内存适用于那些需要大量内存或者大量时间的开发者，毕竟 IO 操作也比较费时。我们可以缓存那些很难去计算的具有临时数据的对象。当然如果内存紧张的话，还是会被移除掉的，还得重新处理。可以用 <a href="https://developer.apple.com/documentation/foundation/nscache">NSCache</a> 和 <a href="https://developer.apple.com/documentation/foundation/nspurgeabledata">NSPurgeableData</a></p><h2 id="跟踪内存的使用"><a href="#跟踪内存的使用" class="headerlink" title="跟踪内存的使用"></a>跟踪内存的使用</h2><p>用 Instruments 去跟踪分析内存的使用，大概有四种类型:</p><ul><li>The ObjectAlloc instrument records and displays a history of all memory allocations since the launch of your application.</li><li>The Leaks instrument looks for allocated memory that is no longer referenced by your program’s code; </li><li>The Shared Memory instrument monitors the opening and unlinking of shared memory regions.</li><li>The Memory Monitor instrument measures and records the system’s overall memory usage.</li></ul><p>这里贴一张在 WWDC 性能相关 session 上出现了几次的性能分析优化处理流程图。复现问题，用工具去检查，然后猜测调整测试，直到问题得以解决。</p><p><img src="http://wx3.sinaimg.cn/mw690/005IevIrgy1fpg7883i8zj30xq0jx10g.jpg" alt="Processing rules"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>由于设备的内存比较小，所以我们要尽可能的用最小的内存，在各种设备上都得测试，尤其是内存受限的设备。</li><li>用在 Instruments 跟踪的时候，在发现问题处做标记，用类名来筛选。</li><li>用 @autoreleasepool 处理大循环，并且里面处理内存数据。例如，在一万次循环里面读取图片。</li><li>循环引用，尤其是 block。</li><li>内存泄露。</li><li>给已释放的对象发消息会导致闪退<ul><li>NSNotificationCenter and KVO</li><li>与 CF 相关对象不正确的 bridge 桥接</li><li>__unsafe_unretained 引用</li><li>__autoreleasing NSError* and @autoreleasepool</li></ul></li><li>图片的读取采用正确的方式<ul><li><code>imageNamed:</code>  会缓存图片，用它读取频繁用到的小图片，最恶心的是不知道它到底什么时候释放。</li><li><code>imageWithContentsOfFile:</code>  不缓存图片，适合一次性读取的大图片。</li></ul></li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://developer.apple.com/library/content/documentation/Performance/Conceptual/ManagingMemory/ManagingMemory.html#//apple_ref/doc/uid/10000160-SW1">Memory Usage Performance Guidelines</a></li><li><a href="https://www.youtube.com/watch?v=J96ukDI90yk">WWDC 2012 Session 242 iOS App Performance Memory</a></li><li><a href="https://developer.apple.com/library/content/documentation/Performance/Conceptual/PerformanceOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40001410-CH202-SW1">Performance Overview</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;**转载请注明出处！&lt;a href=&quot;http://joakimliu.github.io/2018/03/17/Memory-optimization/&quot;&gt;http://joakimliu.github.io/2018/03/17/Memory-optimization/&lt;/a&gt; 谢谢！ **&lt;/p&gt;
&lt;p&gt;使用了大量内存会降低性能。所以内存优化对于注重用户体验的 App 来说是比较重要的，本文讲讲内存优化中需要注意的点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="内存管理" scheme="http://example.com/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
      <category term="性能优化" scheme="http://example.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>虚拟内存</title>
    <link href="http://example.com/2018/03/16/Virtual-Memory/"/>
    <id>http://example.com/2018/03/16/Virtual-Memory/</id>
    <published>2018-03-16T15:11:45.000Z</published>
    <updated>2021-01-22T14:55:23.850Z</updated>
    
    <content type="html"><![CDATA[<p>**转载请注明出处！<a href="http://joakimliu.github.io/2018/03/16/Virtual-Memory/">http://joakimliu.github.io/2018/03/16/Virtual-Memory/</a> 谢谢！ **</p><h1 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h1><p>应用程序需要一个简单的执行环境(<strong>地址空间+CPU</strong>)，地址空间我们可以把它想象成一个很大的数组，每个数组的元素就是一个字节，这个数组大小由地址空间的长度决定。比如 32 位的地址空间大小为 2^32 byte = 2^22 KB = 2^12 MB = 2^2 GB = 4BG，用16进制表示就是 0x00000000~0xFFFFFFFF，32位 iPhone 机型里面的应用地址空间如下图所示。地址空间分为两种：虚拟地址空间（Virtual Address Space）和物理地址空间（Physical Address Space）。物理地址空间是实实在在存在的，可以把它理解为物理内存，如 32 位的机器，它的物理空间就是 4GB。而虚拟地址空间是虚拟的，人们想象出来的，它并不存在。</p><a id="more"></a><p><img src="http://wx4.sinaimg.cn/mw690/005IevIrly1fpfvwks2ckj30rf0fndh1.jpg" alt="Address Space Fundamentals"></p><p>如果程序直接运行在物理空间上会怎样呢？假设我们的计算机有 128M 内存，有三个程序A、B、C，其中 A 需要 10M，B 需要 100MB，C 需要 20MB。如果同时运行程序 A 和 B，那么比较直接的做法就是将内存前 10M 分给程序 A，接着把 10MB~110MB 分给程序 B。但是这样有以下问题：</p><ul><li><strong>地址空间不隔离</strong>     所有程序都直接访问物理地址，它们所使用的内存空间不是相互隔离的。其他恶意的程序可以轻易的修改破坏其他程序的内存数据。</li><li><strong>内存使用率低</strong>    没有有效的内存管理机制，通常要执行一个程序时，就将整个程序装入内存然后开始执行。上面那个例子，如果我要执行程序 C，那么就得把其他程序的数据先写到磁盘中，等要用的时候再读回来。由于程序所需要的空间是连续的，所以这里只能将程序 B 换出到磁盘。大量的数据换入换出，导致效率十分低下。</li><li><strong>运行的地址不确定</strong>   程序每次需要装入运行时，我们都需要给它从内存中分配一块足够大的空间区域，而这块空间区域的位置是不确定的。</li><li><strong>避开物理地址空间的限制</strong>   如果我们要同时运行程序 ABC 呢。</li></ul><p>按照计算机领域的名言 <strong>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决</strong>。所以我们这里可以增加一个中间层：虚拟内存地址。但是这样，内存使用率低的问题还没处理。根据程序的局部性原理，当一个程序运行时，在某个时间段，它只是频繁的用到了一小部分数据。所以我们就采取更小粒度的内存分割和映射方案：分页（paging）。即将物理空间地址等分成固定大小的页，每一页的大小由硬件决定，在 iOS 中，每页是 4KB。我们提到了两个概念：虚拟内存地址和分页。还有其他的陌生概念等着我们去了解。</p><h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><p>虚拟内存允许一个操作系统避开物理内存(4GB)的限制。虚拟内存为每个进程创建了一个逻辑地址空间（也可以理解为虚拟地址空间），它将逻辑地址空间划分成同等大小的内存块，被称为 pages 。处理器和它的内存管理单元(memory management unit (MMU))维持一个 page table 表(从程序的逻辑内存映射到电脑的RAM硬件内存)。当程序代码访问内存地址的时候，MMU 用 page table 将逻辑内存转化为实际的硬件内存，这个过程对于运行的程序是自动并且透明的。</p><p><img src="http://wx3.sinaimg.cn/mw690/005IevIrly1fpfvwd832hj30te0hfacb.jpg" alt="Virtual Memory"></p><p>从 WWDC2012 session 242 里的这张虚拟内存图，我们可以看出其他几个概念：region、VM Object、Resident Memory、Free Memory、Heap。我们一个一个来了解（Heap 下次讲解）。</p><h2 id="page"><a href="#page" class="headerlink" title="page"></a>page</h2><p>逻辑内存地址一直有效，如果一个程序访问的逻辑内存地址没有相对应的物理地址时，page fault 就会发生。当它发生时，虚拟内存系统马上会调用一个特殊的 page-fault handler 处理器去响应它。page-fault handler 会停止当前代码的运行，在物理内存中找到 free page，然后从磁盘中加载包含所需数据的这个 page，并且马上返回去控制程序的代码，这样就能正常的获取内存地址了，这个过程就叫 paging。当然很有可能物理内存中没有可用的 free pages，那么 page-fault handler 会马上释放一个存在的 page，给新的 page 腾出空间。当然系统怎样释放 pages 取决于平台。在 OS X 中，虚拟内存系统经常将 pages 写入 backing store（可以理解为文件交换，它就是一个进程里，用磁盘作为的一个仓库，里面存储的是内存 page 的拷贝）。将数据从物理内存移到 backing store，称为 paging in (or “swapping in”)；反之将数据从 backing store 移到物理内存，称为 paging in (or “swapping in”)。但是 iOS 中是没有 backing store 的，所以不存在 paging out。下面详细讲解 paging in out。</p><h2 id="region"><a href="#region" class="headerlink" title="region"></a>region</h2><p>一个进程的逻辑地址空间由内存的映射区域（region）组成。 每个映射内存区域包含多个虚拟内存页（page）。每个区域有特殊的属性控制，如继承，写保护，是否联动（wired）等。由于区域包含很多页，它们是页对齐的，意味着区域的起始地址也是一个页的起始地址，结束地址也是一样的。</p><h2 id="VM-Object"><a href="#VM-Object" class="headerlink" title="VM Object"></a>VM Object</h2><p>内核用一个 VM 对象与逻辑地址空间的每个区域关联起来。内核用 VM 对象去跟踪和管理相关区域的居住（resident）和不居住（nonresident）的页（page）。区域能够在文件系统里面映射到 backing store 的一部分或者 memory-mapped 文件。每个 VM 对象包含一个用 the default pager 或者 the vnode pager 关联区域的 map。这跟前面的映射一一对应， the default pager 对应 backing store，the vnode pager 对应 memory-mapped 文件。除了映射区域到 default 或者 vnode pager，一个 VM 对象也映射区域到另一个 VM 对象。 内核用这个自己引用计数去实现 copy-on-write 区域。copy-on-write 区域允许多个不同的进程去共享一个页，只要它们没有写数据到这个页。当一个进程打算向这个页进行写操作时，当它写的时候，这个页的拷贝在这个进程的逻辑地址空间就被创建了。copy-on-write 区域常用于从系统框架里面加载页。读写锁也是这个原理。</p><h2 id="Resident-Memory"><a href="#Resident-Memory" class="headerlink" title="Resident Memory"></a>Resident Memory</h2><p>也叫联动（wired）内存，它存储内核的代码和数据结构，不能发生 page out 行为。应用，框架以及其他用户级别的软件不能创建联动内存，但是它们能够影响任何时候已经存在的联动内存。</p><h2 id="Free-Memory"><a href="#Free-Memory" class="headerlink" title="Free Memory"></a>Free Memory</h2><p>顾名思义，就是没有被占用，随时可以拿来用的内存。</p><h2 id="Clean-memory"><a href="#Clean-memory" class="headerlink" title="Clean memory"></a>Clean memory</h2><p>在磁盘中有备份的，能够再次读取。包括：</p><ul><li>system framework</li><li>binary executable of your app</li><li>memory mapped files</li></ul><h2 id="Dirty-memory"><a href="#Dirty-memory" class="headerlink" title="Dirty memory"></a>Dirty memory</h2><p>所有非 clean memory 都是的，它不能被系统回收，包括</p><ul><li>Heap allocations</li><li>decompressed images</li><li>database caches</li></ul><p>在 iOS 中发生内存警告时，我们要在相关警告方法里面处理这些内存，不然应用会被系统杀掉的。</p><h1 id="Page-Lists"><a href="#Page-Lists" class="headerlink" title="Page Lists"></a>Page Lists</h1><p>内核维持和查询三种物理内存页面系统级别的数组</p><ul><li>The active list contains pages that are currently mapped into memory and have been recently accessed.</li><li>The inactive list contains pages that are currently resident in physical memory but have not been accessed recently. These pages contain valid data but may be removed from memory at any time.</li><li>The free list contains pages of physical memory that are not associated with any address space of VM object. These pages are available for immediate use by any process that needs them.</li></ul><p>这三种是相互影响的，例如</p><ul><li>当 free list 低于一定阈值时，它会从 inactive list 里面拉去一些页过来；</li><li>当一个页被访问时，它会被放到 active list 的后面；</li><li>当 inactive 页的数据最近没有写入到 backing store，在它可以放在 active list 里面之前，它必须 page out 到磁盘；</li></ul><h1 id="Paging-Out-Process"><a href="#Paging-Out-Process" class="headerlink" title="Paging Out Process"></a>Paging Out Process</h1><p>当 free list 里面的页面数量低于一定阈值时，内核会通过将 inactive pages 从内存中移除，增加 free list 数量，此时会发生 page out 行为（而 iOS 中是没有这种行为的，直接就是内存警告）。相关步骤如下</p><ul><li>If a page in the active list is not recently touched, it is moved to the inactive list.</li><li>If a page in the inactive list is not recently touched, the kernel finds the page’s VM object.</li><li>If the VM object has never been paged before, the kernel calls an initialization routine that creates and assigns a default pager object.</li><li>The VM object’s default pager attempts to write the page out to the backing store.</li><li>If the pager succeeds, the kernel frees the physical memory occupied by the page and moves the page from the inactive to the free list.</li></ul><h1 id="Paging-In-Process"><a href="#Paging-In-Process" class="headerlink" title="Paging In Process"></a>Paging In Process</h1><p>当获取的虚拟内存没有映射到物理内存时，就会出现错误，包括两种：</p><ul><li>A soft fault occurs when the page of the referenced address is resident in physical memory but is currently not mapped into the address space of this process.</li><li>A hard fault occurs when the page of the referenced address is not in physical memory but is swapped out to backing store (or is available from a mapped file). This is what is typically known as a page fault.</li></ul><p>而我们上面所说的 paging，就是 hard fault。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们对虚拟内存空间有了一点的理解，但是里面有各种内存，现在对它们做个总结。</p><ul><li><strong>free</strong> 空闲内存，随时都可以用的，当这个内存降到了一定阈值，系统内核会进行一些操作，例如从 inactive 拉取一些页过来，发生 page out；</li><li><strong>inactive</strong> 不活跃的内存，但可被分页；</li><li><strong>active</strong> 活跃的内存，已使用的内存，但是可被分页；</li><li><strong>wire(resident)</strong> 已使用的内存，且不可被分页的，不能发生 page out；</li><li><strong>clean</strong> 在磁盘中有备份的，能够再次读取；</li><li><strong>dirty</strong> 所有非 clean memory 都是的，它不能被系统回收，我们创建在堆上的大部分内存都属于这种。</li></ul><p>它们之间的关系为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">virtual memory &#x3D; clean memory + dirty memory + free memory(下面 stackoverflow 的链接没有包括它，但从 WWDC 2012 Session 242 的 PDF 上看，应该是包括的，见下图)</span><br><span class="line">resident memory &#x3D; dirty memory + clean memory that loaded in physical memory(如果 App 出现低内存警告了，首先想到的应该是它)</span><br></pre></td></tr></table></figure><p><img src="http://wx4.sinaimg.cn/mw690/005IevIrly1fpg00et2s8j30zr0iawgj.jpg" alt="Managing System-Wide Memory"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://developer.apple.com/library/content/documentation/Performance/Conceptual/ManagingMemory/Articles/AboutMemory.html#//apple_ref/doc/uid/20001880-BCICIHAB">About the Virtual Memory System</a></li><li><a href="https://www.youtube.com/watch?v=J96ukDI90yk">WWDC 2012 Session 242 iOS App Performance Memory</a></li><li><a href="https://stackoverflow.com/questions/13437365/what-is-resident-and-dirty-memory-of-ios">stackoverflow: What is resident and dirty memory of iOS?</a></li><li><a href="https://support.apple.com/zh-cn/HT201538">使用“活动监视器”读取系统内存并确定所使用的 RAM 容量（OS X Mountain Lion 及更低版本）</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;**转载请注明出处！&lt;a href=&quot;http://joakimliu.github.io/2018/03/16/Virtual-Memory/&quot;&gt;http://joakimliu.github.io/2018/03/16/Virtual-Memory/&lt;/a&gt; 谢谢！ **&lt;/p&gt;
&lt;h1 id=&quot;地址空间&quot;&gt;&lt;a href=&quot;#地址空间&quot; class=&quot;headerlink&quot; title=&quot;地址空间&quot;&gt;&lt;/a&gt;地址空间&lt;/h1&gt;&lt;p&gt;应用程序需要一个简单的执行环境(&lt;strong&gt;地址空间+CPU&lt;/strong&gt;)，地址空间我们可以把它想象成一个很大的数组，每个数组的元素就是一个字节，这个数组大小由地址空间的长度决定。比如 32 位的地址空间大小为 2^32 byte = 2^22 KB = 2^12 MB = 2^2 GB = 4BG，用16进制表示就是 0x00000000~0xFFFFFFFF，32位 iPhone 机型里面的应用地址空间如下图所示。地址空间分为两种：虚拟地址空间（Virtual Address Space）和物理地址空间（Physical Address Space）。物理地址空间是实实在在存在的，可以把它理解为物理内存，如 32 位的机器，它的物理空间就是 4GB。而虚拟地址空间是虚拟的，人们想象出来的，它并不存在。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="内存管理" scheme="http://example.com/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>写在被苹果被拒6次后</title>
    <link href="http://example.com/2017/09/22/%E5%86%99%E5%9C%A8%E8%A2%AB%E8%8B%B9%E6%9E%9C%E8%A2%AB%E6%8B%926%E6%AC%A1%E5%90%8E/"/>
    <id>http://example.com/2017/09/22/写在被苹果被拒6次后/</id>
    <published>2017-09-22T15:30:21.000Z</published>
    <updated>2021-01-22T14:55:23.857Z</updated>
    
    <content type="html"><![CDATA[<p>我们的 App <a href="https://itunes.apple.com/cn/app/%E9%93%B6%E7%9B%9B%E9%80%9A/id785907916?mt=8">银盛通</a> 4.1.1 版本被拒了 6 次，经历两个星期，心好累，凌晨等邮件，等电话，本文记录下审核过程，下次提交时注意。</p><a id="more"></a><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>经历过程如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">可供销售Developer2017年9月22日 上午9:07</span><br><span class="line">等待开发人员发布Apple2017年9月22日 上午1:05</span><br><span class="line">正在审核 Apple2017年9月21日 上午5:04</span><br><span class="line">正在等待审核Developer2017年9月20日 下午10:18</span><br><span class="line">准备提交Developer2017年9月20日 下午10:17</span><br><span class="line">被开发人员拒绝Developer2017年9月20日 下午4:31</span><br><span class="line">正在等待审核Developer2017年9月20日 上午11:55</span><br><span class="line">被拒绝  Apple2017年9月16日 下午11:18</span><br><span class="line">正在审核 Apple2017年9月16日 下午10:33</span><br><span class="line">正在等待审核 Developer2017年9月16日 上午10:56</span><br><span class="line">准备提交Developer2017年9月16日 上午10:42</span><br><span class="line">被拒绝 Apple 2017年9月15日 下午11:50</span><br><span class="line">正在审核 Apple 2017年9月15日 下午8:34</span><br><span class="line">正在等待审核 Developer2017年9月15日 下午3:40</span><br><span class="line">准备提交 Developer2017年9月15日 下午3:40</span><br><span class="line">被拒绝 Apple2017年9月15日 下午12:16</span><br><span class="line">正在审核 Apple 2017年9月15日 下午12:05</span><br><span class="line">正在等待审核  Developer2017年9月15日 上午11:20</span><br><span class="line">被拒绝  Apple2017年9月14日 上午12:41</span><br><span class="line">正在审核 Apple2017年9月14日 上午12:26</span><br><span class="line">正在等待审核      Developer 2017年9月13日 上午11:18</span><br><span class="line">准备提交         Developer2017年9月13日 上午11:17</span><br><span class="line">被拒绝     Apple2017年9月13日 上午3:03</span><br><span class="line">正在审核 Apple2017年9月12日 下午11:21</span><br><span class="line">正在等待审核 Developer2017年9月11日 上午11:28</span><br><span class="line">准备提交 Developer2017年9月11日 上午11:27</span><br><span class="line">被拒绝 Apple2017年9月11日 上午1:35</span><br><span class="line">正在审核 Apple2017年9月11日 上午12:45</span><br><span class="line">正在等待审核 Developer2017年9月8日  下午5:32</span><br></pre></td></tr></table></figure><h2 id="第一杀"><a href="#第一杀" class="headerlink" title="第一杀"></a>第一杀</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PLA 1.2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">The seller and company names associated with your app do not reflect the multiple credit card applications in the app or its metadata, as required by section 1.2 of the Apple Developer Program License Agreement.</span><br><span class="line"></span><br><span class="line">Next Steps</span><br><span class="line"></span><br><span class="line">Your app must be published under a seller name and company name that reflects the credit card applications. If you have developed this app on behalf of a client, please advise your client to add you to the development team of their Apple Developer account.</span><br><span class="line"></span><br><span class="line">Once created, you cannot change your seller name or company name in iTunes Connect. For assistance with changing your company name or seller name, you will need to contact iTunes Connect through the Contact Us page. Select Getting Started from the first dropdown menu, then select General iTunes Connect Inquiry to contact the appropriate iTunes Connect team.</span><br></pre></td></tr></table></figure><p>还有三张关于信用卡的截图。这是因为我们有申请信用卡的内置 webView。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>后台把相关的网页屏蔽掉。</p><h2 id="第二杀"><a href="#第二杀" class="headerlink" title="第二杀"></a>第二杀</h2><h3 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Guideline 3.1.1 - Business - Payments - In-App Purchase</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">We noticed that your app uses in-app purchase products to purchase credits or currencies that are not consumed within the app, which is not appropriate for the App Store.</span><br><span class="line"></span><br><span class="line">Please see attached screenshots for details.</span><br><span class="line"></span><br><span class="line">Next Steps</span><br><span class="line"></span><br><span class="line">To resolve this issue, please revise your app to ensure that the credits or currencies purchased with in-app purchase products are used within the app or remove the in-app purchases entirely.</span><br><span class="line"></span><br><span class="line">Request a phone call from App Review</span><br><span class="line"></span><br><span class="line">At your request, we can arrange for an Apple Representative to call you within the next three to five business days to discuss your App Review issue.</span><br><span class="line"></span><br><span class="line">To request a call and ensure we have accurate contact information, reply directly to this message with a contact name and direct phone number to reach you.</span><br><span class="line"></span><br><span class="line">PLA 1.2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">The seller and company names associated with your app do not reflect names of financial institutions in the app or its metadata, as required by section 1.2 of the Apple Developer Program License Agreement.</span><br><span class="line"></span><br><span class="line">Next Steps</span><br><span class="line"></span><br><span class="line">Your app must be published under a seller name and company name that reflects names of financial institutions. If you have developed this app on behalf of a client, please advise your client to add you to the development team of their Apple Developer account.</span><br><span class="line"></span><br><span class="line">Once created, you cannot change your seller name or company name in iTunes Connect. For assistance with changing your company name or seller name, you will need to contact iTunes Connect through the Contact Us page. Select Getting Started from the first dropdown menu, then select General iTunes Connect Inquiry to contact the appropriate iTunes Connect team.</span><br></pre></td></tr></table></figure><ul><li>因为我们的 App 里面有 Q 币充值的功能，被 Apple 认为是内购。</li><li>我们有个信用卡还款的功能，页面上方还有申请信用卡的入口。</li></ul><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>WTF？Q 币充值竟然是内购，好吧，把这个增值业务的功能入口隐藏掉。把信用卡还款上方的入口隐藏掉。</p><h2 id="第三杀"><a href="#第三杀" class="headerlink" title="第三杀"></a>第三杀</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Guideline 2.3.3 - Performance - Accurate Metadata</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">We noticed that your screenshots do not sufficiently reflect your app in use.</span><br><span class="line"></span><br><span class="line">Please see attached screenshots for details.</span><br><span class="line"></span><br><span class="line">Next Steps</span><br><span class="line"></span><br><span class="line">To resolve this issue, please revise your screenshots to ensure that they accurately reflect the app in use. For resources on creating great screenshots for the App Store, you may want to review the App Store Product Page information available on the Apple developer portal.</span><br><span class="line"></span><br><span class="line">Please ensure you have made any screenshot modifications using Media Manager. You should confirm your app looks and behaves identically in all languages and on all supported devices. Learn how to use Media Manager to add custom screenshots for each display size and localization.</span><br><span class="line"></span><br><span class="line">Since your iTunes Connect status is Rejected, a new binary will be required. Make the desired metadata changes when you upload the new binary.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PLA 1.2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">The seller and company names associated with your app do not reflect the name of financial institutions in the app or its metadata, as required by section 1.2 of the Apple Developer Program License Agreement.</span><br><span class="line"></span><br><span class="line">Next Steps</span><br><span class="line"></span><br><span class="line">Your app must be published under a seller name and company name that reflects the name of financial institutions. If you have developed this app on behalf of a client, please advise your client to add you to the development team of their Apple Developer account.</span><br><span class="line"></span><br><span class="line">Once created, you cannot change your seller name or company name in iTunes Connect. For assistance with changing your company name or seller name, you will need to contact iTunes Connect through the Contact Us page. Select Getting Started from the first dropdown menu, then select General iTunes Connect Inquiry to contact the appropriate iTunes Connect team.</span><br></pre></td></tr></table></figure><h3 id="原因-2"><a href="#原因-2" class="headerlink" title="原因"></a>原因</h3><ul><li>说我们上传到 App Store 的媒体图片首页跟 App 里面的不同。</li><li>说我们这次新增的理财业务跟我们公司没关系。</li></ul><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>对于这两个问题，我是有疑问的，然后向苹果爸爸发邮件咨询，说明情况。</p><ul><li>因为我们首页八宫格的功能入口是后台返回的。</li><li>因为这次新增的理财功能是我们集团公司的另外一个子公司提供的，而我们的账号不在集团公司名下。</li></ul><p>重新提交，并申请加急处理。</p><p>苹果那边回复了</p><ul><li>关于<code>Guideline 2.3.3</code>，这次截图确是我们八宫格编辑界面，说与上传到 App Store 的媒体图片不相符。  这。。。我服了，反正能找到原因弄死你，这个我们改。</li><li>关于<code>PLA 1.2</code>，说我们的账号只能放在集团公司名下才能销售。 对于这一点，以我们目前的情况不太可能，因为我们还要去申请 DUNS 邓白氏编码、重新申请一个开发者账号、将 App 转到集团公司开发者名下。于是再次向苹果说明情况，看能不能提供相关文件证明我们开发者所在的公司跟集团公司的关系。苹果说回复可以，结果他们添加附件的功能死活用不了，后面经过沟通后，我就把相关资料放在 Dropbox 上，然后将链接告诉苹果那边。</li></ul><h2 id="第四杀"><a href="#第四杀" class="headerlink" title="第四杀"></a>第四杀</h2><p>我们将相关资料发送给苹果后，再次提交审核。这次审核很快，差不多1个小时左右（这次中国团队审核的，因为截图的时间跟我们的时间一致），上午11点左右提交，中午12点钟被拒。</p><h3 id="原因-3"><a href="#原因-3" class="headerlink" title="原因"></a>原因</h3><ul><li>XMPP 连接时 IPV6 被拒。这个去年强制 IPV6 时，苹果没测到么？？？</li><li>我们上传到 App Store 的媒体图片首页跟 App 里面的不同。细节扣得很死。</li></ul><h3 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>IPV6 解决方案 <a href="https://github.com/robbiehanson/XMPPFramework/issues/718">XMPP socket fails to connect when connected to a IPv6 only network</a>。</li><li>继续调整首页八宫格的 App Store 媒体图片。</li></ul><h2 id="第五杀"><a href="#第五杀" class="headerlink" title="第五杀"></a>第五杀</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PLA 1.2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">The seller and company names associated with your app do not reflect the financial institute in the app or its metadata, as required by section 1.2 of the Apple Developer Program License Agreement.</span><br><span class="line"></span><br><span class="line">Next Steps</span><br><span class="line"></span><br><span class="line">Your app must be published under a seller name and company name that reflects the financial institution name. If you have developed this app on behalf of a client, please advise your client to add you to the development team of their Apple Developer account.</span><br><span class="line"></span><br><span class="line">Once created, you cannot change your seller name or company name in iTunes Connect. For assistance with changing your company name or seller name, you will need to contact iTunes Connect through the Contact Us page. Select Getting Started from the first dropdown menu, then select General iTunes Connect Inquiry to contact the appropriate iTunes Connect team.</span><br></pre></td></tr></table></figure><h3 id="原因-4"><a href="#原因-4" class="headerlink" title="原因"></a>原因</h3><p>这次给的截图又是首页理财 tabbar。WTF？这个我们上次提交了公司相关资料啊，于是向苹果争论。结果给的原因却是，因为我们新版本的开机引导页最后一张是介绍信用卡申请的。</p><h3 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h3><p>还好周六我们的设计师欧巴在公司加班，于是让他帮忙处理，提交审核。</p><h2 id="第六杀"><a href="#第六杀" class="headerlink" title="第六杀"></a>第六杀</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PLA 1.2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">The seller and company names associated with your app still do not reflect the name of the financial institutions in the app or its metadata, as required by section 1.2 of the Apple Developer Program License Agreement.</span><br><span class="line"></span><br><span class="line">Next Steps</span><br><span class="line"></span><br><span class="line">Your app must be published under a seller name and company name that reflects the financial institution’s name. If you have developed this app on behalf of a client, please advise your client to add you to the development team of their Apple Developer account.</span><br><span class="line"></span><br><span class="line">Once created, you cannot change your seller name or company name in iTunes Connect. For assistance with changing your company name or seller name, you will need to contact iTunes Connect through the Contact Us page. Select Getting Started from the first dropdown menu, then select General iTunes Connect Inquiry to contact the appropriate iTunes Connect team.</span><br></pre></td></tr></table></figure><h3 id="原因-5"><a href="#原因-5" class="headerlink" title="原因"></a>原因</h3><p>又是 PLA 1.2，继续向苹果那边咨询，结果苹果那边没给截图直接甩了一封邮件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Hello,</span><br><span class="line"></span><br><span class="line">We appreciate your feedback and have scheduled a call with an Apple representative in order to discuss your concerns. We anticipate calling within 3 business days.</span><br><span class="line"></span><br><span class="line">To help ensure we have the correct contact information, please reply to this message to provide a contact name and phone number for this call.</span><br><span class="line"></span><br><span class="line">Best regards,</span><br><span class="line"></span><br><span class="line">App Store Review</span><br></pre></td></tr></table></figure><h3 id="解决方案-5"><a href="#解决方案-5" class="headerlink" title="解决方案"></a>解决方案</h3><p>于是按照苹果爸爸的要求提交了相关信息，周二早餐 7:10 左右，美国那边打电话（电话号码是<code>+1 (408)996-1010</code>，圣何塞，加利福尼亚州，美国）来了，那个时候我在刷牙，去客厅一看，响一声就挂了，然后把手机放在口袋继续刷牙，结果又打来了，这次拿起手机刚好要去接的时候，那边又挂了。我当时。。。。。。 然后收到了一封邮件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">I&#39;m writing to let you know that I tried to reach you at +86 xxx-xxxx-xxxx to discuss your app, but have been unsuccessful. </span><br><span class="line"></span><br><span class="line">Please provide a telephone number and time that you can be reached at so that we may attempt to contact you again.  Once I receive your phone number, I will contact you at my next available opportunity. </span><br><span class="line"></span><br><span class="line">While I may not be able to call you immediately upon receipt of your email, I will get back to you as quickly as I can. </span><br></pre></td></tr></table></figure><p>8点左右才看到邮件，赶紧提供提供另外一个电话回复邮件，并且说明希望那边再次联系的时候能够多打几次，并且通知我英语口语好的领导，让他回个电话，结果没法联系到苹果审核团队那边。</p><p>终于在周三上午接到了那个电话，告诉我是因为我们的版本更新描述以及App介绍里面提到了信用卡！！！！！！接完电话，苹果那边又发了封邮件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Thank you for your time during our call today. </span><br><span class="line"></span><br><span class="line">As we discussed, your app was found to be out of compliance with App Store Review Guidelines. </span><br><span class="line"></span><br><span class="line">PLA 1.2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">The seller and company names associated with your app still do not reflect the name of the financial institutions in the app or its metadata, as required by section 1.2 of the Apple Developer Program License Agreement.</span><br><span class="line"></span><br><span class="line">Next Steps</span><br><span class="line"></span><br><span class="line">Your app must be published under a seller name and company name that reflects the financial institution’s name. If you have developed this app on behalf of a client, please advise your client to add you to the development team of their Apple Developer account.</span><br><span class="line"></span><br><span class="line">Once created, you cannot change your seller name or company name in iTunes Connect. For assistance with changing your company name or seller name, you will need to contact iTunes Connect through the Contact Us page. Select Getting Started from the first dropdown menu, then select General iTunes Connect Inquiry to contact the appropriate iTunes Connect team.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">We hope you will consider making the appropriate revisions to your app and resubmit. </span><br><span class="line"></span><br><span class="line">If you feel that this rejection was made in error, and believe your app is in compliance with the App Store Review Guidelines, you may submit an appeal to the App Review Board. Once the App Review Board has completed their evaluation, they will contact you directly with the decision.</span><br><span class="line"></span><br><span class="line">If you have any questions about this information, please reply to this message via Resolution Center on iTunes Connect. If you would like to discuss the review findings in more detail, please reply to this message via Resolution Center on iTunes Connect or feel free to contact me at +1 (669)-227-5527 between 11am - 8pm Pacific Daylight Time.</span><br><span class="line"></span><br><span class="line">Thank you</span><br></pre></td></tr></table></figure><p>上面提到了一个电话<code>+1 (669)-227-5527</code>，没打过，下次遇到了问题可以试一下。这次晚上10点半左右提交，然后第三天凌晨就审核通过了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>流水账似的把整个过程描述了下，总结以下几点</p><ul><li>仔细看<a href="https://developer.apple.com/app-store/review/guidelines/cn/">App Store 审核指南</a>，不过有些问题还是得看人品了，因为苹果爸爸说的就是对的！有几次明明被拒原因的截图给的是A，向苹果询问后，苹果又给的截图是B，想弄你，理由总是有的。</li><li>金融类 App 千万别牵涉到信用卡相关业务，除非你就是本银行的 App。</li><li>有啥问题向苹果申诉，网上的东西经验仅供参考，官方解释才是王道，这次 PLA 1.2 的相关问题，看网上的说苹果审核团队电话回访后，也没啥用，只能更换开发者账号所在的公司，这个我也咨询过中国苹果开发者技术支持，说是要到更换两个公司的 DUNS，或者转让App，不过挺麻烦的。</li><li>对于审核这块，中国苹果开发者技术支持（电话：<code>400-670-1855</code>）的作用不是很大。</li><li>App Store 的媒体图片和提交的 App 页面元素最好差不多。</li><li>我这次提供给苹果审核团队的电话，第一次是中国移动手机号码，出现了上面响了一声对方就挂了的情况，换个中国电话手机号码后，我是响了两下才接的，这个不知道有没有影响，不然我们的 App 上架至少可以提前一天。</li><li>审核加急作用于整个版本，直至提交成功。</li></ul><p>审核的时候，人品成分比较大（因为我们上个版本的 App Store 的媒体图片，版本描述和 App 描述里面也提到了信用卡，然而没什么印象），把之前被拒的原因都记录下来，下次绝不犯类似的错误！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们的 App &lt;a href=&quot;https://itunes.apple.com/cn/app/%E9%93%B6%E7%9B%9B%E9%80%9A/id785907916?mt=8&quot;&gt;银盛通&lt;/a&gt; 4.1.1 版本被拒了 6 次，经历两个星期，心好累，凌晨等邮件，等电话，本文记录下审核过程，下次提交时注意。&lt;/p&gt;
    
    </summary>
    
      <category term="经验分享" scheme="http://example.com/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Apple 审核" scheme="http://example.com/tags/Apple-%E5%AE%A1%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 Diffie-Hellman 密钥交换</title>
    <link href="http://example.com/2017/08/17/%E6%B5%85%E8%B0%88-Diffie-Hellman-%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2/"/>
    <id>http://example.com/2017/08/17/浅谈-Diffie-Hellman-密钥交换/</id>
    <published>2017-08-17T15:06:30.000Z</published>
    <updated>2021-01-20T14:51:29.673Z</updated>
    
    <content type="html"><![CDATA[<p>之前在讲密钥配送的时候，有提到 Diffie-Hellman 密钥交换，今天来简单的谈谈它。 Diffie-Hellman 密钥交换(Diffie-Hellman key exchange)通信双方仅通过交换一些可以公开的信息就能够生成共享的数字，而这一秘密数字就可以被用作对称密码的密钥。下面先来讲讲它的步骤。</p><a id="more"></a><ul><li>Alice 向 Bob 发送两个质数 P 和 G<br> P 必须是一个非常大的质数，而 G 则是和 P 相关的数，被称为生成元，而 G 可以是一个很小的数。 P 和 G不需要保密。</li><li>Alice 生成一个随机数 A<br> A 是一个<code>1 ~ P-2</code>之间的整数，它只能是 Alice 自己知道的密码数字。</li><li>Bob 生成一个随机数 B<br> 同样的，B 是一个<code>1 ~ P-2</code>之间的整数，它只能是 Bob 自己知道的密码数字。</li><li>Alice 将 G^A mod P 这个数发送给 Bob<br>  这个数被 Eve 知道也没关系。</li><li>Bob 将 G^B mod P 这个数发送给 Alice<br>  这个数被 Eve 知道也没关系。</li><li>Alice 用 Bob 发过来的数计算 A 次方 并求 mod P<br>  即<code>(G^B mod P)^A mode P</code>，这个数就是共享密钥，可以将它简化为：<code>G^(A*B) mod P</code></li><li>Bob 用 Alice 发过来的数计算 B 次方 并求 mod P<br>  即<code>(G^A mod P)^B mode P</code>，这个数就是共享密钥，可以将它简化为：<code>G^(A*B) mod P</code></li></ul><p>我们可以发现：<code>Alice 计算的密钥 = Bob 计算的密钥</code>。 那么问题来了，Eve 能够计算出密钥么？从上面的步骤来看， Eve 知道<code>P、G、G^A mod P、G^B mod P</code>这 4 个数，而根据这 4 个数计算出共享秘钥 <code>G^(A*B) mod P</code> 是非常困难的，这个又是离散对数的问题了。</p><p>还是上篇博文《浅谈 RSA》说的时钟问题。我们假设 P 为 13，而 mod P 的时钟运算中所使用的数就是：<code>0,1,2...12</code>。我们看看下面 G^A mod P 表格（P = 13）。</p><table><thead><tr><th>G  /  A</th><th align="right">1</th><th align="right">2</th><th align="right">3</th><th align="right">4</th><th align="right">5</th><th align="right">6</th><th align="right">7</th><th align="right">8</th><th align="right">9</th><th align="right">10</th><th align="right">11</th><th align="right">12</th></tr></thead><tbody><tr><td>0</td><td align="right">0</td><td align="right">0</td><td align="right">0</td><td align="right">0</td><td align="right">0</td><td align="right">0</td><td align="right">0</td><td align="right">0</td><td align="right">0</td><td align="right">0</td><td align="right">0</td><td align="right">0</td></tr><tr><td>1</td><td align="right">1</td><td align="right">1</td><td align="right">1</td><td align="right">1</td><td align="right">1</td><td align="right">1</td><td align="right">1</td><td align="right">1</td><td align="right">1</td><td align="right">1</td><td align="right">1</td><td align="right">1</td></tr><tr><td>2</td><td align="right">2</td><td align="right">4</td><td align="right">8</td><td align="right">3</td><td align="right">6</td><td align="right">12</td><td align="right">11</td><td align="right">9</td><td align="right">5</td><td align="right">10</td><td align="right">7</td><td align="right">1</td></tr><tr><td>3</td><td align="right">3</td><td align="right">9</td><td align="right">1</td><td align="right">3</td><td align="right">9</td><td align="right">1</td><td align="right">3</td><td align="right">9</td><td align="right">1</td><td align="right">3</td><td align="right">9</td><td align="right">1</td></tr><tr><td>4</td><td align="right">4</td><td align="right">3</td><td align="right">12</td><td align="right">9</td><td align="right">10</td><td align="right">1</td><td align="right">4</td><td align="right">3</td><td align="right">12</td><td align="right">9</td><td align="right">10</td><td align="right">1</td></tr><tr><td>5</td><td align="right">5</td><td align="right">12</td><td align="right">8</td><td align="right">1</td><td align="right">5</td><td align="right">12</td><td align="right">8</td><td align="right">1</td><td align="right">5</td><td align="right">2</td><td align="right">8</td><td align="right">1</td></tr><tr><td>6</td><td align="right">6</td><td align="right">10</td><td align="right">8</td><td align="right">9</td><td align="right">2</td><td align="right">12</td><td align="right">7</td><td align="right">3</td><td align="right">5</td><td align="right">4</td><td align="right">11</td><td align="right">1</td></tr><tr><td>7</td><td align="right">7</td><td align="right">10</td><td align="right">5</td><td align="right">9</td><td align="right">11</td><td align="right">12</td><td align="right">6</td><td align="right">3</td><td align="right">8</td><td align="right">4</td><td align="right">2</td><td align="right">1</td></tr><tr><td>9</td><td align="right">8</td><td align="right">12</td><td align="right">5</td><td align="right">1</td><td align="right">8</td><td align="right">12</td><td align="right">5</td><td align="right">1</td><td align="right">8</td><td align="right">12</td><td align="right">5</td><td align="right">1</td></tr><tr><td>9</td><td align="right">9</td><td align="right">3</td><td align="right">1</td><td align="right">9</td><td align="right">3</td><td align="right">1</td><td align="right">9</td><td align="right">3</td><td align="right">1</td><td align="right">9</td><td align="right">3</td><td align="right">1</td></tr><tr><td>10</td><td align="right">10</td><td align="right">9</td><td align="right">12</td><td align="right">3</td><td align="right">4</td><td align="right">1</td><td align="right">10</td><td align="right">9</td><td align="right">12</td><td align="right">3</td><td align="right">4</td><td align="right">1</td></tr><tr><td>11</td><td align="right">11</td><td align="right">4</td><td align="right">5</td><td align="right">3</td><td align="right">7</td><td align="right">12</td><td align="right">2</td><td align="right">9</td><td align="right">8</td><td align="right">10</td><td align="right">6</td><td align="right">1</td></tr><tr><td>12</td><td align="right">12</td><td align="right">1</td><td align="right">12</td><td align="right">1</td><td align="right">12</td><td align="right">1</td><td align="right">12</td><td align="right">1</td><td align="right">12</td><td align="right">1</td><td align="right">12</td><td align="right">1</td></tr></tbody></table><p>在上表中，注意看 G 等于 2 那一行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">2^1  mod 13 &#x3D; 2</span><br><span class="line">2^2  mod 13 &#x3D; 4</span><br><span class="line">2^3  mod 13 &#x3D; 7</span><br><span class="line">2^4  mod 13 &#x3D; 3</span><br><span class="line">2^5  mod 13 &#x3D; 6</span><br><span class="line">2^6  mod 13 &#x3D; 12</span><br><span class="line">2^7  mod 13 &#x3D; 11</span><br><span class="line">2^8  mod 13 &#x3D; 9</span><br><span class="line">2^9  mod 13 &#x3D; 5</span><br><span class="line">2^10 mod 13 &#x3D; 10</span><br><span class="line">2^11 mod 13 &#x3D; 7</span><br><span class="line">2^12 mod 13 &#x3D; 1</span><br></pre></td></tr></table></figure><p>我们发现<code>2^1</code>到<code>2^12</code>这 12 个值都不一样，也就是说， 2 的乘方结果中出现了 1 到 12 的全部整数，由于 2 具备上述性质，因此称它为 13 的生成元，同样的， 6、7、11也是生成元。 P 的生成元的乘方结果与<code>1 ~ P-1</code>一一对应。正是因为这种一一对应关系， Alice 和 Bob 才能从<code>1 ~ P-2</code>中随机选择一个数字（之所以不能选择 P-1，因为<code>G^(P-1) mod P</code>的值一定是等于 1 的）。当然，从数学上看，我们还得必须证明对于任意质数 P 都一定存在生成元 G，但这个就不证明了。不得不感叹质数真的很神奇！！！</p><p>**转载请注明出处！<a href="http://joakimliu.github.io/2017/08/17/%E6%B5%85%E8%B0%88-Diffie-Hellman-%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2/">http://joakimliu.github.io/2017/08/17/浅谈-Diffie-Hellman-密钥交换/</a> 谢谢！ **</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在讲密钥配送的时候，有提到 Diffie-Hellman 密钥交换，今天来简单的谈谈它。 Diffie-Hellman 密钥交换(Diffie-Hellman key exchange)通信双方仅通过交换一些可以公开的信息就能够生成共享的数字，而这一秘密数字就可以被用作对称密码的密钥。下面先来讲讲它的步骤。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="密码" scheme="http://example.com/tags/%E5%AF%86%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 RSA</title>
    <link href="http://example.com/2017/08/17/%E6%B5%85%E8%B0%88-RSA/"/>
    <id>http://example.com/2017/08/17/浅谈-RSA/</id>
    <published>2017-08-17T14:39:17.000Z</published>
    <updated>2021-01-20T14:51:29.674Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章中讲到了密码学的相关知识，今天来简单谈谈 RSA。之前有提到过，对称密码通过将明文转换为复杂的形式来保证其机密性的，而公钥密码则是基于数学上困难的问题来保证机密性的。 RSA 就是利用了大整数的质因数分解问题的困难度。在谈它之前，我们先来谈谈时钟（只有指向小时的一根指针）运算。</p><a id="more"></a><h1 id="时钟运算"><a href="#时钟运算" class="headerlink" title="时钟运算"></a>时钟运算</h1><p>我们来想想指针的转动，运用加、减、乘、除、乘法、对数处理一下。</p><h2 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h2><p>假设现在时钟的指针指向 0，往右转一个刻度就是 1，再转一个刻度就是 2，以此类推，当转到 10、11 之后，就会回到 0，这样指针就转了整整一圈。如果现在指针指向 8，向右转动 20 个刻度是多少呢？按照常识可知，不是指向 28，而是 4，因为每隔 12 就会回到 0，所以为 4，计算方法为：<code>(8+20) / 12 = 28 / 12 = 2 余 4</code>。上面的例子就是求余数，只要求得除以 12 的余数，无论时钟转了多少刻度，我们就能算出它最终指向哪个位置。在数学中，<code>除数求余数的运算</code>有个一个运算符： mod 。 所以上面的例子可以写成：<code>28 mod 12 = 4， 28 除以 12 的余数</code>。在数学上，也称<code>28 与 4 以 12 为模同余</code>。</p><h2 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h2><p>减法可以看做是时钟向左转动。我们先规定指针不能左转，只能右转。那么<code>(8+x) mod = 0， 8 加上多少除以 12 的余数为 0 ？</code> 因为 x 只能为 <code>0,1,2...11</code>，不可能为 -7，我们将候选值一个一个的试，可以知道<code>x = 5</code>，5 这个数字，在时钟运算中和 -7 是等价的。这里我们将减法转换为加法了，<code>将指针向左转动 X 个刻度</code>和<code>将指针向右转动 Y 个刻度</code>这两个操作是等价的。</p><h2 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h2><p>乘法其实相当于加法的多次运算：<code>8 * 4 mod 12 = 32 mod 12 = 8</code>。</p><h2 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h2><p>减法是加法的逆运算，除法是乘法的逆运算。先看看：<code>7 * x mod 12 = 1</code>，我们将 <code>0,1,2...11</code> 一个一个代入 x 可知，x = 7。也就是：<code>7 * 7 mod 12 = 1</code>，也就是<code>在 mod 12 的世界中， 7 * 7 = 1，也就是 1 / 7 = 7</code>。再来看看这个算是：<code>x * y mod 12 = 1</code>，在 mod 12 的世界中， x 与 y 互为倒数。那么在 <code>0,1,2...11</code> 中，是不是每一个数都存在相对应的倒数呢？实际上，时钟运算中<code>某个数是否存在倒数</code>这个问题，与 RSA 中<code>一个公钥是否存在相对应的私钥</code>这个问题是直接相关的。我们来看看 <code>0,1,2...11</code> 中的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> 0 * x mod 12 &#x3D; 1, 不存在，不管 x 为多少都为 0。</span><br><span class="line"> 1 * x mod 12 &#x3D; 1, 不存在，注意 x 也只能为 &#96;0,1,2...11&#96; 中的数</span><br><span class="line"> 2 * x mod 12 &#x3D; 1, 不存在</span><br><span class="line"> 3 * x mod 12 &#x3D; 1, 不存在</span><br><span class="line"> 4 * x mod 12 &#x3D; 1, 不存在</span><br><span class="line"> 5 * x mod 12 &#x3D; 1, x &#x3D;  5</span><br><span class="line"> 6 * x mod 12 &#x3D; 1, 不存在</span><br><span class="line"> 7 * x mod 12 &#x3D; 1, x &#x3D;  7</span><br><span class="line"> 8 * x mod 12 &#x3D; 1, 不存在</span><br><span class="line"> 9 * x mod 12 &#x3D; 1, 不存在 </span><br><span class="line">10 * x mod 12 &#x3D; 1, 不存在</span><br><span class="line">11 * x mod 12 &#x3D; 1, x &#x3D; 11</span><br></pre></td></tr></table></figure><p>我们上面的关系，我们推断出：在 mod 12 的世界中，存在倒数的数，它们和 12 之间的最大公约数是 1。所以，某个数是否存在倒数，可以通过这个数和 12 的最大公约数是否为 1 这个条件来进行判断。和 12 的最大公约数为 1 的数（5、7、11），在数学上称为<code>和 12 互质的数</code>，也可以理解为<code>相对于 12 的质数</code>。</p><h2 id="乘方"><a href="#乘方" class="headerlink" title="乘方"></a>乘方</h2><p>指数运算。举个例子吧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">7^4 mod 12 </span><br><span class="line">&#x3D; ( 7 * 7 * 7 * 7 )mod 12 </span><br><span class="line">&#x3D; (7 * 7 mod 12) * (7 * 7 mod 12) mod 12 </span><br><span class="line">&#x3D; (49 mod 12) * (49 mod 12) mod 12 </span><br><span class="line">&#x3D; (1 * 1) mod 12 </span><br><span class="line">&#x3D; 1</span><br></pre></td></tr></table></figure><p>这里中间步骤求 mod 的方法，可以避免计算大整数的乘积，RSA 中加密和解密也是用的这种方法。</p><h2 id="对数"><a href="#对数" class="headerlink" title="对数"></a>对数</h2><p>乘法的逆运算称为对数。时钟运算中的对数称为离散对数。我们来求下：<code>7^x mod 13 = 8</code>，我们将 <code>0,1,2...12</code> 代入 x 中算一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">7^0 mod 13 &#x3D; 1</span><br><span class="line">7^1 mod 13 &#x3D; 7</span><br><span class="line">7^2 mod 13 &#x3D; 10</span><br><span class="line">7^3 mod 13 &#x3D; 5</span><br><span class="line">7^4 mod 13 &#x3D; 9</span><br><span class="line">7^5 mod 13 &#x3D; 11</span><br><span class="line">7^6 mod 13 &#x3D; 12</span><br><span class="line">7^7 mod 13 &#x3D; 6</span><br><span class="line">7^8 mod 13 &#x3D; 3</span><br><span class="line">7^9 mod 13 &#x3D; 8</span><br></pre></td></tr></table></figure><p>当数字很大时，求离散对数非常困难，也非常耗时。能快速求出离散对数的算法到现在还没发现，RSA 就是利用了这一点。 Diffie-Hellman 密钥交换协议（下篇博文会简单介绍）和 ElGamal 公钥算法中也用到了离散对数。</p><h1 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h1><p>RSA 的加密公式为：<code>密文 = 明文^E mod N</code>。解密公式为：<code>明文 = 密文^D mod N</code>。其中 E 是加密(Encryption)的首字母，D 是解密(Decryption)的首字母，N 是数字(Number)的首字母。E 和 N 的组合就是公钥，当然 E 和 N 不是什么随便的数字，它们是经过严密计算得到的。D 和 N 的组合就是私钥，加密和解密中的 N 是相同的，并且 D 也不是什么随便的数字，它和 E 有着相当紧密的关系，否则用 E 加密的结果用 D 来解密是无法实现的。</p><h2 id="生成密钥对"><a href="#生成密钥对" class="headerlink" title="生成密钥对"></a>生成密钥对</h2><p>我们只要求出 E、D 和 N 就能生成密钥对。它的步骤如下：</p><ul><li>求 N<br>  我们先得准备两个很大的质数 p 和 q。如果 p 和 q 太小的话，密码会很容易被破译，太大的话计算时间又会变得很长。例如，假设 p 和 q 都是 512 比特，它们相对于 155 为的十进制（2^512 约等于 10^155）。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">N &#x3D; p * q</span><br></pre></td></tr></table></figure></li><li>求 L（L 仅在生成密钥对的过程中使用）<br>  L 是 p-1 和 q-1 的最小公倍数(least common multiple, lcm)。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L &#x3D; lcm(p-1,q-1)</span><br></pre></td></tr></table></figure></li><li>求 E<br>  E 是一个比 1 大、比 L 小的数，此外， E 和 L 的最大公约数(greatest common divisor, gcd)必须为 1，这里是为了保证一定存在解密时需要使用的 D，之前在讲时钟运算减法的时候有提到。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt; E &lt; L</span><br><span class="line">gcd(E,L) &#x3D; 1</span><br></pre></td></tr></table></figure></li><li>求 D<br>D 需要满足以下条件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt; D &lt; L</span><br><span class="line">E * D mod L &#x3D; 1</span><br></pre></td></tr></table></figure>其中 p、q、E 都需要用伪随机数生成器生成。</li></ul><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>我们用具体的较小的数实践一下一下吧</p><ul><li>p = 17, q = 19, 两个都是质数</li><li>N = 17 * 19 = 323</li><li>L = lcm(p-1,q-1) = lcm(16,18) = 144</li><li>求 E，gcd(E,L) = 1，满足条件的有<code>5，7，11，13，17，19，23，25，29，31，...</code> 这些数称为和 L “互质的数”，也就是相对于 L 是质数，所以 25 也是可以的。我们选择 5 为 E 吧，公钥就是 (E,N)=(5,323)，它是公开的。</li><li>求 D，<code>E * D mod L = 1, 5 * 29 mod 144 = 145 mod 144 = 1</code>，那么就取 29 为 D 吧，私钥就是 (D,N)=(29,323)，它必须要妥善保管，不能告诉任何人。</li></ul><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>注意，要加密的密文必须是小于 N 的数，这是因为在加密和解密过程中都需要执行<code>mod N</code>操作，而<code>mod N</code>的结果必然小于 N，所以如果明文本身大于 N，那么解密后就无法得到正确的明文。我们就取明文为 123 吧，根据加密公式：<code>密文 = 明文^E mod N </code>。 123^5 mod 323 = 225，因此密文是 225。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x3D; ((123 mod 323) * (123 mod 323) * (123 mod 323) * (123 mod 323) * (123 mod 323)) mod 323</span><br><span class="line">&#x3D; (123 * 123 * 123 * 123 * 123) mod 322 (wtf?没有变化，再来)</span><br><span class="line">&#x3D; ((123^2 mod 323) * (123^2 mod 323) * (123 mod 323)) mod 323</span><br><span class="line">&#x3D; (271 * 271 * 123) mod 323</span><br><span class="line">&#x3D; 9033243 mode 323</span><br><span class="line">&#x3D; 225</span><br></pre></td></tr></table></figure><p>我们发现<code>123 323 271</code>都是质数，<code>质数A mod 质数B = 质数A</code>，质数真的是个有意思的东西。</p><h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><p>明文 = 密文^D mod N = 225^29 mod 323 = 123。</p><h1 id="对-RSA-的攻击"><a href="#对-RSA-的攻击" class="headerlink" title="对 RSA 的攻击"></a>对 RSA 的攻击</h1><p>任何密码总有一天会被破解的，只是时间问题而已。那来谈谈怎么破解 RSA，密码破译者知道的信息有：密文、E、N，不知道的有：明文、D、p、q、L。</p><h2 id="通过密文来求得明文"><a href="#通过密文来求得明文" class="headerlink" title="通过密文来求得明文"></a>通过密文来求得明文</h2><p>RSA 的加密过程为：<code>密文 = 明文^E mod N</code>。既然密文、E、N都知道了，那有没有一种方法能够求出密文呢？如果没有 mod N 即<code>密文 = 明文^E</code>的话，这就是个求对数的问题，难道不大。加上 mod N 后，就变成了求离散对数的问题了，这是非常困难的，目前还没发现求离散对数的高效算法。PS：至于更深入的问题讨论，不是搞数学的就没啥必要去深究了，攻城狮还有很多事情要做。</p><h2 id="通过暴力破解找出-D"><a href="#通过暴力破解找出-D" class="headerlink" title="通过暴力破解找出 D"></a>通过暴力破解找出 D</h2><p>当 D 足够长时，是不可能在现实的时间内通过暴力破解找出 D 的。现在，RSA 中所使用的 p 和 q 都是 1024 长度以上，那么 N 的长度为 2048 以上，E 和 D 的长度和 N 差不多，所以要找出 D，就需要进行 2048 以上的暴力破解(2^2048 = 10 ^x，自己算是 x 是多少吧)。</p><h2 id="通过-E-和-N-找出-D"><a href="#通过-E-和-N-找出-D" class="headerlink" title="通过 E 和 N 找出 D"></a>通过 E 和 N 找出 D</h2><p>E 和 D 的关系：<code>E * D mod L = 1</code>，而 L 为：<code>lcm(p-1,q-1)</code>，所以通过 E 计算 D 需要求出 p 和 q，所以质数 p 和 q 不能被密码破译者知道。当然密码破译者也可以通过下面的方法来求出 p 和 q。</p><ul><li>对 N 进行质因数分解。所以一旦发现了对大整数进行质因数分解的高效算法，那么 RSA 就能够被破解。而问题是现在还没发现，而且也尚未证明质因数分解是否真的是非常困难的问题，甚至也不知道是否存在一种质因数分解的简单方法。</li><li>通过推测 p 和 q 进行攻击。由于 p 和 q 是通过伪随机数生成器产生的，如果伪随机数生成器的算法很差的话，那么就有可能推测出 p 和 q 来。</li></ul><h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><p>中间人攻击(man-in-the-middle attack)，就是攻击者混入发送者和接收者之间，对发送者伪装成接收者，对接收者伪装成发送者的攻击方式。这种攻击不仅针对于 RSA ，而是可以针对任何公钥密码，这个需要证书防御。</p><h1 id="对-RSA-的-Q-amp-A"><a href="#对-RSA-的-Q-amp-A" class="headerlink" title="对 RSA 的 Q&amp;A"></a>对 RSA 的 Q&amp;A</h1><p>下面来说说关于 RSA 的一些比较重要的问题。</p><h2 id="RSA-与质数"><a href="#RSA-与质数" class="headerlink" title="RSA 与质数"></a>RSA 与质数</h2><p>Q: 越来越多的人生成 RSA 密钥对，质数会不会用光？<br>A: 这个不需要担心，来看看一组数据吧。512 比特能够容纳的质数的数量大约为 10 的 150 次方(2^512 约等于 10^150)，这个数量比整个宇宙中原子的数量还要多。我们现在来做个假设吧，如果现在地球上 100 亿人，每个人每秒中生成 100 亿个密钥对，那么经过 100 亿年会生成多少对呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 年最多 365 天，也就是 366 * 24 * 60 * 60 &#x3D; 31622400 秒</span><br><span class="line"></span><br><span class="line">100 亿人 * 100 亿个 * 31622400 秒 * 100 亿年 </span><br><span class="line">&#x3D; 31624400*(100*100000000)^3 </span><br><span class="line">&#x3D; 31624400 * (10^10)^3 </span><br><span class="line">&#x3D; 31624400 * 10^30 </span><br><span class="line">&#x3D; 3.16244 * 10^37</span><br></pre></td></tr></table></figure><p><code>3.16244 * 10^37</code> 比 <code>10^150</code> 差远了，所以不用担心，当然，质数组合偶然碰撞的可能性还是存在的，不过事实上也可以忽略咯。</p><h2 id="RSA-的长度"><a href="#RSA-的长度" class="headerlink" title="RSA 的长度"></a>RSA 的长度</h2><p>Q: 要抵御质因数分解，N 的长度需要达到多少比特？<br>A: N 无论有多长，总有一天都能够被质因数分解，现在的问题是，在现实的时间内 N 是否能够被质因数分解。当然，随着计算机性能的提高，分解的时间会进一步缩短。目前能够分解的长度为 1024 比特的整数，目前 RSA-2048（617位）的整数应该是不大可能被分解的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">计算方法为 2^RSA长度 &#x3D; 10^位</span><br><span class="line">RSA-512155</span><br><span class="line">RSA-640193</span><br><span class="line">RSA-768232</span><br><span class="line">RSA-1024309</span><br><span class="line">RSA-1536463</span><br><span class="line">RSA-2048 617</span><br></pre></td></tr></table></figure><p>这里有趣的现象叫做密码劣势：随着计算机技术的进步等，以前被认为是安全的密码会被破译。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这里只简单地讲述了 RSA 的加密功能，它可以用来数字签名，相信你会看到过<code>RSASHA1</code>吧，下次有机会再谈。</p><p>**转载请注明出处！<a href="http://joakimliu.github.io/2017/08/17/%E6%B5%85%E8%B0%88-RSA/">http://joakimliu.github.io/2017/08/17/浅谈-RSA/</a> 谢谢！ **</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章中讲到了密码学的相关知识，今天来简单谈谈 RSA。之前有提到过，对称密码通过将明文转换为复杂的形式来保证其机密性的，而公钥密码则是基于数学上困难的问题来保证机密性的。 RSA 就是利用了大整数的质因数分解问题的困难度。在谈它之前，我们先来谈谈时钟（只有指向小时的一根指针）运算。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="密码" scheme="http://example.com/tags/%E5%AF%86%E7%A0%81/"/>
    
  </entry>
  
</feed>
