<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="《程序员的自我修养–链接、装载与库》 10.2 栈与调用惯例 里面讲到了堆栈帧这块的内容，联想到同事面试时说到捕获奔溃调用栈的问题，感觉挺有意思，于是记录一下。本文主要讲解以下内容  栈帧是什么东西？ Arm64 汇编基础，Arm64 栈帧 栈帧回溯怎么玩？怎么符号化？常见的三方库又是怎么玩的？  栈《程序员的自我修养–链接、装载与库》是这么描述栈的：  栈（stack）是现代计算机程序里最为重要">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS 函数调用栈那些事">
<meta property="og:url" content="http://example.com/2022/09/30/stack/index.html">
<meta property="og:site_name" content="牛易疯先森的开发记录">
<meta property="og:description" content="《程序员的自我修养–链接、装载与库》 10.2 栈与调用惯例 里面讲到了堆栈帧这块的内容，联想到同事面试时说到捕获奔溃调用栈的问题，感觉挺有意思，于是记录一下。本文主要讲解以下内容  栈帧是什么东西？ Arm64 汇编基础，Arm64 栈帧 栈帧回溯怎么玩？怎么符号化？常见的三方库又是怎么玩的？  栈《程序员的自我修养–链接、装载与库》是这么描述栈的：  栈（stack）是现代计算机程序里最为重要">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/JoakimLiu/pic/master/stack/20220930091349.png">
<meta property="og:image" content="https://raw.githubusercontent.com/JoakimLiu/pic/master/stack/aapcs64-variadic-stack.png">
<meta property="og:image" content="https://raw.githubusercontent.com/JoakimLiu/pic/master/stack/20220930104416.png">
<meta property="og:image" content="https://raw.githubusercontent.com/JoakimLiu/pic/master/stack/20220930105031.png">
<meta property="og:image" content="https://raw.githubusercontent.com/JoakimLiu/pic/master/stack/20220930115939.png">
<meta property="article:published_time" content="2022-09-30T00:26:20.000Z">
<meta property="article:modified_time" content="2022-09-30T10:32:39.437Z">
<meta property="article:author" content="joakim.liu">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/JoakimLiu/pic/master/stack/20220930091349.png">

<link rel="canonical" href="http://example.com/2022/09/30/stack/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>iOS 函数调用栈那些事 | 牛易疯先森的开发记录</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">牛易疯先森的开发记录</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/30/stack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="joakim.liu">
      <meta itemprop="description" content="你不解决问题，就会成为问题。iOS菜逗一枚。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="牛易疯先森的开发记录">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          iOS 函数调用栈那些事
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-30 08:26:20" itemprop="dateCreated datePublished" datetime="2022-09-30T08:26:20+08:00">2022-09-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>《<a href="https://book.douban.com/subject/3652388/">程序员的自我修养–链接、装载与库</a>》 <code>10.2 栈与调用惯例</code> 里面讲到了堆栈帧这块的内容，联想到同事面试时说到捕获奔溃调用栈的问题，感觉挺有意思，于是记录一下。<br>本文主要讲解以下内容</p>
<ol>
<li>栈帧是什么东西？</li>
<li>Arm64 汇编基础，Arm64 栈帧</li>
<li>栈帧回溯怎么玩？怎么符号化？常见的三方库又是怎么玩的？</li>
</ol>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>《<a href="https://book.douban.com/subject/3652388/">程序员的自我修养–链接、装载与库</a>》是这么描述栈的：</p>
<blockquote>
<p>栈（stack）是现代计算机程序里最为重要的概念之一，几乎每一个程序都使用了栈，没有栈就没有函数，没有局部变量，也就没有我们如今能够看见的所有的计算机语言。<br>在经典的计算机科学中，栈被定义为一个特殊的容器，用户可以将数据压入栈中（入栈，push），也可以将已经压入栈中的数据弹出（出栈，pop），但栈这个容器必须遵守一条规则：先入栈的数据后出栈（First In Last Out, FIFO），多多少少像叠成一叠的书：先叠上去的书在最下面，因此要最后才能取出。<br>在计算机系统中，栈则是一个具有以上属性的动态内存区域。程序可以将数据压入栈中，也可以将数据从栈顶弹出。压栈操作使得栈增大，而弹出操作使栈减小。</p>
</blockquote>
<h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><p>栈保存了函数调用所需的信息，而这些信息称为堆栈帧（Stack Frame）或活动记录（Activate Record），包括以下内容：</p>
<ul>
<li>函数的返回地址和参数</li>
<li>临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量</li>
<li>保存的上下文：包括在函数调用前后需要保持不变的寄存器</li>
</ul>
<p><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/stack/20220930091349.png" alt="栈帧"></p>
<p>上图是 i386 中一个函数的栈帧，根据 ebp(Frame Pointer, 帧寄存器) 和 esp(Stack Pointer, 栈寄存器) 这两寄存器可以划分一个函数的堆栈。</p>
<ol>
<li>ebp 是固定的，始终指向栈底（高地址）</li>
<li>esp 始终指向栈顶（低地址），它是动态变化的</li>
<li>可以通过 ebp esp 和获取栈帧中的数据，比如，ebp+4 获取函数的返回地址</li>
</ol>
<h2 id="调用惯例"><a href="#调用惯例" class="headerlink" title="调用惯例"></a>调用惯例</h2><p>调用惯例：函数的调用方和被调用方对于函数如何调用须要有一个明确的约定。就像两个人沟通一样的，只有使用相同的语言（普通话）才能进行友好的沟通。<br>而调用惯例包括以下几方面的内容：</p>
<ol>
<li>函数参数的传递顺序和方式<ol>
<li>函数参数的传递有很多种方式，最常见的一种是通过栈传递。函数的调用方将参数压入栈中，函数自己再从栈中将参数取出。对于有多个参数的函数，调用惯例要规定函数调用方将参数压栈的顺序：是从左至右，还是从右至左。有些调用惯例还允许使用寄存器传递参数，以提高性能。</li>
</ol>
</li>
<li>栈的维护方式<ol>
<li>在函数将参数压栈之后，函数体会被调用，此后需要将被压入栈中的参数全部弹出，以使得栈在函数调用前后保持一致。这个弹出的工作可以由函数的调用方来完成，也可以由函数本身来完成。 // 如果不进行栈回退 pop 操作的话，函数调用会讲程序的栈空间用完，从而出现 stackoverflow 的错误</li>
</ol>
</li>
<li>名字修饰（Name-mangling）的策略<ol>
<li>为了链接的时候对调用惯例进行区分，调用管理要对函数本身的名字进行修饰。不同的调用惯例有不同的名字修饰策略。</li>
</ol>
</li>
</ol>
<h1 id="Arm64"><a href="#Arm64" class="headerlink" title="Arm64"></a>Arm64</h1><p>有了上面书本基础知识的加持，现在到 Arm64 架构下实践一波吧。</p>
<h2 id="汇编基础"><a href="#汇编基础" class="headerlink" title="汇编基础"></a>汇编基础</h2><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p><a href="https://zh.wikipedia.org/wiki/%E5%AF%84%E5%AD%98%E5%99%A8">寄存器</a>（Register）是中央处理器内用来暂存指令、数据和地址的电脑存储器。 它就是 CPU 内部用来存储数据的存储器件，容量小、访问速度快。<br><br/></p>
<p>而 Arm64 有 31 个通用寄存器，相关用途如下。 </p>
<blockquote>
<p>The 64-bit ARM (AArch64) calling convention allocates the 31 general-purpose registers as:<br>x31 (SP): Stack pointer or a zero register, depending on context.<br>x30 (LR): Procedure link register, used to return from subroutines.<br>x29 (FP): Frame pointer.<br>x19 to x29: Callee-saved.<br>x18 (PR): Platform register. Used for some operating-system-specific special purpose, or an additional caller-saved register.<br>x16 (IP0) and x17 (IP1): Intra-Procedure-call scratch registers.<br>x9 to x15: Local variables, caller saved.<br>x8 (XR): Indirect return value address.<br>x0 to x7: Argument values passed to and results returned from a subroutine.</p>
</blockquote>
<p>摘自 <a href="https://en.wikipedia.org/wiki/Calling_convention#ARM_(A64)">Calling_convention#ARM_(A64)</a>。</p>
<br/>

<p>总结下常用的:</p>
<ol>
<li>x0-x7: 用来存放函数调用的参数和函数返回值(x0)，更多参数可以使用堆栈来存放</li>
<li>x29 (FP): 上图 i386 中的 ebp, 它里面存储的是上一个函数（该函数的调用方 caller） ebp 的地址</li>
<li>x30 (LR): 存储函数的返回地址</li>
<li>SP: 上图 i386 中的 esp, 指向栈顶<ol>
<li>现在执行 lldb 命令<code>register read x31</code> 会报错：<code>error: Invalid register name &#39;x31&#39;.</code></li>
</ol>
</li>
<li>PC: 记录 CPU 当前执行的是哪条指令</li>
</ol>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>一些常见的指令，内容摘自 <a href="https://blackteachinese.github.io/2017/07/12/arm64/">10分钟入门arm64汇编</a>，具体的可以参加 ARM 操作手册。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">add x0,x0,#1            ;x0 &lt;&#x3D;&#x3D;x0+1 ,把x0的内容加1。</span><br><span class="line">add x0,x0,#0x30         ;x0 &lt;&#x3D;&#x3D;x0+0x30,把x0的内容加 0x30。</span><br><span class="line">add x0,x1,x3            ;x0 &lt;&#x3D;&#x3D;x1+x3, 把x1的内容加上x3的内容放入x0</span><br><span class="line">add x0,x1,x3,lsl #3     ;x0 &lt;&#x3D;&#x3D;x0+x3*8 ,x3的值左移3位就是乘以8，结果与x1的值相, 放入x0.</span><br><span class="line">add x0,x1,[x2]          ;x0 &lt;&#x3D;&#x3D;x1+[x2], 把x1的内容加上x2的内容作为地址取内存内容放入x0</span><br><span class="line">ldr x0,[x1]             ;x0 &lt;&#x3D;&#x3D;[x1], 把x1的内容作为地址取内存内容放入x0</span><br><span class="line">str x0,[x1]             ;[x1] &lt;&#x3D;&#x3D; x0, 把x0的内容放入x1的内容作为地址的内存中</span><br><span class="line">ldr x0,[x1,#4]          ;x0 &lt;&#x3D;&#x3D;[x1+4], 把x1的内容加上4, 作为内存地址, 取其内容放入x0</span><br><span class="line">ldr x0,[x1,#4]!         ;x0 &lt;&#x3D;&#x3D;[x1+4]、 x1&lt;&#x3D;&#x3D;x1+4, 把x1的内容加上4, 作为内存地址, 取其内容放入x0, 然后把x1的内容加上4放入x1</span><br><span class="line">ldr x0,[x1],#4          ;x0 &lt;&#x3D;&#x3D;[x1] 、x1 &lt;&#x3D;&#x3D;x1+4, 把x1的内容作为内存地址取内存内容放入x0, 并把x1的内容加上4放入x1</span><br><span class="line">ldr x0,[x1,x2]          ;x0 &lt;&#x3D;&#x3D;[x1+x2], 把x1和x2的内容相加, 作为内存地址取内存内容放入x0</span><br></pre></td></tr></table></figure>

<h2 id="栈帧-1"><a href="#栈帧-1" class="headerlink" title="栈帧"></a>栈帧</h2><p><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/stack/aapcs64-variadic-stack.png" alt="aapcs64-variadic-stack"><br>跟《<a href="https://book.douban.com/subject/3652388/">程序员的自我修养–链接、装载与库</a>》里面的栈帧差不多，图片来自 <a href="https://github.com/ARM-software/abi-aa/blob/60a8eb8c55e999d74dac5e368fc9d7e36e38dda4/aapcs64/aapcs64.rst#the-stack">Procedure Call Standard for the Arm® 64-bit Architecture (AArch64)</a>。</p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>用一个 Demo 将上面的内容串联起来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (int)test1:(int)a &#123;</span><br><span class="line">    int res &#x3D; [self test2:a b:2];</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (int)test2:(int)a b:(int)b &#123;</span><br><span class="line">    int res &#x3D; a + b;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    int res &#x3D; [self test1:1];</span><br><span class="line">    NSLog(@&quot;res: %d&quot;, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在函数调用方 <code>test1</code> 和被调方 <code>test2</code> 的第一行代码处下断点，并用汇编查看。</p>
<h3 id="caller-test1"><a href="#caller-test1" class="headerlink" title="caller - test1"></a>caller - test1</h3><p><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/stack/20220930104416.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Demo_fishhook&#96;-[ViewController test1:]:</span><br><span class="line">    0x102067294 &lt;+0&gt;:  sub    sp, sp, #0x30     ; sp &#x3D; sp - 0x30(48), 开辟栈空间</span><br><span class="line">    0x102067298 &lt;+4&gt;:  stp    x29, x30, [sp, #0x20] ; 将 x29(fp) 里面的内容存入 sp+0x20(32)的位置，占 8B(x29 共 64bit, 8B) 长度；将 x30(lr) 的内容存入 sp+0x20+8&#x3D;sp+40 的位置，占 8B</span><br><span class="line">    0x10206729c &lt;+8&gt;:  add    x29, sp, #0x20 ; x29 &#x3D; sp + 0x20</span><br><span class="line">    0x1020672a0 &lt;+12&gt;: stur   x0, [x29, #-0x8] ; 将 x0 的内容，x29-0x8 的位置</span><br><span class="line">    0x1020672a4 &lt;+16&gt;: str    x1, [sp, #0x10] ; 将 x1 的内容放入 sp+0x10 的位置</span><br><span class="line">    0x1020672a8 &lt;+20&gt;: str    w2, [sp, #0xc] ; w2 是 x2 的低32位，占 4B</span><br><span class="line">-&gt;  0x1020672ac &lt;+24&gt;: ldur   x0, [x29, #-0x8] ; 数据读取，就是将上面的数据再读出来</span><br><span class="line">    0x1020672b0 &lt;+28&gt;: ldr    w2, [sp, #0xc] ; 数据读取</span><br><span class="line">    0x1020672b4 &lt;+32&gt;: adrp   x8, 87</span><br><span class="line">    0x1020672b8 &lt;+36&gt;: ldr    x1, [x8, #0xb80] ; 数据读取放入 x1 寄存器中</span><br><span class="line">    0x1020672bc &lt;+40&gt;: mov    w3, #0x2 ; x3 的低32位存的值是 0x2</span><br><span class="line">    0x1020672c0 &lt;+44&gt;: bl     0x102d2f0e4               ; symbol stub for: objc_msgSend ; 函数跳转</span><br><span class="line">    0x1020672c4 &lt;+48&gt;: str    w0, [sp, #0x8] ; 存储 test2 的结果</span><br><span class="line">    0x1020672c8 &lt;+52&gt;: ldr    w0, [sp, #0x8] ; 读取 w0 </span><br><span class="line">    0x1020672cc &lt;+56&gt;: ldp    x29, x30, [sp, #0x20] ; 将 [sp, #0x20] 的内容放入 x29 x30 寄存器</span><br><span class="line">    0x1020672d0 &lt;+60&gt;: add    sp, sp, #0x30 ; sp &#x3D; sp + 0x30</span><br><span class="line">    0x1020672d4 &lt;+64&gt;: ret    </span><br></pre></td></tr></table></figure>
<br/>

<p>这里大概做了下面几件事</p>
<ol>
<li>开辟栈空间，存储 x29 x30 的值到栈，因为后面会修改 x29 x30 的值</li>
<li>给 x29 赋值，即固定当前函数 x29 的位置</li>
<li>存储和读取 x0 x1 w2<code>test2:b:</code> 函数入参的值</li>
<li>给 x3 赋值为 2, 相当于 <code>test2:b:</code> 函数入参 b 的值</li>
<li><code>bl</code> 调用 <code>test2:b:</code> 函数</li>
<li>从栈中取出 x29 x30 的值，回退栈空间</li>
<li>ret: 函数返回到 x30 所指向的地址</li>
</ol>
<br/>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">(lldb) register read</span><br><span class="line">General Purpose Registers:</span><br><span class="line">        x0 &#x3D; 0x0000000102709160</span><br><span class="line">        x1 &#x3D; 0x00000001020ab733  &quot;test1:&quot;</span><br><span class="line">        x2 &#x3D; 0x0000000000000001</span><br><span class="line">        x3 &#x3D; 0x000000016dd9dbf0</span><br><span class="line">        x4 &#x3D; 0x0000000000000010</span><br><span class="line">        x5 &#x3D; 0x0000000000000020</span><br><span class="line">        x6 &#x3D; 0x000000016dd9d8f0</span><br><span class="line">        x7 &#x3D; 0x0000000000000000</span><br><span class="line">        x8 &#x3D; 0x00000001020be000  (void *)0x00000001020ab182: initWithCodeType:baseAddress:size:name:uuid:.hex + 7651</span><br><span class="line">        x9 &#x3D; 0x0000000000000000</span><br><span class="line">       x10 &#x3D; 0x000000000000005d</span><br><span class="line">       x11 &#x3D; 0x00000001030221d8</span><br><span class="line">       x12 &#x3D; 0x000000000000005d</span><br><span class="line">       x13 &#x3D; 0x0000000000000000</span><br><span class="line">       x14 &#x3D; 0x0000000180964000</span><br><span class="line">       x15 &#x3D; 0x000000020b12c000</span><br><span class="line">       x16 &#x3D; 0x00000001020bf9b2  (void *)0xe12800000001020b</span><br><span class="line">       x17 &#x3D; 0x0000000102067294  Demo_fishhook&#96;-[ViewController test1:] at ViewController.m:144</span><br><span class="line">       x18 &#x3D; 0x0000000000000000</span><br><span class="line">       x19 &#x3D; 0x0000000102709160</span><br><span class="line">       x20 &#x3D; 0x0000000000000000</span><br><span class="line">       x21 &#x3D; 0x00000001f59e3000  UIKitCore&#96;_UIInternalPreference_IdleSchedulerTargetDeadlineFraction</span><br><span class="line">       x22 &#x3D; 0x000000019b10ec13  </span><br><span class="line">       x23 &#x3D; 0x000000019b7043f5  </span><br><span class="line">       x24 &#x3D; 0x0000000000000000</span><br><span class="line">       x25 &#x3D; 0x00000001f630c000  UIKitCore&#96;_UIPreviewPresentationAnimator._startMediaTime</span><br><span class="line">       x26 &#x3D; 0x00000001027083f0</span><br><span class="line">       x27 &#x3D; 0x000000019bb48a24  </span><br><span class="line">       x28 &#x3D; 0x00000001fab5f4e8  CoreFoundation&#96;__NSArray0__struct</span><br><span class="line">        fp &#x3D; 0x000000016dd9da20</span><br><span class="line">        lr &#x3D; 0x000000010206718c  Demo_fishhook&#96;-[ViewController viewDidLoad] + 76 at ViewController.m:84:9</span><br><span class="line">        sp &#x3D; 0x000000016dd9da00</span><br><span class="line">        pc &#x3D; 0x00000001020672ac  Demo_fishhook&#96;-[ViewController test1:] + 24 at ViewController.m:145:16</span><br><span class="line">      cpsr &#x3D; 0x40000000</span><br></pre></td></tr></table></figure>
<p>现在来 debug 看下相关寄存器里面的值，分别看.</p>
<ul>
<li>x0-x7, 存放参数和返回值<ul>
<li>x0 和 x1 存储的是 OC 方法的前两个隐藏入参: self 和 _cmd.  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po 0x0000000102709160</span><br><span class="line">&lt;ViewController: 0x102709160&gt;</span><br><span class="line"></span><br><span class="line">(lldb) po (char *)0x00000001020ab733</span><br><span class="line">&quot;test2:b:&quot; </span><br></pre></td></tr></table></figure></li>
<li> <code>x2 = 0x0000000000000001</code> 存储的值是 1, 主上面的汇编代码使用的 w2, 即 x2 低 32 位(即 000000001), 就是值 1 </li>
<li> 断点指向到 0x1020672c0 处后，<code>x3 = 0x0000000000000002</code>，同 x2, 值 2</li>
</ul>
</li>
<li>pc, 当前断点指向的地址</li>
</ul>
<br/>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p&#x2F;x 0x000000016f351a20 - 0x000000016f351a00</span><br><span class="line">(long) $13 &#x3D; 0x0000000000000020</span><br></pre></td></tr></table></figure>
<p>fp-sp=0x20, 因为上面开始开辟栈空间 0x30, 但存储 x29 和 x30 用了 0x10, 所以还剩 0x20 大小的空间可用。</p>
<h3 id="callee-test2"><a href="#callee-test2" class="headerlink" title="callee - test2"></a>callee - test2</h3><p><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/stack/20220930105031.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Demo_fishhook&#96;-[ViewController test2:b:]:</span><br><span class="line">    0x1020672d8 &lt;+0&gt;:  sub    sp, sp, #0x20</span><br><span class="line">    0x1020672dc &lt;+4&gt;:  str    x0, [sp, #0x18]</span><br><span class="line">    0x1020672e0 &lt;+8&gt;:  str    x1, [sp, #0x10]</span><br><span class="line">    0x1020672e4 &lt;+12&gt;: str    w2, [sp, #0xc]</span><br><span class="line">    0x1020672e8 &lt;+16&gt;: str    w3, [sp, #0x8]</span><br><span class="line">-&gt;  0x1020672ec &lt;+20&gt;: ldr    w8, [sp, #0xc]</span><br><span class="line">    0x1020672f0 &lt;+24&gt;: ldr    w9, [sp, #0x8]</span><br><span class="line">    0x1020672f4 &lt;+28&gt;: add    w8, w8, w9</span><br><span class="line">    0x1020672f8 &lt;+32&gt;: str    w8, [sp, #0x4]</span><br><span class="line">    0x1020672fc &lt;+36&gt;: ldr    w0, [sp, #0x4]</span><br><span class="line">    0x102067300 &lt;+40&gt;: add    sp, sp, #0x20</span><br><span class="line">    0x102067304 &lt;+44&gt;: ret    </span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">(lldb) register read</span><br><span class="line">General Purpose Registers:</span><br><span class="line">        x0 &#x3D; 0x0000000102709160</span><br><span class="line">        x1 &#x3D; 0x00000001020ab740  &quot;test2:b:&quot;</span><br><span class="line">        x2 &#x3D; 0x0000000000000001</span><br><span class="line">        x3 &#x3D; 0x0000000000000002</span><br><span class="line">        x4 &#x3D; 0x0000000000000010</span><br><span class="line">        x5 &#x3D; 0x0000000000000020</span><br><span class="line">        x6 &#x3D; 0x000000016dd9d8f0</span><br><span class="line">        x7 &#x3D; 0x0000000000000000</span><br><span class="line">        x8 &#x3D; 0x00000001020be000  (void *)0x00000001020ab182: initWithCodeType:baseAddress:size:name:uuid:.hex + 7651</span><br><span class="line">        x9 &#x3D; 0x0000000000000000</span><br><span class="line">       x10 &#x3D; 0x000000000000002e</span><br><span class="line">       x11 &#x3D; 0x0000000103021ee8</span><br><span class="line">       x12 &#x3D; 0x000000000000002e</span><br><span class="line">       x13 &#x3D; 0x0000000000000000</span><br><span class="line">       x14 &#x3D; 0x0000000180964000</span><br><span class="line">       x15 &#x3D; 0x000000020b12c000</span><br><span class="line">       x16 &#x3D; 0x00000001020bf9b2  (void *)0xe12800000001020b</span><br><span class="line">       x17 &#x3D; 0x00000001020672d8  Demo_fishhook&#96;-[ViewController test2:b:] at ViewController.m:149</span><br><span class="line">       x18 &#x3D; 0x0000000000000000</span><br><span class="line">       x19 &#x3D; 0x0000000102709160</span><br><span class="line">       x20 &#x3D; 0x0000000000000000</span><br><span class="line">       x21 &#x3D; 0x00000001f59e3000  UIKitCore&#96;_UIInternalPreference_IdleSchedulerTargetDeadlineFraction</span><br><span class="line">       x22 &#x3D; 0x000000019b10ec13  </span><br><span class="line">       x23 &#x3D; 0x000000019b7043f5  </span><br><span class="line">       x24 &#x3D; 0x0000000000000000</span><br><span class="line">       x25 &#x3D; 0x00000001f630c000  UIKitCore&#96;_UIPreviewPresentationAnimator._startMediaTime</span><br><span class="line">       x26 &#x3D; 0x00000001027083f0</span><br><span class="line">       x27 &#x3D; 0x000000019bb48a24  </span><br><span class="line">       x28 &#x3D; 0x00000001fab5f4e8  CoreFoundation&#96;__NSArray0__struct</span><br><span class="line">        fp &#x3D; 0x000000016dd9da20</span><br><span class="line">        lr &#x3D; 0x00000001020672c4  Demo_fishhook&#96;-[ViewController test1:] + 48 at ViewController.m:145:9</span><br><span class="line">        sp &#x3D; 0x000000016dd9d9e0</span><br><span class="line">        pc &#x3D; 0x00000001020672ec  Demo_fishhook&#96;-[ViewController test2:b:] + 20 at ViewController.m:151:15</span><br><span class="line">      cpsr &#x3D; 0x40000000</span><br><span class="line"></span><br><span class="line">(lldb)  </span><br></pre></td></tr></table></figure>
<br/>

<p>继续来看寄存器的值</p>
<ul>
<li>x0-x7, 存放参数和返回值<ul>
<li>x0 x1 跟 test1 一样，它们两个的 x0 值都是 0x0000000102709160</li>
<li>x2 = 0x0000000000000001, 入参 a 的值为 1</li>
<li>x3 = 0x0000000000000002, 入参 b 的值为 2</li>
<li>返回值，当断点在 <code>0x102067304</code> 的时候，变化的寄存器值如下，x0 就是返回值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x0 &#x3D; 0x0000000100f0ac70</span><br><span class="line">x8 &#x3D; 0x0000000100a26000  (void *)0x0000000100a13182: initWithCodeType:baseAddress:size:name:uuid:.hex + 7651</span><br><span class="line">x9 &#x3D; 0x0000000000000000</span><br><span class="line">sp &#x3D; 0x000000016f4359e0</span><br><span class="line">pc &#x3D; 0x00000001009cf2ec  Demo_fishhook&#96;-[ViewController test2:b:] + 20 at ViewController.m:151:15</span><br></pre></td></tr></table></figure>
sp 和 pc 变化是可以理解的，因为回退栈空间了；但 x8 和 x9 也发生变化就不知道原因了</li>
</ul>
</li>
<li>fp = 0x000000016dd9da20, 跟 test1 的 fp 值相同</li>
<li>lr = 0x00000001020672c4, 就是 test1 处的 0x1020672c4(即函数跳转处的下一条指令)</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>lr 寄存器存储的是函数返回值，根据 lr 可以回溯到上个函数</li>
<li>test2 没有存储 x29 x30 到栈中, 而 test1 则有存储；因为 test2 是<code>叶子函数</code>，它里面没有调用其他函数。函数调用会用到 bl, 而 bl 则会把下一条指令的地址存入 x30 寄存器，会改变 x30 的值，所以出于保护现场的目的需要提前保存 x30 的值。而这里没有函数调用，意味着不会改变 x30, 所以就没有存储 x30 的意义了。</li>
<li>关于 fp 也是一个有趣的点，分别在 viewDidLoad 和 test1 处下断点，见下图<br><img src="https://raw.githubusercontent.com/JoakimLiu/pic/master/stack/20220930115939.png"></li>
</ol>
<ul>
<li>viewDidLoad.fp = 0x000000016f705a60</li>
<li>test1.fp = 0x000000016f705a20</li>
<li>由于 fp 是指针，那就看它所指向地址存储的数据（x 0x000000016f705a20）：<code>0x16f705a20: 60 5a 70 6f 01 00 00 00</code>, 因为是小端，所有读取出来就是 <code>0x016f705a60</code>(viewDidLoad.fp)，从而验证了该函数的 fp 指向上个函数的 fp</li>
<li><code>0x16f705a8: 8c f1 6f 00 01 00 00 00</code> 就是 <code>0x01006ff18c</code> (test1.lr)，因为在 x29 x30 在 test1 里面就是连续存储的，见 <code>stp    x29, x30, [sp, #0x20]</code></li>
</ul>
<h1 id="获取函数调用栈"><a href="#获取函数调用栈" class="headerlink" title="获取函数调用栈"></a>获取函数调用栈</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>根据前面的 <code>Arm64/Demo/总结</code> 可知，如果要获取函数调用栈的话，首先要找到当前函数的 pc 和 lr 指针。</p>
<ol>
<li>获取当前函数的 pc, 得到当前函数的地址</li>
<li>根据 lr 得到上个函数的地址</li>
<li>循环进行 2 步，直到 lr 为空</li>
<li>拿到相关地址后符号化</li>
</ol>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>从易后难，先看符号化的逻辑。</p>
<h3 id="符号化"><a href="#符号化" class="headerlink" title="符号化"></a>符号化</h3><p>看上面的 <code>Arm64/Demo</code>, 如果在 test2 获取的话，相关寄存器的值如下</p>
<ol>
<li>pc: 0x00000001020672ec</li>
<li>lr: 0x00000001020672c4</li>
</ol>
<p>而 test2 和 test1 的函数地址分别是</p>
<ol>
<li>0x1020672d8</li>
<li>0x102067294</li>
</ol>
<p>也就是说获取的地址值是大于实际地址值的，那这要怎么处理呢？带着这个问题，看下经典库 <a href="https://github.com/kstenerud/KSCrash/blob/498aa21d23541b0bb4990f8d3d20bea2c280a18b/Source/KSCrash/Recording/Tools/KSDynamicLinker.c#L232">KSCrash</a> 是怎么处理的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">bool ksdl_dladdr(const uintptr_t address, Dl_info* const info)</span><br><span class="line">&#123;</span><br><span class="line">    info-&gt;dli_fname &#x3D; NULL;</span><br><span class="line">    info-&gt;dli_fbase &#x3D; NULL;</span><br><span class="line">    info-&gt;dli_sname &#x3D; NULL;</span><br><span class="line">    info-&gt;dli_saddr &#x3D; NULL;</span><br><span class="line">	&#x2F;&#x2F; 在哪个 image</span><br><span class="line">    const uint32_t idx &#x3D; imageIndexContainingAddress(address);</span><br><span class="line">    if(idx &#x3D;&#x3D; UINT_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    const struct mach_header* header &#x3D; _dyld_get_image_header(idx);</span><br><span class="line">    &#x2F;&#x2F; ALSR 值</span><br><span class="line">    const uintptr_t imageVMAddrSlide &#x3D; (uintptr_t)_dyld_get_image_vmaddr_slide(idx);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 就是没有 ALSR 的 VMaddress</span><br><span class="line">    const uintptr_t addressWithSlide &#x3D; address - imageVMAddrSlide;</span><br><span class="line">    &#x2F;&#x2F; 虚拟基地址+ALSR值, 就是包含 ALSR 的虚拟内存地址, 其实就是 header, 验证结果见下面 segmentBase fishhook</span><br><span class="line">    const uintptr_t segmentBase &#x3D; segmentBaseOfImageIndex(idx) + imageVMAddrSlide;</span><br><span class="line">    if(segmentBase &#x3D;&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    info-&gt;dli_fname &#x3D; _dyld_get_image_name(idx);</span><br><span class="line">    info-&gt;dli_fbase &#x3D; (void*)header;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Find symbol tables and get whichever symbol is closest to the address.</span><br><span class="line">    const nlist_t* bestMatch &#x3D; NULL;</span><br><span class="line">    uintptr_t bestDistance &#x3D; ULONG_MAX;</span><br><span class="line">    uintptr_t cmdPtr &#x3D; firstCmdAfterHeader(header);</span><br><span class="line">    if(cmdPtr &#x3D;&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    for(uint32_t iCmd &#x3D; 0; iCmd &lt; header-&gt;ncmds; iCmd++)</span><br><span class="line">    &#123;</span><br><span class="line">        const struct load_command* loadCmd &#x3D; (struct load_command*)cmdPtr;</span><br><span class="line">        &#x2F;&#x2F; 符号表查询</span><br><span class="line">        if(loadCmd-&gt;cmd &#x3D;&#x3D; LC_SYMTAB)</span><br><span class="line">        &#123;</span><br><span class="line">            const struct symtab_command* symtabCmd &#x3D; (struct symtab_command*)cmdPtr;</span><br><span class="line">            const nlist_t* symbolTable &#x3D; (nlist_t*)(segmentBase + symtabCmd-&gt;symoff);</span><br><span class="line">            const uintptr_t stringTable &#x3D; segmentBase + symtabCmd-&gt;stroff;</span><br><span class="line"></span><br><span class="line">            for(uint32_t iSym &#x3D; 0; iSym &lt; symtabCmd-&gt;nsyms; iSym++)</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F; If n_value is 0, the symbol refers to an external object.</span><br><span class="line">                if(symbolTable[iSym].n_value !&#x3D; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    &#x2F;&#x2F; 符号表的值，是不包含 ASLR 值的，所以上面 addressWithSlide 是要减去 ASLR</span><br><span class="line">                    uintptr_t symbolBase &#x3D; symbolTable[iSym].n_value;</span><br><span class="line">                    &#x2F;&#x2F; 两种相减，找距离最近的</span><br><span class="line">                    uintptr_t currentDistance &#x3D; addressWithSlide - symbolBase;</span><br><span class="line">                    &#x2F;*</span><br><span class="line">                	&#96;(addressWithSlide &gt;&#x3D; symbolBase)&#96; : 因为 symbolBase 是具体符号值；而 addressWithSlide 则是需要查找的地址值, 二者可能想到，所以是 &gt;&#x3D; symbolBase</span><br><span class="line">                	(currentDistance &lt;&#x3D; bestDistance) : 寻找最匹配的，距离越近越好</span><br><span class="line">                	*&#x2F;</span><br><span class="line">                    if((addressWithSlide &gt;&#x3D; symbolBase) &amp;&amp;</span><br><span class="line">                       (currentDistance &lt;&#x3D; bestDistance))</span><br><span class="line">                    &#123;</span><br><span class="line">                        &#x2F;&#x2F; iSym 符号表的下标，跟 fishhook 里面的字符串计算是一样的道理</span><br><span class="line">                        bestMatch &#x3D; symbolTable + iSym;</span><br><span class="line">                        bestDistance &#x3D; currentDistance;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(bestMatch !&#x3D; NULL)</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F; + imageVMAddrSlide(ASLR值)，因为前面 addressWithSlide 有减去 imageVMAddrSlide ASLR 值</span><br><span class="line">                info-&gt;dli_saddr &#x3D; (void*)(bestMatch-&gt;n_value + imageVMAddrSlide);</span><br><span class="line">                if(bestMatch-&gt;n_desc &#x3D;&#x3D; 16)</span><br><span class="line">                &#123;</span><br><span class="line">                    &#x2F;&#x2F; This image has been stripped. The name is meaningless, and</span><br><span class="line">                    &#x2F;&#x2F; almost certainly resolves to &quot;_mh_execute_header&quot;</span><br><span class="line">                    info-&gt;dli_sname &#x3D; NULL;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    &#x2F;&#x2F; 过掉符号修饰的前面的 &#96;_&#96;。</span><br><span class="line">                    info-&gt;dli_sname &#x3D; (char*)((intptr_t)stringTable + (intptr_t)bestMatch-&gt;n_un.n_strx);</span><br><span class="line">                    if(*info-&gt;dli_sname &#x3D;&#x3D;addressWithSlide - &#39;_&#39;)</span><br><span class="line">                    &#123;</span><br><span class="line">                        info-&gt;dli_sname++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 继续匹配下一个符号</span><br><span class="line">        cmdPtr +&#x3D; loadCmd-&gt;cmdsize;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码可知，跟 fishhook 查找符号表原理是类似的，就是用 lr 的地址值到符号表里一一匹配，找到比 lr 地址值小并离 lr 地址值最近的那个符号就是该函数的符号。</p>
<h3 id="获取线程信息"><a href="#获取线程信息" class="headerlink" title="获取线程信息"></a>获取线程信息</h3><p>因为 KSCrash 这块的代码比较多，现在还没捋顺，于是就找到了《<a href="https://time.geekbang.org/column/intro/100024501?tab=catalog">iOS 开发高手课</a>》作者的 <a href="https://github.com/ming1016/DecoupleDemo/blob/master/DecoupleDemo/SMCallStack.m#L103">SMCallStack.m</a></p>
<br/>

<p>大致逻辑(只针对 Arm64 架构)如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">typedef struct SMStackFrame &#123;</span><br><span class="line">    const struct SMStackFrame *const previous;</span><br><span class="line">    const uintptr_t return_address;</span><br><span class="line">&#125; SMStackFrame;</span><br><span class="line"></span><br><span class="line">NSString *smStackOfThread(thread_t thread) &#123;</span><br><span class="line">    uintptr_t buffer[100];</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    _STRUCT_MCONTEXT64 machineContext;</span><br><span class="line">    mach_msg_type_number_t state_count &#x3D; ARM_THREAD_STATE64_COUNT;</span><br><span class="line">    kern_return_t kr &#x3D; thread_get_state(thread, ARM_THREAD_STATE64, (thread_state_t)&amp;machineContext.__ss, &amp;state_count);</span><br><span class="line">    if (kr !&#x3D; KERN_SUCCESS) &#123;</span><br><span class="line">        return [NSString stringWithFormat:@&quot;Fail get thread: %u&quot;, thread];</span><br><span class="line">    &#125;</span><br><span class="line">    const uintptr_t instructionAddress &#x3D; machineContext.__ss.__pc;</span><br><span class="line">    buffer[i++] &#x3D; instructionAddress;</span><br><span class="line">    uintptr_t linkRegisterPointer &#x3D; machineContext.__ss.__lr;</span><br><span class="line">    if (linkRegisterPointer) &#123;</span><br><span class="line">        buffer[i++] &#x3D; linkRegisterPointer;</span><br><span class="line">    &#125;</span><br><span class="line">    SMStackFrame stackFrame &#x3D; &#123;0&#125;;</span><br><span class="line">    const uintptr_t framePointer &#x3D; machineContext.__ss.__fp;</span><br><span class="line">    </span><br><span class="line">    vm_size_t bytesCopied &#x3D; 0;</span><br><span class="line">    if (framePointer &#x3D;&#x3D; 0 || vm_read_overwrite(mach_task_self(), (vm_address_t)(void *)framePointer, (vm_size_t)sizeof(stackFrame), (vm_address_t)&amp;stackFrame, &amp;bytesCopied) !&#x3D; KERN_SUCCESS) &#123;</span><br><span class="line">        return @&quot;Fail frame pointer&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bytesCopied &#x3D; 0;</span><br><span class="line">    </span><br><span class="line">    for (; ; i++) &#123;</span><br><span class="line">        buffer[i] &#x3D; stackFrame.return_address;</span><br><span class="line">        if (buffer[i] &#x3D;&#x3D; 0 || stackFrame.previous &#x3D;&#x3D; 0 || vm_read_overwrite(mach_task_self(), (vm_address_t)(void *)stackFrame.previous, (vm_size_t)sizeof(stackFrame), (vm_address_t)&amp;stackFrame, &amp;bytesCopied) !&#x3D; KERN_SUCCESS) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; xxxxx</span><br><span class="line">    return @&quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码大致逻辑能看懂：根据系统函数获取 pc fp lr, 再循环获取 lr 加入数组。<br>但不知道为什么要这样写，只能找到根据大佬的代码去搜索相关资料，基本都是操作系统领域的相关知识。</p>
<h4 id="STRUCT-MCONTEXT64"><a href="#STRUCT-MCONTEXT64" class="headerlink" title="_STRUCT_MCONTEXT64"></a>_STRUCT_MCONTEXT64</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#define _STRUCT_MCONTEXT64      struct __darwin_mcontext64</span><br><span class="line">_STRUCT_MCONTEXT64</span><br><span class="line">&#123;</span><br><span class="line">	_STRUCT_ARM_EXCEPTION_STATE64   __es;</span><br><span class="line">	_STRUCT_ARM_THREAD_STATE64      __ss;</span><br><span class="line">	_STRUCT_ARM_NEON_STATE64        __ns;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">_STRUCT_ARM_THREAD_STATE64</span><br><span class="line">&#123;</span><br><span class="line">	__uint64_t __x[29]; &#x2F;* General purpose registers x0-x28 *&#x2F;</span><br><span class="line">	__uint64_t __fp;    &#x2F;* Frame pointer x29 *&#x2F;</span><br><span class="line">	__uint64_t __lr;    &#x2F;* Link register x30 *&#x2F;</span><br><span class="line">	__uint64_t __sp;    &#x2F;* Stack pointer x31 *&#x2F;</span><br><span class="line">	__uint64_t __pc;    &#x2F;* Program counter *&#x2F;</span><br><span class="line">	__uint32_t __cpsr;  &#x2F;* Current program status register *&#x2F;</span><br><span class="line">	__uint32_t __pad;   &#x2F;* Same size for 32-bit or 64-bit clients *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>获取线程寄存器相关信息。</p>
<h4 id="thread-get-state"><a href="#thread-get-state" class="headerlink" title="thread_get_state"></a>thread_get_state</h4><p>在 <a href="https://github.com/apple-oss-distributions/xnu/blob/main/libsyscall/wrappers/thread_register_state.c#L63">xnu</a> 源码中找到了搜索到了蛛丝马迹，获取到 state 内容后使用相关寄存器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#if defined(__i386__)</span><br><span class="line">	i386_thread_state_t state &#x3D; &#123;&#125;;</span><br><span class="line">	thread_state_flavor_t flavor &#x3D; x86_THREAD_STATE32;</span><br><span class="line">	mach_msg_type_number_t count &#x3D; i386_THREAD_STATE_COUNT;</span><br><span class="line">#elif defined(__x86_64__)</span><br><span class="line">	x86_thread_state64_t state &#x3D; &#123;&#125;;</span><br><span class="line">	thread_state_flavor_t flavor &#x3D; x86_THREAD_STATE64;</span><br><span class="line">	mach_msg_type_number_t count &#x3D; x86_THREAD_STATE64_COUNT;</span><br><span class="line">#elif defined(__arm__)</span><br><span class="line">	arm_thread_state_t state &#x3D; &#123;&#125;;</span><br><span class="line">	thread_state_flavor_t flavor &#x3D; ARM_THREAD_STATE;</span><br><span class="line">	mach_msg_type_number_t count &#x3D; ARM_THREAD_STATE_COUNT;</span><br><span class="line">#elif defined(__arm64__)</span><br><span class="line">	arm_thread_state64_t state &#x3D; &#123;&#125;;</span><br><span class="line">	thread_state_flavor_t flavor &#x3D; ARM_THREAD_STATE64;</span><br><span class="line">	mach_msg_type_number_t count &#x3D; ARM_THREAD_STATE64_COUNT;</span><br><span class="line">#else</span><br><span class="line">#error thread_get_register_pointer_values not defined for this architecture</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	kern_return_t ret &#x3D; thread_get_state(thread, flavor, (thread_state_t)&amp;state, &amp;count);</span><br><span class="line">	</span><br><span class="line">&#x2F;&#x2F;	xxxx</span><br><span class="line">if (sp) &#123;</span><br><span class="line">		uintptr_t __sp &#x3D; arm_thread_state64_get_sp(state);</span><br><span class="line">		if (__sp &gt; 128) &#123;</span><br><span class="line">			*sp &#x3D; __sp - 128 &#x2F;* redzone *&#x2F;;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			*sp &#x3D; 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	push_register_value(arm_thread_state64_get_lr(state));</span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; 0; i &lt; 29; i++) &#123;</span><br><span class="line">		push_register_value(state.__x[i]);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="vm-read-overwrite"><a href="#vm-read-overwrite" class="headerlink" title="vm_read_overwrite"></a>vm_read_overwrite</h4><p><a href="http://web.mit.edu/darwin/src/modules/xnu/osfmk/man/vm_read.html">vm_read_overwrite</a></p>
<blockquote>
<p>The vm_read and vm_read_overwrite functions read a portion of a task’s virtual memory (they enable tasks to read other tasks’ memory). The vm_read function returns the data in a dynamically allocated array of bytes; the vm_read_overwrite function places the data into a caller-specified buffer (the data_in parameter).</p>
</blockquote>
<p>上面的代码就是调用系统函数 <code>vm_read_overwrite</code> 从 fp 的位置开始读取内存，给 <code>SMStackFrame</code> 结构体赋值，从而得到 lr, 再根据 lr 递归调用获取整个函数的调用链。 </p>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="ksdl-dladdr"><a href="#ksdl-dladdr" class="headerlink" title="ksdl_dladdr"></a>ksdl_dladdr</h2><p>从上面的调试可知，<code>dladdr</code> 就是 <code>lldb</code> 命令 <code>image lookup -a 0x00xxx</code> 的代码实现，二者功能是类似的。<br><br/></p>
<blockquote>
<p>NAME<br>     dladdr – find the image containing a given address</p>
</blockquote>
<p>上面是在终端使用 <code>man dladdr</code> 得到的内容。</p>
<p>有一个问题：为什么不使用系统的 <code>dladdr</code> 函数？而要自己实现 <code>ksdl_dladdr</code> 呢？<br>找到了相关问题 <a href="https://github.com/bestswifter/BSBacktraceLogger/issues/8">BSBacktraceLogger - 请问为什么不用系统提供的dladdr方法，而需要自己写一个fl_dladdr呢？ #8</a>，但作者没有给出有用的答案。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** async-safe version of dladdr.</span><br><span class="line"> *</span><br><span class="line"> * This method searches the dynamic loader for information about any image</span><br><span class="line"> * containing the specified address. It may not be entirely successful in</span><br><span class="line"> * finding information, in which case any fields it could not find will be set</span><br><span class="line"> * to NULL.</span><br><span class="line"> *</span><br><span class="line"> * Unlike dladdr(), this method does not make use of locks, and does not call</span><br><span class="line"> * async-unsafe functions.</span><br><span class="line"> *</span><br><span class="line"> * @param address The address to search for.</span><br><span class="line"> * @param info Gets filled out by this function.</span><br><span class="line"> * @return true if at least some information was found.</span><br><span class="line"> *&#x2F;</span><br><span class="line">bool ksdl_dladdr(const uintptr_t address, Dl_info* const info);</span><br></pre></td></tr></table></figure>
<p>看 <code>ksdl_dladdr</code> 的声明可知，从侧面反应系统的 <code>dladdr</code> 是同步的，会使用锁，可能会导致耗时。</p>
<p>有兴趣的可以查看 <a href="https://github.com/apple-oss-distributions/dyld/blob/f73171cf0a177f453fdb124952908fe83864acab/dyld/DyldAPIs.cpp#L1016">dyld</a> 里面关于 <code>dladdr</code> 的实现。</p>
<h2 id="lldb-backtrace-thread"><a href="#lldb-backtrace-thread" class="headerlink" title="lldb backtrace thread"></a>lldb backtrace thread</h2><p>不管是 <a href="https://github.com/ming1016/DecoupleDemo/blob/master/DecoupleDemo/SMCallStack.m#L103">SMCallStack</a> 还是 <a href="https://github.com/bestswifter/BSBacktraceLogger/issues/8">BSBacktraceLogger</a> 输出结果跟 <code>lldb bt</code> 的结果还是有些差异的，可能跟着两个库代码很久没更新有关系，<a href="https://github.com/microsoft/plcrashreporter">plcrashreporter</a> 的输出结果最接近（因为不知道怎么根据 KSCrash 直接获取调用堆栈），代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PLCrashReporterConfig *config &#x3D; [[PLCrashReporterConfig alloc] initWithSignalHandlerType:PLCrashReporterSignalHandlerTypeBSD symbolicationStrategy:PLCrashReporterSymbolicationStrategyAll];</span><br><span class="line">    PLCrashReporter *crashReporter &#x3D; [[PLCrashReporter alloc] initWithConfiguration:config];</span><br><span class="line">    NSData *data &#x3D; [crashReporter generateLiveReport];</span><br><span class="line">    PLCrashReport *reporter &#x3D; [[PLCrashReport alloc] initWithData:data error:NULL];</span><br><span class="line">    NSString *report &#x3D; [PLCrashReportTextFormatter stringValueForCrashReport:reporter</span><br><span class="line">withTextFormat:PLCrashReportTextFormatiOS];</span><br></pre></td></tr></table></figure>
<br>

<p>所以，就想找到 <code>lldb backtrace thread</code> 的源码实现。<br>下载 <a href="https://github.com/apple-oss-distributions/lldb">lldb</a> 工程，然后搜索 <code>Backtrace thread</code> 找到如下相关代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">lldb::ThreadSP</span><br><span class="line">    GetExtendedBacktraceThread (ConstString type);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ----</span><br><span class="line">uint32_t</span><br><span class="line">SBThread::GetExtendedBacktraceOriginatingIndexID ()</span><br><span class="line">&#123;</span><br><span class="line">    ThreadSP thread_sp(m_opaque_sp-&gt;GetThreadSP());</span><br><span class="line">    if (thread_sp)</span><br><span class="line">        return thread_sp-&gt;GetExtendedBacktraceOriginatingIndexID();</span><br><span class="line">    return LLDB_INVALID_INDEX32;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ----</span><br><span class="line">typedef std::shared_ptr&lt;lldb_private::Thread&gt; ThreadSP;</span><br></pre></td></tr></table></figure>
<p>坑爹，看到 <code>lldb_private</code> 就知道凉凉了，因为它是私有的，只在 llvm 官网找到了相关定义 <a href="https://lldb.llvm.org/cpp_reference/classlldb__private_1_1Thread.html">lldb_private::Thread Class Reference</a>。</p>
<p>后面又想过是否可以通过查看 GDB 的源码来查看 <code>backtrace thread</code> 的源码实现，嗯，是个好想法！！！</p>
<h2 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h2><p>我们知道，OC 的方法调用最终都会走 <code>objc_msgSend</code> 这个汇编实现的函数，那为什么它没有出现在调用堆栈里面呢？<br>可以猜测下答案：因为 <code>objc_msgSend</code> 不会使用栈空间。<br>下面来 debug 调试下，还是前面 <code>viewDidLoad</code> 调用 <code>test1</code> 的例子，分别对比在这两个函数汇编下寄存器的值。</p>
<hr>
<p>call test1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Demo_fishhook&#96;-[ViewController viewDidLoad]:</span><br><span class="line">    0x104e32f58 &lt;+0&gt;:   sub    sp, sp, #0x40</span><br><span class="line">    0x104e32f5c &lt;+4&gt;:   stp    x29, x30, [sp, #0x30]</span><br><span class="line">    0x104e32f60 &lt;+8&gt;:   add    x29, sp, #0x30</span><br><span class="line">    0x104e32f64 &lt;+12&gt;:  stur   x0, [x29, #-0x8]</span><br><span class="line">    0x104e32f68 &lt;+16&gt;:  stur   x1, [x29, #-0x10]</span><br><span class="line">    0x104e32f6c &lt;+20&gt;:  ldur   x8, [x29, #-0x8]</span><br><span class="line">    0x104e32f70 &lt;+24&gt;:  add    x0, sp, #0x10</span><br><span class="line">    0x104e32f74 &lt;+28&gt;:  str    x8, [sp, #0x10]</span><br><span class="line">    0x104e32f78 &lt;+32&gt;:  adrp   x8, 89</span><br><span class="line">    0x104e32f7c &lt;+36&gt;:  ldr    x8, [x8, #0x6c0]</span><br><span class="line">    0x104e32f80 &lt;+40&gt;:  str    x8, [sp, #0x18]</span><br><span class="line">    0x104e32f84 &lt;+44&gt;:  adrp   x8, 88</span><br><span class="line">    0x104e32f88 &lt;+48&gt;:  ldr    x1, [x8, #0xbe8]</span><br><span class="line">    0x104e32f8c &lt;+52&gt;:  bl     0x104e730a4               ; symbol stub for: objc_msgSendSuper2</span><br><span class="line">    0x104e32f90 &lt;+56&gt;:  ldur   x0, [x29, #-0x8]</span><br><span class="line">    0x104e32f94 &lt;+60&gt;:  adrp   x8, 88</span><br><span class="line">    0x104e32f98 &lt;+64&gt;:  ldr    x1, [x8, #0xbf0]</span><br><span class="line">    0x104e32f9c &lt;+68&gt;:  mov    w2, #0x1</span><br><span class="line">-&gt;  0x104e32fa0 &lt;+72&gt;:  bl     0x104e73098               ; symbol stub for: objc_msgSend</span><br><span class="line">    0x104e32fa4 &lt;+76&gt;:  str    w0, [sp, #0xc]</span><br><span class="line">    0x104e32fa8 &lt;+80&gt;:  ldr    w9, [sp, #0xc]</span><br><span class="line">    0x104e32fac &lt;+84&gt;:  mov    x8, x9</span><br><span class="line">    0x104e32fb0 &lt;+88&gt;:  adrp   x0, 81</span><br><span class="line">    0x104e32fb4 &lt;+92&gt;:  add    x0, x0, #0x440            ; @&quot;res: %d&quot;</span><br><span class="line">    0x104e32fb8 &lt;+96&gt;:  mov    x9, sp</span><br><span class="line">    0x104e32fbc &lt;+100&gt;: str    x8, [x9]</span><br><span class="line">    0x104e32fc0 &lt;+104&gt;: bl     0x104e72720               ; symbol stub for: NSLog</span><br><span class="line">    0x104e32fc4 &lt;+108&gt;: ldp    x29, x30, [sp, #0x30]</span><br><span class="line">    0x104e32fc8 &lt;+112&gt;: add    sp, sp, #0x40</span><br><span class="line">    0x104e32fcc &lt;+116&gt;: ret    </span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) register read</span><br><span class="line">General Purpose Registers:</span><br></pre></td></tr></table></figure>
<hr>
<p>objc_msgSend</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Demo_fishhook&#96;objc_msgSend:</span><br><span class="line">-&gt;  0x104e73098 &lt;+0&gt;: nop    </span><br><span class="line">    0x104e7309c &lt;+4&gt;: ldr    x16, #0xd6e4              ; (void *)0x0000000198569ce0: objc_msgSend</span><br><span class="line">    0x104e730a0 &lt;+8&gt;: br     x16</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(lldb) si</span><br><span class="line">(lldb) register read</span><br><span class="line">General Purpose Registers:</span><br></pre></td></tr></table></figure>
<p>对比发现两者变化的仅仅是 <code>lr</code> 和 <code>pc</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; test1</span><br><span class="line">lr &#x3D; 0x0000000104e32f90  Demo_fishhook&#96;-[ViewController viewDidLoad] + 56 at ViewController.m:84:16</span><br><span class="line">pc &#x3D; 0x0000000104e32fa0  Demo_fishhook&#96;-[ViewController viewDidLoad] + 72 at ViewController.m:84:15</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; objc_msgSend</span><br><span class="line">lr &#x3D; 0x0000000104e32fa4  Demo_fishhook&#96;-[ViewController viewDidLoad] + 76 at ViewController.m:84:9</span><br><span class="line">pc &#x3D; 0x0000000104e73098  Demo_fishhook&#96;symbol stub for: objc_msgSend</span><br></pre></td></tr></table></figure>
<p>经过上面的输出可知，<code>objc_msgSend</code> 共用当前函数的栈空间，没有产生新的栈空间，所以就不会出现在函数调用栈里面了，所以，这是 <code>objc_msgSend</code> 用汇编实现的原因之一吗？</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="https://book.douban.com/subject/3652388/">程序员的自我修养–链接、装载与库</a></li>
<li><a href="https://github.com/ARM-software/abi-aa/blob/60a8eb8c55e999d74dac5e368fc9d7e36e38dda4/aapcs64/aapcs64.rst#the-stack">Procedure Call Standard for the Arm® 64-bit Architecture (AArch64)</a></li>
<li><a href="https://en.wikipedia.org/wiki/Calling_convention#ARM_(A64)">Calling_convention#ARM_(A64)</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%AF%84%E5%AD%98%E5%99%A8">寄存器</a></li>
<li><a href="https://time.geekbang.org/column/intro/100024501?tab=catalog">iOS 开发高手课</a></li>
<li><a href="https://blackteachinese.github.io/2017/07/12/arm64/">10分钟入门arm64汇编</a></li>
<li><a href="https://github.com/bestswifter/BSBacktraceLogger/issues/8">BSBacktraceLogger - 请问为什么不用系统提供的dladdr方法，而需要自己写一个fl_dladdr呢？ #8</a></li>
<li><a href="https://github.com/apple-oss-distributions/dyld/blob/f73171cf0a177f453fdb124952908fe83864acab/dyld/DyldAPIs.cpp#L1016">dyld</a></li>
<li><a href="https://github.com/ming1016/DecoupleDemo/blob/master/DecoupleDemo/SMCallStack.m#L103">SMCallStack</a></li>
<li><a href="https://github.com/kstenerud/KSCrash/blob/498aa21d23541b0bb4990f8d3d20bea2c280a18b/Source/KSCrash/Recording/Tools/KSDynamicLinker.c#L232">KSCrash</a></li>
<li><a href="https://github.com/microsoft/plcrashreporter">plcrashreporter</a></li>
<li><a href="https://github.com/apple-oss-distributions/lldb">lldb</a></li>
<li><a href="http://djs66256.github.io/2018/01/21/2018-01-21-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%8E%B7%E5%8F%96%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88/">运行时获取函数调用栈</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/09/20/fishhook/" rel="prev" title="从 Fishhook 学到了什么？">
      <i class="fa fa-chevron-left"></i> 从 Fishhook 学到了什么？
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%88"><span class="nav-number">1.</span> <span class="nav-text">栈</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E5%B8%A7"><span class="nav-number">1.1.</span> <span class="nav-text">栈帧</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E6%83%AF%E4%BE%8B"><span class="nav-number">1.2.</span> <span class="nav-text">调用惯例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Arm64"><span class="nav-number">2.</span> <span class="nav-text">Arm64</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80"><span class="nav-number">2.1.</span> <span class="nav-text">汇编基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">2.1.1.</span> <span class="nav-text">寄存器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4"><span class="nav-number">2.1.2.</span> <span class="nav-text">指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E5%B8%A7-1"><span class="nav-number">2.2.</span> <span class="nav-text">栈帧</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Demo"><span class="nav-number">2.3.</span> <span class="nav-text">Demo</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#caller-test1"><span class="nav-number">2.3.1.</span> <span class="nav-text">caller - test1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#callee-test2"><span class="nav-number">2.3.2.</span> <span class="nav-text">callee - test2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">2.3.3.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88"><span class="nav-number">3.</span> <span class="nav-text">获取函数调用栈</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF"><span class="nav-number">3.1.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.2.</span> <span class="nav-text">具体实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E5%8C%96"><span class="nav-number">3.2.1.</span> <span class="nav-text">符号化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8B%E4%BF%A1%E6%81%AF"><span class="nav-number">3.2.2.</span> <span class="nav-text">获取线程信息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#STRUCT-MCONTEXT64"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">_STRUCT_MCONTEXT64</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#thread-get-state"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">thread_get_state</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vm-read-overwrite"><span class="nav-number">3.2.2.3.</span> <span class="nav-text">vm_read_overwrite</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%A9%E5%B1%95"><span class="nav-number">4.</span> <span class="nav-text">扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ksdl-dladdr"><span class="nav-number">4.1.</span> <span class="nav-text">ksdl_dladdr</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lldb-backtrace-thread"><span class="nav-number">4.2.</span> <span class="nav-text">lldb backtrace thread</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#objc-msgSend"><span class="nav-number">4.3.</span> <span class="nav-text">objc_msgSend</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="nav-number">5.</span> <span class="nav-text">参考链接</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">joakim.liu</p>
  <div class="site-description" itemprop="description">你不解决问题，就会成为问题。iOS菜逗一枚。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">40</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/JoakimLiu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;JoakimLiu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/JoakimLiu" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;JoakimLiu" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">joakim.liu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script>
  var disqus_config = function() {
    this.page.url = "http://example.com/2022/09/30/stack/";
    this.page.identifier = "2022/09/30/stack/";
    this.page.title = "iOS 函数调用栈那些事";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://http-joakimliu-github-io.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
