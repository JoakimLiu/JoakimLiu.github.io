<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="iOS中的事件处理">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS的事件处理">
<meta property="og:url" content="http://example.com/2017/01/15/iOS%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/index.html">
<meta property="og:site_name" content="牛易疯先森的开发记录">
<meta property="og:description" content="iOS中的事件处理">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://ww2.sinaimg.cn/mw690/005IevIrjw1fbr6dodpgmj31p80pawqm.jpg">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/General/Conceptual/Devpedia-CocoaApp/Art/target_action.jpg">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/gestureRecognizer_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/discrete_vs_continuous_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/gr_state_transitions_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/path_of_touches_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/recognize_touch_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/hit_testing_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/iOS_responder_chain_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/exclusive_touch_view_2x.png">
<meta property="og:image" content="http://ww4.sinaimg.cn/mw690/005IevIrjw1fbrc8p59h4j30sq0r4tkl.jpg">
<meta property="og:image" content="http://ww3.sinaimg.cn/mw690/005IevIrjw1fbrc8oa8etj30sw0q87fd.jpg">
<meta property="article:published_time" content="2017-01-15T02:20:28.000Z">
<meta property="article:modified_time" content="2021-01-22T14:55:23.851Z">
<meta property="article:author" content="joakim.liu">
<meta property="article:tag" content="Event Handling">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://ww2.sinaimg.cn/mw690/005IevIrjw1fbr6dodpgmj31p80pawqm.jpg">

<link rel="canonical" href="http://example.com/2017/01/15/iOS%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>iOS的事件处理 | 牛易疯先森的开发记录</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">牛易疯先森的开发记录</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/01/15/iOS%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="joakim.liu">
      <meta itemprop="description" content="你不解决问题，就会成为问题。iOS菜逗一枚。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="牛易疯先森的开发记录">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          iOS的事件处理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-01-15 10:20:28" itemprop="dateCreated datePublished" datetime="2017-01-15T10:20:28+08:00">2017-01-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">经验分享</span></a>
                </span>
            </span>

          
            <div class="post-description">iOS中的事件处理</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>**转载请注明出处！<a href="http://joakimliu.github.io/2017/01/15/iOS%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/">http://joakimliu.github.io/2017/01/15/iOS的事件处理/</a> 谢谢！ **</p>
<p>最近把 <a href="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009541-CH1-SW1">Event Handling Guide for iOS</a> 看了几遍，算是对 iOS 的事件处理有了个整体的概念，<strong>本文较长，可以先看后面的总结部分</strong>。对于事件处理，我们最熟悉的莫过于下面的<code>Target-Action</code>模式代码。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UIControl </span><br><span class="line">addTarget:action:forControlEvents:</span><br><span class="line"></span><br><span class="line">UIGestureRecognizer</span><br><span class="line">initWithTarget:action:</span><br></pre></td></tr></table></figure>
<p>这些都是比较高级的用法了，因为 UIKit 都帮我们处理了，<code>Gesture recognizers convert low-level event handling code into higher-level actions.</code>低级的事件处理就是所谓的自定义事件处理。在这之前，我们先谈谈 iOS 中表示事件的相关类。</p>
<p>#一些重要的类<br>##UIEvent<br><code>A UIEvent object (or, simply, an event object) represents an event in iOS.</code> 在 iOS 中，事件是由<a href="https://developer.apple.com/reference/uikit/uievent?language=objc">UIEvent</a>类表示的，大致可以分为四种类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, UIEventType) &#123;</span><br><span class="line">    UIEventTypeTouches, &#x2F;&#x2F; 触摸事件，按钮、手势等</span><br><span class="line">    UIEventTypeMotion, &#x2F;&#x2F; 运动事件，摇一摇、指南针等</span><br><span class="line">    UIEventTypeRemoteControl, &#x2F;&#x2F; 远程控制，耳机等</span><br><span class="line">    UIEventTypePresses NS_ENUM_AVAILABLE_IOS(9_0), &#x2F;&#x2F; 3D touch</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里只说 UIEventTypeTouches 触摸事件（注：本文所说的事件都是触摸事件）。 event 里面包含一个或者多个 touch (代表手指触摸屏幕，由 <a href="https://developer.apple.com/reference/uikit/uitouch?language=objc">UITouch</a> 类表示，下面会说)。当触摸事件发生时，系统会将它路由到合适的响应者，然后通过 UIResponder 的 touchesBegan:withEvent: 等方法传递。系统会评估这个事件并且找到合适的对象来处理它(包括<code>hit-testing</code>和<code>first responder</code>)，一般情况下，我们不需要做特殊的处理。所以 UIEvent 类里面有多个获取 UITouch 对象的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (nullable NSSet &lt;UITouch *&gt; *)allTouches;</span><br><span class="line">- (nullable NSSet &lt;UITouch *&gt; *)touchesForWindow:(UIWindow *)window;</span><br><span class="line">- (nullable NSSet &lt;UITouch *&gt; *)touchesForView:(UIView *)view;</span><br><span class="line">- (nullable NSSet &lt;UITouch *&gt; *)touchesForGestureRecognizer:(UIGestureRecognizer *)gesture NS_AVAILABLE_IOS(3_2);</span><br><span class="line">- (nullable NSArray &lt;UITouch *&gt; *)coalescedTouchesForTouch:(UITouch *)touch NS_AVAILABLE_IOS(9_0);</span><br><span class="line">- (nullable NSArray &lt;UITouch *&gt; *)predictedTouchesForTouch:(UITouch *)touch NS_AVAILABLE_IOS(9_0);</span><br></pre></td></tr></table></figure>
<p>这里有两点需要注意一下：</p>
<ul>
<li>timestamp 属性，这个时间戳是从系统开机后开始算的。相关事件处理，可以看Peak君的<a href="http://mrpeak.cn/blog/ios-time/">iOS关于时间的处理</a>；</li>
<li><code>You should never retain an event object or any object returned from an event object.</code> 不要持有事件对象或者从事件 对象中返回的对象。因为 UIEvent 对象在多点触摸序列（指手指触摸屏幕到离开屏幕）中是持久的， UIKit 会重用 UIEvent 对象，如果你需要持有 event 或者 touch 的相关信息时，你可以拷贝相关信息，赋值给相关变量。</li>
</ul>
<p>##UITouch<br>它代表手指触摸到屏幕上的位置，大小等相关信息。一个手指代表一个 UITouch 对象，所以可以根据<code>tapCount</code>属性来判断是单击、双击、三击。根据 touch 可以我们可以得知</p>
<ul>
<li>The view or window in which the touch occurred （touch 发生所在的 view 或者 window）</li>
<li>The location of the touch within the view or window （touch 发生所在的 view 或者 window 上的位置）</li>
<li>The approximate radius of the touch</li>
<li>The force of the touch (on devices that support 3D Touch or Apple Pencil)</li>
</ul>
<p>当然还可以知道接受该 touch 对象的 gestureRecognizers 手势识别器。</p>
<p>我们还可以根据 phase 属性获取 touch 的相关状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UITouchPhaseBegan: A finger for a given event touched the screen.</span><br><span class="line">UITouchPhaseMoved: A finger for a given event moved on the screen.</span><br><span class="line">UITouchPhaseStationary: A finger is touching the surface but hasn&#39;t moved since the previous event.</span><br><span class="line">UITouchPhaseEnded: A finger for a given event was lifted from the screen.</span><br><span class="line">UITouchPhaseCancelled: The system canceled tracking for the touch, as when (for example) the user moves the device against his or her face.</span><br></pre></td></tr></table></figure>
<p>除了 UITouchPhaseStationary 状态以外，每个状态都对应着 UIResponder 的<code>touchXxxxx:withEvent:</code>类似的方法。拿到 UITouch ，我们就可以指定这个触摸事件所在的 view 以及位置。拿到位置以后，我们就可以做我们想要做的事情了。</p>
<p>##UIResponder<br><code>The UIResponder class defines an interface for objects that respond to and handle events. It is the superclass of UIApplication, UIView and its subclasses (which include UIWindow). Instances of these classes are sometimes referred to as responder objects or, simply, responders.</code> 它定义了响应和处理事件的接口。像一些能够处理相应事件的类（UIApplication, UIView 等）都是它的子类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 处理触摸事件的主要方法，所以我们自定义事件处理时，就需要在这几个方法里面做文章。</span><br><span class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event; &#x2F;&#x2F; 一根或者多跟手指开始触摸屏幕</span><br><span class="line">- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event; &#x2F;&#x2F; 手指在屏幕上移动</span><br><span class="line">- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event; &#x2F;&#x2F; 手指离开屏幕</span><br><span class="line">- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event; &#x2F;&#x2F; 收到系统的事件（如，来电话了或者低内存警告等）取消触摸事件</span><br></pre></td></tr></table></figure>
<p>只要手指触摸在屏幕上，不管是手指拖动还是离开屏幕， UIEvent 对象就会生成，而它由包含相关的 UITouch 对象。入参说明：</p>
<ul>
<li>touches。这个状态新的或改变的 touches 。</li>
<li>event。代表这个事件 event 的所有 touches ，所以上面的 touches 也属于它。<code>This differs from the set of touches because some of the touch objects in the event may not have changed since the previous event message.</code> 它跟上面的 touches 的区别就在于它可能包含发生改变的 touch 。强调一个状态的改变。</li>
</ul>
<p>###管理响应链的方法<br>####nextResponder<br><code>Returns the receiver&#39;s next responder, or nil if it has none.</code> 接受者的下一个响应者，如果没有的话就为 nil。nextResponder 就是响应链中下一个处理事件的对象。</p>
<p>UIResponder 类不会自动存储 nextResponder，所以默认返回 nil。子类化的时候需要重载该方法自己设置。一般情况下，UIView 一般返回它所在的 UIViewController 或者它的 superview；而 UIViewController 返回它 view 的 superview 或者 UIViewController (会一直循环找，直到找到 UIWindow -&gt; UIApplication)；UIWindow 返回 UIApplication；UIApplication 返回 nil。所以，响应链在视图层级构建的时候就已经形成了。</p>
<p>####isFirstResponder<br><code>Returns a Boolean value indicating whether the receiver is the first responder.</code> 是否是第一响应者。默认为 YES。</p>
<p>####canBecomeFirstResponder<br><code>Returns a Boolean value indicating whether the receiver can become first responder.</code> 是否能够成为第一响应者。默认为 NO。</p>
<p>如果返回 YES ，就说明它能够成为第一响应者，<code>it becomes the first responder and can receive touch events and action messages. </code>能够接受触摸事件和动作消息。子类如果想要成为第一响应者，那么必须重载这个方法。注意，你只有当 view 已经添加到 view 层级里面才能发送这个消息(becomeFirstResponder)，不然这个结果是不确定的，例子如下:</p>
<p><code>Note: Make sure that your app has established its object graph before assigning an object to be the first responder. For example, you typically call the becomeFirstResponder method in an override of the viewDidAppear: method. If you try to assign the first responder in viewWillAppear:, your object graph is not yet established, so the becomeFirstResponder method returns NO.</code><br>注意：在一个对象成为 first repsonder 之前要确保建立好 object graph。例如，你通常在 viewDidAppear: 方法里面调用 becomeFirstResponder。如果 viewWillAppear: 方法里面设置 first responder，这个时候 object graph 还没建立好，所以 becomeFirstResponder 会返回 NO。</p>
<p>####becomeFirstResponder<br><code>Notifies the receiver that it is about to become first responder in its window.</code> 报告接受者它将要在 window 上成为为第一响应者。默认返回 YES。</p>
<p><code>A responder object only becomes the first responder if the current responder can resign first-responder status (canResignFirstResponder) and the new responder can become first responder.</code> 只有当前的响应者能够辞去第一响应者，新的响应者才能够成为第一响应者。也就是说第一响应者永远只有一个。</p>
<p><code>If the view’s window property holds a UIWindow object, it has been installed in a view hierarchy;if it returns nil, the view is detached from any hierarchy.</code>     view 的 window 属性持有 UIWindow 对象时才表示这个 view 已经添加到 view 层级中。也就说只有 view 层级确定成功后才能成为第一响应者。</p>
<p>####canResignFirstResponder<br><code>Returns a Boolean value indicating whether the receiver is willing to relinquish first-responder status.</code> 是否能够将要放弃作为第一响应者的状态。默认为 YES。</p>
<p><code>As an example, a text field in the middle of editing might want to implement this method to return NO to keep itself active during editing.</code> 例如，编辑中的文本输入框可能想实现这个方法返回 NO 来保持自己的编辑状态（不过，这种情况目前还没有遇到过。）。</p>
<p>####resignFirstResponder<br><code>Notifies the receiver that it has been asked to relinquish its status as first responder in its window.</code>通知接受者它被询问是否放弃在 window 上作为第一响应者的状态。 默认为 YES。  注意：子类重载该方法的时候，必须实现父类的方法。</p>
<p>####简单实例<br>点击某个 view 出现 copy 等菜单的 UIMenuController 时，我们会重载 canBecomeFirstResponder 方法并返回 YES；</p>
<p>##UIApplication<br><code>A major role of your app’s application object is to handle the initial routing of incoming user events. It dispatches action messages forwarded to it by control objects (instances of the UIControl class) to appropriate target objects.</code> application 主要的职责是处理用户事件。</p>
<p><code>sendEvent:</code><br>分发一个消息给合适的响应者对象。你可以子类 UIApplication 对象并且重载这个方法来拦截事件。但是拦截完后记得调用父类的实现 [super sendEvent:event]。</p>
<p><code>sendAction:to:from:forEvent:</code><br>转发消息给特定的对象。<br>target：接受消息的对象，如果为 nil，那么 APP 会发送给第一响应者，然后沿着响应链传递。<br>sender：发送 action 消息的对象。默认的 sender 是 UIControl 对象。</p>
<p>##UIControl<br><code>The UIControl class implements common behavior for visual elements that convey a specific action or intention in response to user interactions.</code> UIControl 为响应用户的交互而对那些可见的元素实现了共同的行为，其实也是事件的高级处理。它使用来 Target-Action 机制向 APP 报告用户的交互。</p>
<p>UIControl 由 UIControlState 类型的属性 state 决定它的外观和支持用户交互的能力。</p>
<p><code>The control handles all the work of tracking incoming touch events and determining when to call your methods.</code>处理所有的跟踪将要来的触摸事件的工作，并且决定什么时候调用你的方法。通过 addTarget:action:forControlEvents: 方法添加 target 和 action ，target 可以为任何对象，一般是包含 control 的 view controller，如果 target 为 nil，那么控件会通过响应链查找定义了该方法的响应者。</p>
<p><code>The control maintains a list of its attached targets and actions along and the events each supports.</code>里面维持了一个数组来存储它的 target、action 已经所支持的事件。control 不会 retain target。可以参考<a href="https://github.com/nst/iOS-Runtime-Headers/blob/master/Frameworks/UIKit.framework/UIControl.h#L28">iOS-Runtime-Headers _targetActions数组</a></p>
<p>用 Xcode 在 UIControl 的响应事件里面断点可以看到 _targetActions 数组<br><img src="http://ww2.sinaimg.cn/mw690/005IevIrjw1fbr6dodpgmj31p80pawqm.jpg" alt="Xcode lldb for _targetActions"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendActionsForControlEvents:</span><br></pre></td></tr></table></figure>
<p><code>This method iterates over the control’s registered targets and action methods and calls the sendAction:to:forEvent: method for each one that is associated with an event in the controlEvents parameter.</code> 从 <code>iterates</code> 可以看出 UIControl 里面是维持了一个数组。</p>
<p>响应方法有三种形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (IBAction)doSomething;</span><br><span class="line">- (IBAction)doSomething:(id)sender;</span><br><span class="line">- (IBAction)doSomething:(id)sender forEvent:(UIEvent*)event; &#x2F;&#x2F; sender就是调用这个方法的对象，一般就是control自己；而event就是触发这个control的相关事件</span><br></pre></td></tr></table></figure>
<p>根据 UIControlEvents 来指定用户交互的特定形式，例如：UIButton 就是 UIControlEventTouchDown 或者 UIControlEventTouchUpInside 触发 action 方法，而 UISlider，则是 UIControlEventValueChanged。<br><code>When a control-specific event occurs, the control calls any associated action methods right away. Action methods are dispatched through the current UIApplication object, which finds an appropriate object to handle the message, following the responder chain if needed. For more information about responders and the responder chain, see Event Handling Guide for iOS.</code> 当一个特定的事件发生时，control 就正确的调用相关的 action 方法。通过 UIApplication 对象（它能够找到相应的对象来处理消息）来分发 action 方法，如果需要的话，则通过响应链来找到。</p>
<p>子类化 UIControl 使你能够简单支持事件处理。用下面两种方法中的一种来改变它的行为。</p>
<ul>
<li>重载 sendAction:to:forEvent: 方法，观察或者修改分发 action 方法到相关的 target；</li>
<li>重载 beginTrackingWithTouch:withEvent:, continueTrackingWithTouch:withEvent:, endTrackingWithTouch:withEvent:, cancelTrackingWithEvent: 方法当事件发生时，跟踪它们。用这些方法代替 UIResponder 定义的 touchXxx:withEvent: 方法；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendAction:to:forEvent:</span><br></pre></td></tr></table></figure>
<p>调用一个特定的方法。这个方法带着提供的信息并且将它转发给单例 UIApplication 去分发。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beginTrackingWithTouch:withEvent: </span><br></pre></td></tr></table></figure>
<p>当 touch 事件发生在控件里面时会调用这个方法。</p>
<p>#Target-Action<br><code>Target-action is a design pattern in which an object holds the information necessary to send a message to another object when an event occurs.</code> Target-action<br> 是一种设计模式，当某个事件发生时，持有信息的对象发送消息给另外一个对象。持有的信息包括接受消息的对象以及消息。</p>
<p><img src="https://developer.apple.com/library/content/documentation/General/Conceptual/Devpedia-CocoaApp/Art/target_action.jpg" alt="Apple Target-Action"></p>
<p>上面图片所表示的可以用下面的代码表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; viewcontroller</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    UIControl *control &#x3D; [[UIControl alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];</span><br><span class="line">    [control addTarget:self action:@selector(restoreDefaults:) forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">    [self.view addSubview:control];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)restoreDefaults:(id)sender &#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即 UIControlEventTouchUpInside 类型的事件发生时，事件会传递到 control 对象，然后由 control 去触发 target 的 action 行为。UIGestureRecognizer 也是类似的。</p>
<p>#Gesture Recognizers<br>上面有提到 <code>Gesture recognizers convert low-level event handling code into higher-level actions.</code> </p>
<p><code>UIGestureRecognizer is an abstract base class for concrete gesture-recognizer classes.</code> </p>
<p><code>A gesture recognizer doesn’t participate in the view’s responder chain.</code> 尽管它是添加在 view 上的，但是它不参与 view 的响应链。</p>
<p>那来看看 Gesture Recognizers 是怎么个高级法？ 当它添加到 view 上时，它能够让 view 像 control 一样响应特定的事件。</p>
<p><img src="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/gestureRecognizer_2x.png" alt="Apple A gesture recognizer attached to a view"></p>
<p>##内置手势以及其用法<br>系统已经帮我们内置几个非常实用的手势：</p>
<ul>
<li>UITapGestureRecognizer:Tapping (any number of taps)。点击手势，例如：单击、双击、三击。</li>
<li>UIPinchGestureRecognizer:Pinching in and out (for zooming a view)。缩放手势，例如：相册放大缩小。</li>
<li>UIPanGestureRecognizer:Panning or dragging。拖拽手势，例如：scrollview 的拖动滚动。</li>
<li>UISwipeGestureRecognizer:Swiping (in any direction)。滑动手势，例如：浏览相册。</li>
<li>UIRotationGestureRecognizer:Rotating (fingers moving in opposite directions)。旋转手势，例如：两个手指旋转相册的照片。</li>
<li>UILongPressGestureRecognizer:Long press (also known as “touch and hold”)。长按手势，例如：朋友圈长按文本出现复制等菜单。</li>
<li>UIScreenEdgePanGestureRecognizer: swipe up from the bottom of the screen to reveal Control Center。从屏幕下面从下往上滑动，出现控制中心。</li>
</ul>
<p>每个 gesture recognizer 都跟一个 view 相关联，所以它得添加到 view 上。一个 view 可以有多个 gesture recognizer，通过<code>gestureRecognizers</code>属性来获取。</p>
<p><code>When a user touches that view, the gesture recognizer receives a message that a touch occurred before the view object does. As a result, the gesture recognizer can respond to touches on behalf of the view.</code> 当用户触摸 view 的时候，gesture recognizer 会在 view（靠 <code>touchBegan、moved、ended、cancelled:withEvent:</code>这几个方法来处理 touch 事件）之前收到这个 touch 事件。所以 gesture recognizer 能够代表 view 来响应这个 touch。</p>
<p>gesture recognizer 分为离散的和连续的。从下图可以看出，离散的只会发送一次<code>action message</code>给 target ，而连续的则会发送多次直到这个触摸队列完成。</p>
<p><img src="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/discrete_vs_continuous_2x.png" alt="Apple Discrete and continuous gestures"></p>
<ul>
<li>离散的有：UITapGestureRecognizer、UISwipeGestureRecognizer；</li>
<li>连续的有：UIPinchGestureRecognizer、UIPanGestureRecognizer、UIRotationGestureRecognizer、UILongPressGestureRecognizer；</li>
</ul>
<p>使用手势的方法也很简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">     [super viewDidLoad];</span><br><span class="line"> </span><br><span class="line">     &#x2F;&#x2F; Create and initialize a tap gesture</span><br><span class="line">     UITapGestureRecognizer *tapRecognizer &#x3D; [[UITapGestureRecognizer alloc]</span><br><span class="line">          initWithTarget:self action:@selector(respondToTapGesture:)];</span><br><span class="line"> </span><br><span class="line">     &#x2F;&#x2F; Specify that the gesture must be a single tap</span><br><span class="line">     tapRecognizer.numberOfTapsRequired &#x3D; 1;</span><br><span class="line"> </span><br><span class="line">     &#x2F;&#x2F; Add the tap gesture recognizer to the view</span><br><span class="line">     [self.view addGestureRecognizer:tapRecognizer];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; Respond to a rotation gesture 离散的手势需要在响应方法里面判断它的状态</span><br><span class="line">- (IBAction)showGestureForRotationRecognizer:(UIRotationGestureRecognizer *)recognizer &#123;</span><br><span class="line">	if (([recognizer state] &#x3D;&#x3D; UIGestureRecognizerStateEnded) || ([recognizer state] &#x3D;&#x3D; UIGestureRecognizerStateCancelled)) &#123;</span><br><span class="line">        [UIView animateWithDuration:0.5 animations:^&#123;</span><br><span class="line">            self.imageView.alpha &#x3D; 0.0;</span><br><span class="line">            self.imageView.transform &#x3D; CGAffineTransformIdentity;</span><br><span class="line">        &#125;];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>##了解 gesture recognizer 的交互<br>###gesture recognizer 的状态<br>gesture recognizer 可以从一个状态变换到另外一个状态。</p>
<p><img src="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/gr_state_transitions_2x.png" alt="Apple State machines for gesture recognizers"></p>
<p>根据某种特定的条件，状态是会变的。离散手势和连续手势的机制不同。<br>离散手势直接从 Possible -&gt; Failed or Recognized。注意，Ended 是 Recognized 的别名，其实这两个状态都代表手势结束了。</p>
<p>只要 gesture recognizer 改变它的状态，它就会给 target 发送 action message ，除非它的状态变为 Failed  或者 Canceled 。所以，离散的手势就会当状态从 Possible -&gt; Recognized 的时候发送一次 action message 。而 连续手势会发送多次。当 gesture recognizer 到达 Recognized 状态的时候，它会 reset 重置到 Possible 状态（到这个状态不会发送 action message ）。（在后面提到的，自定义手势的时候，置为 Recognized 的时候也要手动 reset 重置，将该 gesture recognizer 的一些属性啥的都置为初始状态。）注意：变为 Failed 或者 Canceled 是不会发送消息的。</p>
<p>###与其他手势的交互<br>一个 view 可以有多个 gesture recognizer 。通过 gestureRecognizers 属性可以知道该它有多少个 gesture recognizer 。当然也可以通过 addGestureRecognizer: 和 removeGestureRecognizer: 方法添加、移除某个 gesture recognizer。那么问题来了，如果有多个 gesture recognizers 的话，怎么处理这些事件，它们之间会存在着竞争关系。</p>
<p><code>When a view has multiple gesture recognizers attached to it, you may want to alter how the competing gesture recognizers receive and analyze touch events. By default, there is no set order for which gesture recognizers receive a touch first, and for this reason touches can be passed to gesture recognizers in a different order each time. </code>  如果一个 view 上有多个 gesture recognizer 时，你可能想改变这些竞争手势如何接受和处理触摸事件的。默认情况下，这些手势谁第一个接受到 touch 是无序的，所以手势可能每次都发生在不同的顺序。所以，我们可以用 delegate 和子类化来处理改变这些行为。</p>
<ul>
<li>Specify that one gesture recognizer should analyze a touch before another gesture recognizer. (指定某个手势发生在另外一个手势前面)</li>
<li>Allow two gesture recognizers to operate simultaneously(允许两个手势同时发生).</li>
<li>Prevent a gesture recognizer from analyzing a touch(防止某个手势发生).</li>
</ul>
<p>####指定两个手势的触发顺序<br>通过下面的相关代理指定某个手势识别的时候另外一个手势识别失败。</p>
<ul>
<li>requireGestureRecognizerToFail:  方法 iOS7之前的处理方式</li>
<li>gestureRecognizer:shouldRequireFailureOfGestureRecognizer: 代理方法</li>
<li>gestureRecognizer:shouldBeRequiredToFailByGestureRecognizer: 代理方法</li>
</ul>
<p>####防止某个分析触摸事件<br>手势的处理使用是<code>analyze</code>分析到<code>handle</code>处理。这个比上面更吊，根本就不让分析触摸事件。通过下面两个代理方法来完成。</p>
<ul>
<li>gestureRecognizer:shouldReceiveTouch: (触发的时候才会走这个代理，有一个新 touch 也会走。默认为 YES。如果为 NO，当一个 touch 发生的时候，该手势就不会被通知。这个方法不会改变手势的状态。)</li>
<li>gestureRecognizerShouldBegin: (走出 Possible 状态后才能知道，所以它的发生时间比上个方法要晚。如果 UIView 或者 UIControl 的子类需要处理自定义的事件处理时，而需要与某个手势竞争时。该方法返回 NO ，使手势的状态马上变为 fail，使其他触摸处理事件去执行。)</li>
</ul>
<p>####允许同时发生<br>是两个手势同时发生。按道理两个手势是不能同时响应的，但是有的时候你希望 pinch 和 rotate 手势同时发生，可以使用下面的代理方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gestureRecognizer:shouldRecognizeSimultaneouslyWithGestureRecognizer: </span><br></pre></td></tr></table></figure>
<p><code>Note:You need to implement a delegate and return YES on only one of your gesture recognizers to allow simultaneous recognition. However, that also means that returning NO doesn’t necessarily prevent simultaneous recognition because the other gesture recognizer&#39;s delegate could return YES.</code> 注意：实现一个代理，让它返回 YES，就能够允许同时发生。当然它也意味着返回 NO 不能防止它不同时发生，因为很有可能其他的代理返回 YES。</p>
<p>####指定两个手势间的单程关系<br>子类重载<code>canPreventGestureRecognizer:</code>或者<code>canBePreventedByGestureRecognizer:</code>方法返回 NO 来处理。默认返回 YES。<br>例如，rotation 能够防止 pinch，而 pinch 不能防止 rotation，就可以用下面的代理来处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[rotationGestureRecognizer canPreventGestureRecognizer:pinchGestureRecognizer];</span><br></pre></td></tr></table></figure>
<p>或者重载 rotation 手势的方法返回 NO。</p>
<p>###与其他控件交互<br><code>In iOS 6.0 and later, default control actions prevent overlapping gesture recognizer behavior.</code>iOS6 以后，默认的 control actions 控制会阻止覆盖手势行为。例如，按钮的事件就是一个 tap 手势。如果你在按钮的父视图上添加了一个手势，那么当用户点击按钮的时候，按钮会收到响应触摸事件，它的父视图不会响应。当然这仅仅作用于默认有<code>control action</code>的手势识别上，它还包括：</p>
<ul>
<li>tap 手势在 UIButton，UISwitch，UIStepper，UISegmentControl，UIPageControl；</li>
<li>swipe 手势在 UISlider；</li>
<li>pan 手势在 UISwitch；</li>
</ul>
<p>当你想要重载 control 默认的 action，在 control 上面添加手势时，手势第一次收到触摸事件。但是你得注意了，需要去看看<code>iOS Human Interface Guidelines</code>以确保能够为用户提供直觉的体验(这样做是不推荐的，记得看<code>view programming</code>的时候看到不推荐在 UIButton 上面手势等之类的事件)。</p>
<p>##手势处理原生的触摸事件<br>那么手势是怎样处理一个 view 的触摸事件呢？我们先了解 touches 和 events 的术语。</p>
<p>###event 包括所有在当前触摸队列里面的 touches<br>UIEvent 和 UITouch 在前面已经讲了。这里的<code>Multitouch Sequence</code>触摸队列是指从手指触摸屏幕开始到最后手指离开屏幕结束。还有需要注意的是，手指的精确性比鼠标要低。并且它的触摸区域是椭圆形的，比用户期望的要差。它还受手指的大小、方向、压力、哪根手指以及其他因素的影响。</p>
<p>###APP 接受触摸事件都是在 Touch-Handling Methods<br>前面讲 UIResponder 的时候，已经提到，在触摸队列中，当某个 touch phase 有新的或改变的 touch 发生时，APP 就会通过下面的方法发送消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;  </span><br><span class="line">- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event; </span><br><span class="line">- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event; </span><br><span class="line">- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event; </span><br></pre></td></tr></table></figure>
<p>每个方法都对应一个 touch phase。例如，touchesBegan:withEvent: 对应着 UITouchPhaseBegan。注意：这些方法跟 gesture recognizer 状态（例如：UIGestureRecognizerStateBegan）没有关系。</p>
<p>##控制 touch 传递到 view<br>你有多少次想 view 在 gesture recognizer 之前收到 touch 。<br>view 的 touch 分发是从 UIApplication -&gt; UIWindow 。然后 window 在发送 touch 到 view 之前，会先发给 view （或者它 superView 上）的 gesture recognizers。</p>
<p><img src="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/path_of_touches_2x.png" alt="Apple Default delivery path for touch events"></p>
<p>###手势首先识别 touch<br><code>A window delays the delivery of touch objects to the view so that the gesture recognizer can analyze the touch first.</code> window 会延迟传递 touch 对象到 view，所以手势能够最先识别这个 touch。如果手势识别了这个触摸事件，那么 window 不会分发剩下到 view 上，并且还会取消之前发送出去的触摸事件。</p>
<p>例如，有一个离散的手势需要两根手指，所以有两个 touch 对象，传递流程如下图所示。</p>
<p><img src="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/recognize_touch_2x.png" alt="Apple Sequence of messages for touches"></p>
<ul>
<li>The window sends two touch objects in the Began phase—through the touchesBegan:withEvent: method—to the gesture recognizer. The gesture recognizer doesn’t recognize the gesture yet, so its state is Possible. The window sends these same touches to the view that the gesture recognizer is attached to.</li>
<li>The window sends two touch objects in the Moved phase—through the touchesMoved:withEvent: method—to the gesture recognizer. The recognizer still doesn’t detect the gesture, and is still in state Possible. The window then sends these touches to the attached view.</li>
<li>The window sends one touch object in the Ended phase—through the touchesEnded:withEvent: method—to the gesture recognizer. This touch object doesn’t yield enough information for the gesture, but the window withholds the object from the attached view.</li>
<li>The window sends the other touch object in the Ended phase. The gesture recognizer now recognizes its gesture, so it sets its state to Recognized. Just before the first action message is sent, the view calls the touchesCancelled:withEvent: method to invalidate the touch objects previously sent in the Began and Moved phases. The touches in the Ended phase are canceled.</li>
</ul>
<p>假如最后一步，gesture recognizer 还没有识别到，那么它的状态就变成 failed，然后 window 就会将那两个 touch 对象通过 touchesEnded:withEvent: 消息传递给它所附属的 view。</p>
<p>连续的 gesture recognizer 跟上面的行为差不多，除了它可能在 Ended phase 之前就已经识别到那个手势了。一旦识别到手势，它就会变成 Began 状态。window 就会把触摸队列中剩下的 touch 对象都发送给这个 gesture recognizer，而不是它所附属的 view。</p>
<p>###响应 touch 传递到 view<br>所以我们可以改变一些 gesture recognizer 的属性来改变默认的事件分发路径。可以参考上面离散两个手指的例子来理解下面的属性。</p>
<ul>
<li><p>cancelsTouchesInView:默认为 YES。当 gesture recognizer 识别到手势后，window 不会分发它们给 view。并且 window 会通过 touchesCancelled:withEvent: 方法来取消之前传递的 touch。如果 gesture recognizer 没有识别到，那么 view 会收到触摸队列里面所有的 touch。</p>
</li>
<li><p>delaysTouchesBegan: 默认为 NO。正常情况下，window 发送 began 和 moved 状态的 touch 给 view 和 gesture recognizer。将它置为 YES，防止 window 发送 Began phase 给这个 view。这能够保证当 gesture recognizer 识别到 touch 时，没有任何 touch 事件分发到这个它附属的 view 上。小心设置这个属性，因为它会使你界面感觉没有响应。这个属性跟 UIScrollView 的 delaysContentTouches 属性类似。当手指触摸滚动开始后，scrollview 的所有 subview 不会接受 touch 事件，所以没有闪光的视觉反馈。</p>
</li>
<li><p>delaysTouchesEnded:默认为 YES。当它为 YES 时，它能保证 view 不会马上完成一个动作，因为 gesture recognizer 后面可能会想要取消。当 gesture recognizer 正在分析一个 touch 事件时，window 不会分发 Ended phase 状态的 touch 给所它附属的view。如果 gesture recognizer 识别到了，那么 touch 将会被取消（即不会分发给 view）。如果 gesture recognizer 识别不到，那么 window 会通过 touchesEnded:withEvent: 消息分发这些 touch 对象给 view。设置它为 NO 时，允许 view 和 gesture recognizer 同时在 Ended phase 分析这些 touch 对象。 例如，当一个 view 有一个双击手势时。delaysTouchesEnded 为 YES，这个 view 收到 touchesBegan:withEvent:, touchesBegan:withEvent:, touchesCancelled:withEvent:, and touchesCancelled:withEvent: 的消息。当它为 NO 时，它会收到 touchesBegan:withEvent:, touchesEnded:withEvent:, touchesBegan:withEvent:, and touchesCancelled:withEvent:，这就意味着在 touchesBegan:withEvent: 时，就能识别它是 double tap（实际情况，应该是在 End 才识别到，Apple 自定义模拟处理单击手势时就是在 touchesEnded:withEvent: 方法里面处理的）。</p>
</li>
</ul>
<p>如果 gesture recognizer 检测到一个 touch 不属于它，它能够直接传递给它的 view。通过 gesture recognizer 调用 ignoreTouch:forEvent: 方法，将这个 touch 传递。（问题：难道如果 gesture recognizer 处理不了，window 就不会将它传递给它所附加的 view 吗？view 是能够接受到 touch 的，gesture recognizer 只是一个高级的封装，所以 window 会传下去。）</p>
<p>##自定义手势<br>自定义手势需要创建 UIGestureRecognizer 的子类。需要引入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit&#x2F;UIGestureRecognizerSubclass.h&gt;</span><br></pre></td></tr></table></figure>
<p>通过实现下面的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)reset;</span><br><span class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;</span><br><span class="line">- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;</span><br><span class="line">- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;</span><br><span class="line">- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;</span><br></pre></td></tr></table></figure>
<p>它的签名和 UIResponder 的那个四个方法签名一样。你重载这些方法的时候，必须调用父类的实现，即使它是个空的实现。重要的是在这些方法里面改变 status 属性的值，并且在 reset 方法里面将一些值置为初始值（因为 gesture recognizer 转成 Recognized/Ended, Canceled, or Failed 时，reset 方法在变成 Possible 状态前会被调用）。</p>
<p>官方文档 <a href="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/GestureRecognizer_basics/GestureRecognizer_basics.html#//apple_ref/doc/uid/TP40009541-CH2-SW2">Listing 1-8  Implementation of a checkmark gesture recognizer</a> 有实现一个自定义的手势，这里就不贴代码了。还可以看看<a href="https://github.com/ibireme/YYKit/blob/master/YYKit/Utility/YYGestureRecognizer.m">YYGestureRecognizer</a>。</p>
<p>#事件的传递<br>我们想动态的响应事件。例如：一个 touch 可以出现在屏幕上的不同对象上，你必须去决定你想要哪个对象去响应这个事件，理解这些对象怎样接受这个事件。</p>
<p>当用户的触摸事件发生时，UIKit 创建一个事件对象，它包含了需要处理这个事件的一些信息。然后它将这个事件对象放在 App 的 event queue 里面（这里就跟 runloop 有关系了）。对于 touch 触摸事件，这个事件对象就是在 UIEvent 对象。对于 motion 事件，这个事件对象就取决于你使用的是哪个 framework 和哪种你感兴趣的 motion 事件了。</p>
<p>一个事件会以一条特定的路线去传递，直到它找到可以处理它某个对象为止。首先，UIApplication 从系统队列的顶层取出一个事件并分发它。通常，这个事件会被发送给 key window，key window 会将它发送给 initial object 去处理。initial object 取决于事件类型。</p>
<ul>
<li>Touch events. window 第一次尝试将事件发送给 touch 发生的那个 view 。这个 view 就是所谓的 hit-test view。找 hit-test view 的过程被称为 hit-testing。(它的寻找顺序是从下至上，而响应链则是从上至下，下面会提到，最下面的是 application，最上面的就是 initial object)</li>
<li>Motion and remote control events. window 发送 shaking-motioin 或者 control event 给 frist responder 去处理。即第一响应者。</li>
</ul>
<p>这些事件路径的最终目标就是找到一个能够处理响应这个事件的对象。所以，UIKit 第一次会将它发送给最适合来处理它的对象。就是上面提到的 hit test view 或者 first responder。</p>
<p>##Hit-Testing 返回 touch 发生的那个 view<br>iOS 用 hit-testing 去寻找 touch 下面的那个 view。hit-testing 会检测 touch 是否在相关 view 的 bounds （这里是 bounds，而不是 frame）里面。如果是，会循环检查这个 view 的所有 subviews。view 层级最低（也就是是最上面那个 subview）的包含这个 touch point 的就是 hit-test view。然后 iOS 会将这个 touch 事件交给这个 view 去处理。这里有张 hit-testing 的经典图。它会从 window 开始从下往上开始寻找。</p>
<p><img src="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/hit_testing_2x.png" alt="Apple Hit-testing returns the subview that was touched"></p>
<p>hitTest:withEvent: 方法根据给定的入参 CGPoint 和 UIEvent 返回 hit test view。在调用 hitTest:withEvent: 方法之前会先调用 pointInside:withEvent: 方法。如果传到 hitTest:withEvent: 的 point 在这个 view 的 bounds 里面，那么 pointInside:withEvent: 返回 YES。然后，会循环的在每个返回 YES 的 subview 上调用 hitTest:withEvent: 方法。</p>
<p>如果传进去的 point 不在 view 的 bounds里面，那么第一次调用 pointInside:withEvent: 会返回 NO，这个 point 会被忽略掉，hitTest:withEvent: 返回 nil。如果某个 subview 返回 NO，那么它这个 view 的整个层级都是被忽略掉的，因为既然它都不会出现在 subview 上，那么自然不会出现在 subview 的 subview 上面嘛。这就意味在一个 subview 上的任何点，它如果在 superview 之外，是接受不到触摸事件的。当 subview  clipsToBounds 属性为 NO （允许 subview 超过 superview 的边界）时，这个事情会发生。</p>
<p><code>Note: A touch object is associated with its hit-test view for its lifetime, even if the touch later moves outside the view.</code><br>注意，一个 touch 对象在 hit-test view 的生命周期内都跟它关联的，即使这个 touch 后面移动到它外面。</p>
<p>hit-test view 给了第一次去处理这个触摸事件的机会。如果 hit-test view 处理不了，那么它会沿着响应链向 application 的方向去寻找可以处理它的对象。</p>
<p>##响应链由响应对象组成<br>许多类型的事件都依赖响应链去分发。响应链是由一系列相连接的响应对象组成（在 view 的层级确定后，响应链就连接完成了）。它由 first responder 开始，application object 结束（它的传递顺序是从上至下的）。如果 frist responder 不能处理这个事件，那么会在响应链里将这个事件向前转发。一个响应对象它能够响应处理事件，UIResponder 就是它的基类（上面有提到过）。像 UIApplication, UIViewController, 和 UIView 都是 responders，但是注意，Core Animation layers 不是。</p>
<p>first responder 指定首先收到事件。通常，first responder 是一个 view。关于 UIResponder，可以看上面的相应内容。</p>
<p>Events不是依赖响应链的唯一对象。响应链还用于以下：</p>
<ul>
<li>Touch events. 如果 hit-test view 不能处理 touch event，那么会由 hit-test view 开始走响应链。</li>
<li>Motion events. </li>
<li>Remote control events. </li>
<li>Action messages. 当用户操作一个 control，例如 button 或者 switch，并且 target 的 action method 为 nil，message 通过响应链从 frist responder 开始传递，也可以是这个 control view 自己。</li>
<li>Editing-menu messages. cut: copy: paste: 等等。 <a href="https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/AddingCustomEditMenuItems/AddingCustomEditMenuItems.html#//apple_ref/doc/uid/TP40009542-CH13">Displaying and Managing the Edit Menu</a></li>
<li>Text editing. 自定义输入内容，应该有自定义键盘的例子。 <a href="https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/InputViews/InputViews.html#//apple_ref/doc/uid/TP40009542-CH12">Custom Views for Data Input</a></li>
</ul>
<p>##响应链的分发路径<br>如果 initial object（hit-test view 或者 the first responder，它通常是个 view）处理不了这个事件，UIKit 会在响应链中将它传递给 next responder。每个响应对象决定它是否处理这个事件，还是通过调用<code>nextResponder</code>传递下去。<br>这个过程持续到 app object，如果 app object 都处理不了，那么就丢弃掉这个事件。</p>
<p><img src="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/iOS_responder_chain_2x.png" alt="Apple  The responder chain on iOS"></p>
<p><code>Important: If you implement a custom view to handle remote control events, action messages, shake-motion events with UIKit, or editing-menu messages, don’t forward the event or message to nextResponder directly to send it up the responder chain. Instead, invoke the superclass implementation of the current event handling method and let UIKit handle the traversal of the responder chain for you.</code></p>
<p>重要：不要直接调用 nextResponder 方法，而应该调用父类当前事件处理的实现，让 UIKit 来处理。</p>
<p>#自定义处理事件<br>通常情况下，我们能够用 UIKit 里面标准的 control 和 gesture recognizers 来处理几乎所有的触摸事件了。当然有些情况，我们需要自定义，也就是上面所提及的高层和低级的问题。</p>
<p>##创建 UIResponder 的子类<br>首先就是要创建 UIResponder 的子类，也可以是 UIView、UIViewController、UIControl、UIApplication、UIWindow 的子类，不过子类化 UIApplication、UIWindow 比较罕见，一般都是继承 UIView、UIControl。</p>
<p>然后还有3件事需要处理</p>
<ul>
<li>实现 touchXxx:withEvent: 等 Touch-Event Handling 相关方法；</li>
<li>userInteractionEnabled 置为 YES；</li>
<li>它是可见的，不能隐藏或者透明。即 hidden = NO &amp; alpha &gt; 0.01。</li>
</ul>
<p>##实现 Touch-Event Handling 方法<br>在触摸队列中，App 发送一系列的事件消息给目标响应者。为了接受处理这些消息，这个响应者对象必须实现下面的 UIResponder 的事件处理方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event; </span><br><span class="line">- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;</span><br><span class="line">- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;</span><br><span class="line">- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;</span><br></pre></td></tr></table></figure>
<p>每个方法都对应一个 touch 对象的状态，UITouchPhaseBegan，UITouchPhaseMoved，UITouchPhaseEnded，UITouchPhaseCancelled。当有某个状态有新的或者改变的 touch 对象时，App 就会调用上面的相关方法。</p>
<p>入参说明：</p>
<ul>
<li>touches。这个状态新的或改变的 touches。</li>
<li>event。代表这个事件 event 的所有 touches，所以上面的 touches 也属于它。它跟上面的 touches 的区别就在于它可能包含没有发生改变的 touch。强调一个状态的改变。</li>
</ul>
<p>处理触摸事件的所有 view 都希望能够收到完整的事件流，所以在创建你的子类时，要注意</p>
<ul>
<li>If your custom responder is a subclass of UIView or UIViewController, you should implement all of the event handling methods.（view 或者 viewcontroler 要实现所有的事件处理方法）</li>
<li>If you subclass any other responder class, you can have a null implementation for some of the event methods.（其他 responder 类的子类，可以不实现其中某个事件处理方法）</li>
<li>In all methods, be sure to call the superclass implementation of the method.（确保调用父类的实现方法）</li>
</ul>
<p>当然如果事件的某个状态没有接受处理，这会导致后果可能不定义的或者不良的。如果在事件处理的时候创建了恒久的对象，那么在 touchesCancelled:withEvent: 方法里，记得销毁这些对象，即让它们回到原始状态。当有电话打进来时，app 就会调用 touchesCancelled:withEvent: 方法。然后在 touchesEnded:withEvent: 方法里面也要销毁这些东西，回到原始状态，强调一个有始有终。</p>
<p>##具体例子<br>用自定义触摸事件来实现相关 UIGestureRecognizer。这一小节的详细代码可见<a href="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/multitouch_background/multitouch_background.html">Multitouch Events</a><code>Listing 3-1</code>至<code>Listing 3-7</code>。</p>
<p>###处理点击手势<br>用 UITouch 的 tapCount 属性来判断是单击还是双击还是三击。最好是在 touchesEnded:withEvent: 方法里面做判断处理，因为它是用户手指离开 App 时才响应的，要确保它真的是个 tap 手势，而不是拖动啥的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    for (UITouch *aTouch in touches) &#123;</span><br><span class="line">        if (aTouch.tapCount &gt;&#x3D; 2) &#123;</span><br><span class="line">             &#x2F;&#x2F; The view responds to the tap</span><br><span class="line">             [self respondToDoubleTapGesture:aTouch];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###处理滑动和拖动手势<br>####滑动手势<br>从三个角度判断它是否是一个滑动手势</p>
<ul>
<li>Did the user’s finger move far enough?</li>
<li>Did the finger move in a relatively straight line?</li>
<li>Did the finger move quickly enough to call it a swipe?</li>
</ul>
<p>具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#define HORIZ_SWIPE_DRAG_MIN  12</span><br><span class="line">#define VERT_SWIPE_DRAG_MAX    4</span><br><span class="line"> </span><br><span class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    UITouch *aTouch &#x3D; [touches anyObject];</span><br><span class="line">    &#x2F;&#x2F; startTouchPosition is a property</span><br><span class="line">    self.startTouchPosition &#x3D; [aTouch locationInView:self];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    UITouch *aTouch &#x3D; [touches anyObject];</span><br><span class="line">    CGPoint currentTouchPosition &#x3D; [aTouch locationInView:self];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;  Check if direction of touch is horizontal and long enough</span><br><span class="line">    if (fabsf(self.startTouchPosition.x - currentTouchPosition.x) &gt;&#x3D; HORIZ_SWIPE_DRAG_MIN &amp;&amp;</span><br><span class="line">        fabsf(self.startTouchPosition.y - currentTouchPosition.y) &lt;&#x3D; VERT_SWIPE_DRAG_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; If touch appears to be a swipe</span><br><span class="line">        if (self.startTouchPosition.x &lt; currentTouchPosition.x) &#123;</span><br><span class="line">            [self myProcessRightSwipe:touches withEvent:event];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            [self myProcessLeftSwipe:touches withEvent:event];</span><br><span class="line">    &#125;</span><br><span class="line">    self.startTouchPosition &#x3D; CGPointZero;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    self.startTouchPosition &#x3D; CGPointZero;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>####拖动手势<br>简单的一根手指拖动的相关代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    UITouch *aTouch &#x3D; [touches anyObject];</span><br><span class="line">    CGPoint loc &#x3D; [aTouch locationInView:self];</span><br><span class="line">    CGPoint prevloc &#x3D; [aTouch previousLocationInView:self];</span><br><span class="line"> </span><br><span class="line">    CGRect myFrame &#x3D; self.frame;</span><br><span class="line">    float deltaX &#x3D; loc.x - prevloc.x;</span><br><span class="line">    float deltaY &#x3D; loc.y - prevloc.y;</span><br><span class="line">    myFrame.origin.x +&#x3D; deltaX;</span><br><span class="line">    myFrame.origin.y +&#x3D; deltaY;</span><br><span class="line">    [self setFrame:myFrame];</span><br><span class="line">&#125;</span><br><span class="line">- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>###多点触摸<br>taps,drags,swipes 通常都只涉及了一个 touch，比较简单去跟踪。但是处理由多个 touches 组成的触摸事件时，比较有挑战性。需要去记录 touch 的所有相关属性，并且改变它的 state 等等。需要做到两点：</p>
<ul>
<li>Set the view’s multipleTouchEnabled property to YES;将多点触摸属性置为 YES；</li>
<li>Use a Core Foundation dictionary object (CFDictionaryRef) to track the mutations of touches through their phases during the event；用 CFDictionaryRef 来跟着 UITouch，这里用 CFDictionaryRef 而不是 NSDictionary，因为 NSDictionary 会 copy 它的 key。而 UITouch 没有采取 NSCopying 协议。</li>
</ul>
<p>Determining when the last touch in a multitouch sequence has ended，判断 multitouch sequence 里的最后一个 touch 是否结束，可以用下面的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesEnded:(NSSet*)touches withEvent:(UIEvent*)event &#123;</span><br><span class="line">    if ([touches count] &#x3D;&#x3D; [[event touchesForView:self] count]) &#123;</span><br><span class="line">        &#x2F;&#x2F; Last finger has lifted</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>###指定自定义的触摸事件行为<br>通过改变一些属性去改变事件流的处理。</p>
<p>####多个 touch 的分发传递（multipleTouchEnabled）<br>Turn on delivery of multiple touches. 默认值为NO，意味着只会接受触摸队列里面的第一个 touch，其他的会忽略掉。所以，<code>[touches anyObject]</code>方法就只会返回一个对象。将属性 multipleTouchEnabled 设为 YES，则可以处理多个 touches。</p>
<p>####限制事件只分发给一个 view（exclusiveTouch）<br>Restrict event delivery to a single view. 即只有一个 view 响应事件。默认情况下，view 的 exclusiveTouch 属性为 NO，这就意味着，一个 view 不会阻塞 window里的其他 view 去接受事件。如果将某个 view 的 exclusiveTouch 设为 YES，那么当它接受 touches 时，只会有它一个接收 touches 。这里举例说明了 exclusiveTouch 属性，A、B、C 3个 view 多点触摸的例子。</p>
<p><img src="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/exclusive_touch_view_2x.png" alt="Apple Restricting event delivery with an exclusive-touch view"></p>
<p><code>If the user touches inside A, it recognizes the touch. But if a user holds one finger inside view B and also touches inside view A, then view A does not receive the touch because it was not the only view tracking touches. Similarly, if a user holds one finger inside view A and also touches inside view B, then view B does not receive the touch because view A is the only view tracking touches. At any time, the user can still touch both B and C, and those views can track their touches simultaneously.</code></p>
<p>exclusiveTouch 这个属性比较傲娇，只有当设置它的为 YES 的 view 首先收到触摸事件时，它才能响应。</p>
<p>####限制事件分发到 subviews 上 （hitTest:withEvent:）<br>Restrict event delivery to subviews. 重载 hitTest:withEvent: 方法返回自己 self。</p>
<p>####关闭事件的分发</p>
<ul>
<li>userInteractionEnabled 属性置为 NO；</li>
<li>hidden 属性置为 NO；</li>
<li>alpha 属性值 &lt;= 0.01；</li>
</ul>
<p>####阶段性的关闭事件的分发<br>beginIgnoringInteractionEvents 方法关闭，endIgnoringInteractionEvents 方法开启。这个方法是 UIApplication 的，所以能做一些全局性的事情。</p>
<p>###触摸事件的转发<br>你可以将一个事件转发给另外一个响应对象（响应链就是这样玩的嘛），当你使用这个技术的时候得小心，因为 UIKit 没有设计去接受不属于它们的事件。所以，你不要转发给 UIKit 框架的对象。如果你想要有条件的去转发事件给其他响应对象时，那么这些对象应该是 UIView 的实例，并且这些对象关心事件的转发，并且能够处理这些事件。原因如下：</p>
<p><code>For a responder object to handle a touch, the touch’s view property must hold a reference to the responder.</code> 一个 responder 对象想要处理一个 touch ，那么 touch 的 view 属性必须持有这个 responder。</p>
<p>事件的转发经常需要去分析 touch 对象觉得它是否应该转发事件。这里有一些方法你可以采取去分析：</p>
<ul>
<li>With an “overlay” view, such as a common superview, use hit-testing to intercept events for analysis prior to forwarding them to subviews.（使用 overlay view，例如公用的父视图，在转发到 subviews 之前拦截事件去分析）</li>
<li>Override sendEvent: in a custom subclass of UIWindow, analyze touches, and forward them to the appropriate responders.（UIWindow 的子类重载 sendEvent: 方法，将事件转发到合适的 responders）</li>
</ul>
<p>重载 sendEvent: 方法可以监听 App 事件的接收。UIApplication 和 UIWindow 都是用这个方法来分发事件的，所以它就是事件进入 App 的管道一样。当你重载的时候，务必调用父类的实现，[super sendEvent:event]。在 control 和 gesture recognizer 的响应事件里面打断点，可以看到，事件走的 UIKit 开始传递都是先走的，[UIApplication sendEvent:]、[UIWindow sendEvent:]，最终都是走的 [UIApplication sendAction:to:from:forEvent:]。</p>
<p><img src="http://ww4.sinaimg.cn/mw690/005IevIrjw1fbrc8p59h4j30sq0r4tkl.jpg" alt="gesture recognizer handle flow"></p>
<p><img src="http://ww3.sinaimg.cn/mw690/005IevIrjw1fbrc8oa8etj30sw0q87fd.jpg" alt="control handle flow"></p>
<p>##处理多点触摸事件的最佳实践<br>当处理 touch 和 motion 事件时，这里有一些值得推荐的技巧和模式：</p>
<ul>
<li>记得实现事件的取消方法。</li>
<li>如果自定义的是 UIView、UIViewController、UIResponder的子类时，你应该实现所有的事件方法，即使里面没有做任何实现。但是不要在里面调用父类的实现。</li>
<li>如果是其他 UIKit 的子类时，你没有必须实现所有的事件方法。但是，你必须得调用父类的实现。即 [super touchesBegan:touches withEvent:event] 。</li>
<li>只转发事件给 UIView 的子类。并确保这些转发后的对象能够知道并且处理这些不属于它的事件。</li>
<li>不要显示的通过 nextResponder 方法在响应链上发送事件。相反的，调用父类的实现，并且让 UIKit 去遍历处理。</li>
<li>不要使用 round-to-integer 代码（即不要使用 integer 来处理 float），这样会丢失精度。</li>
<li>如果在事件处理的时候需要创建持久对象，记得在 touchesCancelled:withEvent 和 touchesEnded:withEvent: 里面销毁它们。</li>
<li>如果你阻止它接受某个状态的 touch 事件时，可能导致结果不确定。不过，我们在实际中应该不会这样做。</li>
</ul>
<p>#总结<br>##需求<br>事件传递的最终目标是找到一个能够处理响应这个事件的对象（UIResponder 的子类）。如果找不到就丢弃它。</p>
<p>##前提条件<br>能够处理事件的对象需要完成下面3个条件：</p>
<ul>
<li>实现这四个方法 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event; </span><br><span class="line">- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;</span><br><span class="line">- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;</span><br><span class="line">- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;</span><br></pre></td></tr></table></figure></li>
<li>可以交互的。即 userInteractionEnabled 属性为 YES。</li>
<li>是可见的。即 hidden = NO &amp; alpha &gt; 0.01。</li>
</ul>
<p>##UIKit 已有的轮子<br>换汤不要药，跟前面的前提条件一样，只不过是另外一种形式来完成而已。</p>
<p>###gesture recognizer<br>通过实现跟 UIResponder 相同签名的方法来完成。参考例子，上面有提到，官方文档 <a href="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/GestureRecognizer_basics/GestureRecognizer_basics.html#//apple_ref/doc/uid/TP40009541-CH2-SW2">Listing 1-8  Implementation of a checkmark gesture recognizer</a> 和 <a href="https://github.com/ibireme/YYKit/blob/master/YYKit/Utility/YYGestureRecognizer.m">YYGestureRecognizer</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event; </span><br><span class="line">- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;</span><br><span class="line">- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;</span><br><span class="line">- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;</span><br></pre></td></tr></table></figure>
<p>###UIControl<br>也是内部实现跟 UIResponder 相同功能的方法来完成，里面通过一个 _targetActions 数组来存储各种 UIControlEvents 状态的事件。可以参考<a href="https://github.com/BigZaphod/Chameleon/blob/master/UIKit/Classes/UIControl.m">Chameleon UIControl</a> 和 <a href="https://github.com/samvermette/SVSegmentedControl">SVSegmentedControl</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)beginTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event;</span><br><span class="line">- (BOOL)continueTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event;</span><br><span class="line">- (void)endTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event;</span><br><span class="line">- (void)cancelTrackingWithEvent:(UIEvent *)event;</span><br></pre></td></tr></table></figure>

<p>##过程<br>手指触摸屏幕就会生成 UIEvent 对象，然后放在 application 的队列里面，application 会从系统队列的顶层取出一个事件并分发它。application(sendEvent:) -&gt; window(sendEvent:) -&gt; initial object(hit-test view or frist responder)。<br>而 application 和 window 则是通过 Hit-Testing 和响应链来找到 initial object。一般情况下，都不需要我们去干涉 UIKit 的这个分发过程。但是，我们可以在这个过程去干涉达到自己的需求。</p>
<p>##用途<br>这个章节的相关代码参考自</p>
<ul>
<li><a href="http://smnh.me/hit-testing-in-ios/">smnh Hit-Testing in iOS</a></li>
<li><a href="http://zhoon.github.io/ios/2015/04/12/ios-event.html">ZhoonChen 深入浅出iOS事件机制</a></li>
<li><a href="http://www.jianshu.com/p/d8512dff2b3e">iOS事件响应链中Hit-Test View的应用</a></li>
</ul>
<p>###扩大触摸区域<br>我们绘制 UIButton 的时候，想要扩大它的响应区域。我们可以在 UIButton 里面处理 Hit-Testing 的那两个方法其中一个里面做处理。</p>
<p>####hitTest:withEvent:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123;</span><br><span class="line">    CGRect touchRect &#x3D; CGRectInset(self.bounds, -10, -10);</span><br><span class="line">    if (CGRectContainsPoint(touchRect, point)) &#123;</span><br><span class="line">        return self;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super hitTest:point withEvent:event];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>####pointInside:withEvent:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event &#123;</span><br><span class="line">    return CGRectContainsPoint(HitTestingBounds(self.bounds, self.minimumHitTestWidth, self.minimumHitTestHeight), point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CGRect HitTestingBounds(CGRect bounds, CGFloat minimumHitTestWidth, CGFloat minimumHitTestHeight) &#123;</span><br><span class="line">    CGRect hitTestingBounds &#x3D; bounds;</span><br><span class="line">    if (minimumHitTestWidth &gt; bounds.size.width) &#123;</span><br><span class="line">        hitTestingBounds.size.width &#x3D; minimumHitTestWidth;</span><br><span class="line">        hitTestingBounds.origin.x -&#x3D; (hitTestingBounds.size.width - bounds.size.width)&#x2F;2;</span><br><span class="line">    &#125;</span><br><span class="line">    if (minimumHitTestHeight &gt; bounds.size.height) &#123;</span><br><span class="line">        hitTestingBounds.size.height &#x3D; minimumHitTestHeight;</span><br><span class="line">        hitTestingBounds.origin.y -&#x3D; (hitTestingBounds.size.height - bounds.size.height)&#x2F;2;</span><br><span class="line">    &#125;</span><br><span class="line">    return hitTestingBounds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###superview 响应 subview 的事件<br>这个在<code>限制事件分发到 subviews 上</code>小节里面就有说过。重载 hitTest:withEvent: 方法返回自己 self。</p>
<p>#参考资料</p>
<ul>
<li><a href="https://developer.apple.com/reference/uikit/uiapplication/1623043-sendevent?language=objc">Apple UIApplication sendEvent:</a></li>
<li><a href="https://developer.apple.com/reference/uikit/uiapplication/1622946-sendaction?language=objc">Apple UIApplication sendAction:to:from:forEvent:</a></li>
<li><a href="https://developer.apple.com/reference/uikit/uiwindow/1621614-sendevent?language=objc">Apple UIWindow sendEvent:</a></li>
<li><a href="https://developer.apple.com/reference/uikit/uiresponder?language=objc">Apple UIResponder</a></li>
<li><a href="https://developer.apple.com/reference/uikit/uicontrol?language=objc">Apple UIControl</a></li>
<li><a href="https://developer.apple.com/reference/uikit/uigesturerecognizer?language=objc">Apple UIGesturerecognizer</a></li>
<li><a href="https://developer.apple.com/library/content/documentation/General/Conceptual/Devpedia-CocoaApp/TargetAction.html#//apple_ref/doc/uid/TP40009071-CH3">Apple TargetAction</a></li>
<li><a href="https://github.com/nst/iOS-Runtime-Headers/blob/master/Frameworks/UIKit.framework/UIControl.h#L28">iOS-Runtime-Headers _targetActions数组</a></li>
<li><a href="https://github.com/BigZaphod/Chameleon/blob/master/UIKit/Classes/UIControl.m#L37">Chameleon 自定义控件里面</a></li>
<li><a href="https://github.com/BigZaphod/Chameleon/blob/master/UIKit/Classes/UIView.m#L864">Chameleon hitTest:withEvent:</a></li>
<li><a href="https://github.com/BigZaphod/Chameleon/blob/master/UIKit/Classes/UIView.m#L844">Chameleon pointInside:withEvent:</a></li>
<li><a href="http://southpeak.github.io/2015/12/13/cocoa-uikit-uicontrol/">南峰子 UIKit: UIControl</a></li>
<li><a href="http://southpeak.github.io/2015/03/07/cocoa-uikit-uiresponder/">南峰子 UIKit: UIResponder</a></li>
</ul>
<p>评论使用的是 disqus，FQ 就可以用了。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Event-Handling/" rel="tag"># Event Handling</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2016/11/20/SCLAlertView/" rel="prev" title="SCLAlertView 源码解析">
      <i class="fa fa-chevron-left"></i> SCLAlertView 源码解析
    </a></div>
      <div class="post-nav-item">
    <a href="/2017/08/14/%E3%80%8A%E5%9B%BE%E8%A7%A3%E7%A7%98%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%8B%E7%AE%80%E5%8D%95%E8%AF%BB%E5%90%8E%E6%84%9F/" rel="next" title="《图解秘密技术》简单读后感">
      《图解秘密技术》简单读后感 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">joakim.liu</p>
  <div class="site-description" itemprop="description">你不解决问题，就会成为问题。iOS菜逗一枚。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/JoakimLiu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;JoakimLiu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/JoakimLiu" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;JoakimLiu" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">joakim.liu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script>
  var disqus_config = function() {
    this.page.url = "http://example.com/2017/01/15/iOS%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/";
    this.page.identifier = "2017/01/15/iOS的事件处理/";
    this.page.title = "iOS的事件处理";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://http-joakimliu-github-io.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
