<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="SDWebImage这个第三方库大家都不陌生吧，一个网络请求图片用的。其官方解释是：作为UIImageView的类别，支持缓存的异步下载图片。 它有一些特点：  一个带有管理网络图片下载和缓存的UIImageView类别一个异步图片下载器一个提供内存和磁盘缓存图片，并且能够自动清理过期的缓存支持GIF图片支持WebP图片后台解压图片保证通一个URL不会下载多次保证假的URL不会返回加载保证主线程不">
<meta property="og:type" content="article">
<meta property="og:title" content="SDWebImage源码浅析">
<meta property="og:url" content="http://example.com/2015/11/15/Resolve-The-SourceCode-Of-SDWebImage/index.html">
<meta property="og:site_name" content="牛易疯先森的开发记录">
<meta property="og:description" content="SDWebImage这个第三方库大家都不陌生吧，一个网络请求图片用的。其官方解释是：作为UIImageView的类别，支持缓存的异步下载图片。 它有一些特点：  一个带有管理网络图片下载和缓存的UIImageView类别一个异步图片下载器一个提供内存和磁盘缓存图片，并且能够自动清理过期的缓存支持GIF图片支持WebP图片后台解压图片保证通一个URL不会下载多次保证假的URL不会返回加载保证主线程不">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://ww2.sinaimg.cn/mw690/005IevIrjw1ey1nz1g35uj308d0j8adk.jpg">
<meta property="article:published_time" content="2015-11-15T07:33:37.000Z">
<meta property="article:modified_time" content="2021-01-22T14:55:23.847Z">
<meta property="article:author" content="joakim.liu">
<meta property="article:tag" content="SDWebImage">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://ww2.sinaimg.cn/mw690/005IevIrjw1ey1nz1g35uj308d0j8adk.jpg">

<link rel="canonical" href="http://example.com/2015/11/15/Resolve-The-SourceCode-Of-SDWebImage/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>SDWebImage源码浅析 | 牛易疯先森的开发记录</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">牛易疯先森的开发记录</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2015/11/15/Resolve-The-SourceCode-Of-SDWebImage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="joakim.liu">
      <meta itemprop="description" content="你不解决问题，就会成为问题。iOS菜逗一枚。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="牛易疯先森的开发记录">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          SDWebImage源码浅析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-11-15 15:33:37" itemprop="dateCreated datePublished" datetime="2015-11-15T15:33:37+08:00">2015-11-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">源码解析</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><a href="https://github.com/rs/SDWebImage">SDWebImage</a>这个第三方库大家都不陌生吧，一个网络请求图片用的。其官方解释是：作为UIImageView的类别，支持缓存的异步下载图片。</p>
<p>它有一些特点：</p>
<blockquote>
<p>一个带有管理网络图片下载和缓存的UIImageView类别<br>一个异步图片下载器<br>一个提供内存和磁盘缓存图片，并且能够自动清理过期的缓存<br>支持<code>GIF</code>图片<br>支持<code>WebP</code><br>图片后台解压图片<br>保证通一个<code>URL</code>不会下载多次<br>保证假的<code>URL</code>不会返回加载<br>保证主线程不会堵塞<br>高性能<br>使用<code>GCD</code>和<code>ARC</code><br>支持<code>Arm64</code></p>
</blockquote>
<a id="more"></a>

<p>从它在<code>github</code>上面的星星数量（已过万），说明它在图片下载和缓存方面还是可以的，记得我13年刚搞iOS的时候就有用过这个库。那个时候年少无知，学习能力不行，只要会用就行，还管它内部怎么个实现法呢……前段时间有同事问我，怎么用<code>SD</code>下载<code>Image</code>，我当时就凌乱了，尼玛，这么有名的库都不会，其实，我当时只是在需要改变它的缓存时间时，初略看过（然后，老大说别动第三方库，所以处理缓存时间那事就完了）。最近，有在细看<code>SD</code>，本文中，会对SD源码（3.7.3版本）做解析，当然只针对自己常用的做分析，什么gif、webP图片格式就算了哈……如果想对图片有深入的了解，请移步至<a href="http://blog.ibireme.com/2015/11/02/mobile_image_benchmark/">YY</a>。</p>
<p><img src="http://ww2.sinaimg.cn/mw690/005IevIrjw1ey1nz1g35uj308d0j8adk.jpg" alt="SD目录结构"></p>
<p>以上是SD的目录结构，很清晰，一目了然！</p>
<blockquote>
<p><code>Downloader</code>下载图片<br><code>Cache</code>缓存图片<br><code>Utils</code>管理图片（<code>SDWebImageManager</code>管理<code>SDWebImageDownloader</code>和<code>SDImageCache</code>，是<code>SD</code>的管理者；<code>SDWebImageDecoder</code>用来解压图片；  <code>SDWebImagePrefetcher</code>预加载图片）<br><code>Categories</code>分类 </p>
</blockquote>
<h1 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h1><p> <code>SDImageCache</code>用来维持内存缓存和可选的磁盘缓存，异步的磁盘缓存不会堵塞UI。该类就做这些事吧：缓存数据、查询获取数据、清理数据、获取存储容量相关数据。</p>
<h2 id="缓存图片"><a href="#缓存图片" class="headerlink" title="缓存图片"></a>缓存图片</h2><p>用图片的<code>URL</code>作为<code>key</code>来存储，用<code>MD5</code>加密获取的字符串来作为数据名。<br>在头文件中可以看到关于存储数据的相关函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)storeImage:(UIImage *)image forKey:(NSString *)key;</span><br><span class="line"></span><br><span class="line">- (void)storeImage:(UIImage *)image forKey:(NSString *)key toDisk:(BOOL)toDisk;</span><br><span class="line"></span><br><span class="line">- (void)storeImage:(UIImage *)image recalculateFromImage:(BOOL)recalculate imageData:(NSData *)imageData forKey:(NSString *)key toDisk:(BOOL)toDisk;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  缓存图片</span><br><span class="line"> *</span><br><span class="line"> *  @param image       图片</span><br><span class="line"> *  @param recalculate 是否重新计算</span><br><span class="line"> *  @param imageData   imageData</span><br><span class="line"> *  @param key         缓存的key</span><br><span class="line"> *  @param toDisk      是否缓存到磁盘</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)storeImage:(UIImage *)image recalculateFromImage:(BOOL)recalculate imageData:(NSData *)imageData forKey:(NSString *)key toDisk:(BOOL)toDisk &#123;</span><br><span class="line">    if (!image || !key) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 缓存到内存</span><br><span class="line">    if (self.shouldCacheImagesInMemory) &#123;</span><br><span class="line">        &#x2F;&#x2F; 计算缓存图片所需的消耗</span><br><span class="line">        NSUInteger cost &#x3D; SDCacheCostForImage(image);</span><br><span class="line">        [self.memCache setObject:image forKey:key cost:cost];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (toDisk) &#123;</span><br><span class="line">        dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">            NSData *data &#x3D; imageData;</span><br><span class="line">            &#x2F;&#x2F; 有图片 并且 （需要重新计算或者图片数据为空）</span><br><span class="line">            if (image &amp;&amp; (recalculate || !data)) &#123;</span><br><span class="line">#if TARGET_OS_IPHONE</span><br><span class="line">                &#x2F;&#x2F; We need to determine if the image is a PNG or a JPEG</span><br><span class="line">                &#x2F;&#x2F; PNGs are easier to detect because they have a unique signature (http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;PNG-Structure.html)</span><br><span class="line">                &#x2F;&#x2F; The first eight bytes of a PNG file always contain the following (decimal) values:</span><br><span class="line">                &#x2F;&#x2F; 137 80 78 71 13 10 26 10</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; If the imageData is nil (i.e. if trying to save a UIImage directly or the image was transformed on download)</span><br><span class="line">                &#x2F;&#x2F; and the image has an alpha channel, we will consider it PNG to avoid losing the transparency</span><br><span class="line">                &#x2F;&#x2F; 判断是PNG还是JPEG</span><br><span class="line">                int alphaInfo &#x3D; CGImageGetAlphaInfo(image.CGImage);</span><br><span class="line">                BOOL hasAlpha &#x3D; !(alphaInfo &#x3D;&#x3D; kCGImageAlphaNone ||</span><br><span class="line">                                  alphaInfo &#x3D;&#x3D; kCGImageAlphaNoneSkipFirst ||</span><br><span class="line">                                  alphaInfo &#x3D;&#x3D; kCGImageAlphaNoneSkipLast);</span><br><span class="line">                BOOL imageIsPng &#x3D; hasAlpha;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; But if we have an image data, we will look at the preffix</span><br><span class="line">                if ([imageData length] &gt;&#x3D; [kPNGSignatureData length]) &#123;</span><br><span class="line">                    imageIsPng &#x3D; ImageDataHasPNGPreffix(imageData);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (imageIsPng) &#123;</span><br><span class="line">                    data &#x3D; UIImagePNGRepresentation(image);</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    data &#x3D; UIImageJPEGRepresentation(image, (CGFloat)1.0);</span><br><span class="line">                &#125;</span><br><span class="line">#else</span><br><span class="line">                data &#x3D; [NSBitmapImageRep representationOfImageRepsInArray:image.representations usingType: NSJPEGFileType properties:nil];</span><br><span class="line">#endif</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 有数据 则缓存</span><br><span class="line">            if (data) &#123;</span><br><span class="line">                &#x2F;&#x2F; 缓存路径是否存在 没有存在则创建</span><br><span class="line">                if (![_fileManager fileExistsAtPath:_diskCachePath]) &#123;</span><br><span class="line">                    [_fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:YES attributes:nil error:NULL];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 根据URL key 来获取存储的路径</span><br><span class="line">                NSString *cachePathForKey &#x3D; [self defaultCachePathForKey:key];</span><br><span class="line">                &#x2F;&#x2F; 转换成URL</span><br><span class="line">                NSURL *fileURL &#x3D; [NSURL fileURLWithPath:cachePathForKey];</span><br><span class="line">                &#x2F;&#x2F; 存储数据</span><br><span class="line">                [_fileManager createFileAtPath:cachePathForKey contents:data attributes:nil];</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; disable iCloud backup</span><br><span class="line">                if (self.shouldDisableiCloud) &#123;</span><br><span class="line">                    [fileURL setResourceValue:[NSNumber numberWithBool:YES] forKey:NSURLIsExcludedFromBackupKey error:nil];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>kPNGSignatureData </code>是PNG格式图片的签名数据，在初始化的时候，它被赋值为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kPNGSignatureData &#x3D; [NSData dataWithBytes:kPNGSignatureBytes length:8];</span><br></pre></td></tr></table></figure>
<p>而<code>kPNGSignatureBytes</code>数组，则是PNG图片格式的签名字节；<code>ImageDataHasPNGPreffix </code>C方法用来判断数据是否为PNG图片；相关关系可看下面代码：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; PNG signature bytes and data (below)</span><br><span class="line">static unsigned char kPNGSignatureBytes[8] &#x3D; &#123;0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A&#125;;</span><br><span class="line">static NSData *kPNGSignatureData &#x3D; nil;</span><br><span class="line"></span><br><span class="line">BOOL ImageDataHasPNGPreffix(NSData *data);</span><br><span class="line"></span><br><span class="line">BOOL ImageDataHasPNGPreffix(NSData *data) &#123;</span><br><span class="line">    NSUInteger pngSignatureLength &#x3D; [kPNGSignatureData length];</span><br><span class="line">    if ([data length] &gt;&#x3D; pngSignatureLength) &#123;</span><br><span class="line">        if ([[data subdataWithRange:NSMakeRange(0, pngSignatureLength)] isEqualToData:kPNGSignatureData]) &#123;</span><br><span class="line">            return YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="查询获取数据"><a href="#查询获取数据" class="headerlink" title="查询获取数据"></a>查询获取数据</h2><p>获取内存存储数据，直接用<code>NSCache</code>对象去查询即可。而获取磁盘存储数据时却做了优化（取出的时候根据需求有解压）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  从内存中查找图片</span><br><span class="line"> *</span><br><span class="line"> *  @param key key</span><br><span class="line"> *</span><br><span class="line"> *  @return return value description</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (UIImage *)imageFromMemoryCacheForKey:(NSString *)key &#123;</span><br><span class="line">    return [self.memCache objectForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  从磁盘中查找图片</span><br><span class="line"> *</span><br><span class="line"> *  @param key key description</span><br><span class="line"> *</span><br><span class="line"> *  @return return value description</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (UIImage *)imageFromDiskCacheForKey:(NSString *)key &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; First check the in-memory cache...</span><br><span class="line">    &#x2F;&#x2F; 从内存中取</span><br><span class="line">    UIImage *image &#x3D; [self imageFromMemoryCacheForKey:key];</span><br><span class="line">    if (image) &#123;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Second check the disk cache...</span><br><span class="line">    &#x2F;&#x2F; 从磁盘中取</span><br><span class="line">    UIImage *diskImage &#x3D; [self diskImageForKey:key];</span><br><span class="line">    &#x2F;&#x2F; 如果图片存在 并且要缓存到内存中 则将图片缓存到内存</span><br><span class="line">    if (diskImage &amp;&amp; self.shouldCacheImagesInMemory) &#123;</span><br><span class="line">        NSUInteger cost &#x3D; SDCacheCostForImage(diskImage);</span><br><span class="line">        [self.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return diskImage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  从磁盘中获取数据</span><br><span class="line"> *</span><br><span class="line"> *  @param key key description</span><br><span class="line"> *</span><br><span class="line"> *  @return return value description</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSData *)diskImageDataBySearchingAllPathsForKey:(NSString *)key &#123;</span><br><span class="line">    &#x2F;&#x2F; 默认路径</span><br><span class="line">    NSString *defaultPath &#x3D; [self defaultCachePathForKey:key];</span><br><span class="line">    NSData *data &#x3D; [NSData dataWithContentsOfFile:defaultPath];</span><br><span class="line">    if (data) &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 自定义路径</span><br><span class="line">    NSArray *customPaths &#x3D; [self.customPaths copy];</span><br><span class="line">    for (NSString *path in customPaths) &#123;</span><br><span class="line">        NSString *filePath &#x3D; [self cachePathForKey:key inPath:path];</span><br><span class="line">        NSData *imageData &#x3D; [NSData dataWithContentsOfFile:filePath];</span><br><span class="line">        if (imageData) &#123;</span><br><span class="line">            return imageData;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  根据key在磁盘中获取图片</span><br><span class="line"> *</span><br><span class="line"> *  @param key key</span><br><span class="line"> *</span><br><span class="line"> *  @return &lt;#return value description#&gt;</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (UIImage *)diskImageForKey:(NSString *)key &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取 data</span><br><span class="line">    NSData *data &#x3D; [self diskImageDataBySearchingAllPathsForKey:key];</span><br><span class="line">    if (data) &#123;</span><br><span class="line">        UIImage *image &#x3D; [UIImage sd_imageWithData:data];</span><br><span class="line">        &#x2F;&#x2F; 缩放图片</span><br><span class="line">        image &#x3D; [self scaledImageForKey:key image:image];</span><br><span class="line">        &#x2F;&#x2F; 解压图片</span><br><span class="line">        if (self.shouldDecompressImages) &#123;</span><br><span class="line">            image &#x3D; [UIImage decodedImageWithImage:image];</span><br><span class="line">        &#125;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然该类也提供了一个包含<code>block</code>参数的多线程查询方法。</p>
<blockquote>
<p>SDImageCacheTypeNone 没有缓存，即该图片还没有下载<br>SDImageCacheTypeDisk 缓存在磁盘的图片<br>SDImageCacheTypeMemory 缓存在内存的图片</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  从磁盘查询数据</span><br><span class="line"> *</span><br><span class="line"> *  @param key       key</span><br><span class="line"> *  @param doneBlock block回调</span><br><span class="line"> *</span><br><span class="line"> *  @return return value description</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSOperation *)queryDiskCacheForKey:(NSString *)key done:(SDWebImageQueryCompletedBlock)doneBlock &#123;</span><br><span class="line">    if (!doneBlock) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果key为空</span><br><span class="line">    if (!key) &#123;</span><br><span class="line">        doneBlock(nil, SDImageCacheTypeNone);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; First check the in-memory cache...</span><br><span class="line">    &#x2F;&#x2F; 首先查询内存</span><br><span class="line">    UIImage *image &#x3D; [self imageFromMemoryCacheForKey:key];</span><br><span class="line">    if (image) &#123;</span><br><span class="line">        doneBlock(image, SDImageCacheTypeMemory);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    NSOperation *operation &#x3D; [NSOperation new];</span><br><span class="line">    dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">        if (operation.isCancelled) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        @autoreleasepool &#123;</span><br><span class="line">            &#x2F;&#x2F; 磁盘查询</span><br><span class="line">            UIImage *diskImage &#x3D; [self diskImageForKey:key];</span><br><span class="line">            &#x2F;&#x2F; 如果图片存在 并且要缓存到内存中 则将图片缓存到内存</span><br><span class="line">            if (diskImage &amp;&amp; self.shouldCacheImagesInMemory) &#123;</span><br><span class="line">                NSUInteger cost &#x3D; SDCacheCostForImage(diskImage);</span><br><span class="line">                [self.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 回调</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                doneBlock(diskImage, SDImageCacheTypeDisk);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="清理数据"><a href="#清理数据" class="headerlink" title="清理数据"></a>清理数据</h2><p> 移除数据只要移除缓存的文件即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  移除文件</span><br><span class="line"> *</span><br><span class="line"> *  @param key        key</span><br><span class="line"> *  @param fromDisk   是否从磁盘移除</span><br><span class="line"> *  @param completion block回调</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)removeImageForKey:(NSString *)key fromDisk:(BOOL)fromDisk withCompletion:(SDWebImageNoParamsBlock)completion &#123;</span><br><span class="line">    </span><br><span class="line">    if (key &#x3D;&#x3D; nil) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果有缓存 则从缓存中移除</span><br><span class="line">    if (self.shouldCacheImagesInMemory) &#123;</span><br><span class="line">        [self.memCache removeObjectForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 从磁盘移除 异步操作</span><br><span class="line">    if (fromDisk) &#123;</span><br><span class="line">        dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">            &#x2F;&#x2F; 直接删除文件</span><br><span class="line">            [_fileManager removeItemAtPath:[self defaultCachePathForKey:key] error:nil];</span><br><span class="line">            &#x2F;&#x2F; 回调</span><br><span class="line">            if (completion) &#123;</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    completion();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else if (completion)&#123;</span><br><span class="line">        completion();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>清理数据分为全部清理( <code>clear</code>打头)和部分清理（<code>clean</code>打头）。</p>
<h3 id="全部清理"><a href="#全部清理" class="headerlink" title="全部清理"></a>全部清理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (void)clearDisk &#123;</span><br><span class="line">    [self clearDiskOnCompletion:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)clearDiskOnCompletion:(SDWebImageNoParamsBlock)completion</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">        &#x2F;&#x2F; 清理文件</span><br><span class="line">        [_fileManager removeItemAtPath:self.diskCachePath error:nil];</span><br><span class="line">        &#x2F;&#x2F; 创建文件路径</span><br><span class="line">        [_fileManager createDirectoryAtPath:self.diskCachePath</span><br><span class="line">                withIntermediateDirectories:YES</span><br><span class="line">                                 attributes:nil</span><br><span class="line">                                      error:NULL];</span><br><span class="line"></span><br><span class="line">        if (completion) &#123;</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completion();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="部分清理"><a href="#部分清理" class="headerlink" title="部分清理"></a>部分清理</h3><p>部分清理主要表现在：1、清理过期的文件；2、当缓存空间超过最大缓存阀值时，按照时间顺序删除超过最先缓存的图片，使缓存空间达到最大缓存阀值的一半。<br>部分清理可以手动清理，即调用<code>cleanDiskWithCompletionBlock:</code>方法即可；当然在APP进入后台的时候该类会自动清理，它调用<code>backgroundCleanDisk </code>方法，从而调用<code>cleanDiskWithCompletionBlock:</code>方法。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  清理磁盘</span><br><span class="line"> *</span><br><span class="line"> *  @param completionBlock &lt;#completionBlock description#&gt;</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)cleanDiskWithCompletionBlock:(SDWebImageNoParamsBlock)completionBlock &#123;</span><br><span class="line">    dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">        &#x2F;&#x2F; 获取存储路径</span><br><span class="line">        NSURL *diskCacheURL &#x3D; [NSURL fileURLWithPath:self.diskCachePath isDirectory:YES];</span><br><span class="line">        &#x2F;&#x2F; 获取相关属性数组</span><br><span class="line">        NSArray *resourceKeys &#x3D; @[NSURLIsDirectoryKey, NSURLContentModificationDateKey, NSURLTotalFileAllocatedSizeKey];</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; This enumerator prefetches useful properties for our cache files.</span><br><span class="line">        &#x2F;&#x2F; 预取缓存文件中有用的属性</span><br><span class="line">        NSDirectoryEnumerator *fileEnumerator &#x3D; [_fileManager enumeratorAtURL:diskCacheURL</span><br><span class="line">                                                   includingPropertiesForKeys:resourceKeys</span><br><span class="line">                                                                      options:NSDirectoryEnumerationSkipsHiddenFiles</span><br><span class="line">                                                                 errorHandler:NULL];</span><br><span class="line">        &#x2F;&#x2F; 计算出过期的时间</span><br><span class="line">        NSDate *expirationDate &#x3D; [NSDate dateWithTimeIntervalSinceNow:-self.maxCacheAge];</span><br><span class="line">        &#x2F;&#x2F; 缓存的文件</span><br><span class="line">        NSMutableDictionary *cacheFiles &#x3D; [NSMutableDictionary dictionary];</span><br><span class="line">        &#x2F;&#x2F; 去掉过期缓存文件后 缓存大小</span><br><span class="line">        NSUInteger currentCacheSize &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Enumerate all of the files in the cache directory.  This loop has two purposes:</span><br><span class="line">        &#x2F;&#x2F;</span><br><span class="line">        &#x2F;&#x2F;  1. Removing files that are older than the expiration date.</span><br><span class="line">        &#x2F;&#x2F;  2. Storing file attributes for the size-based cleanup pass.</span><br><span class="line">        &#x2F;&#x2F; 需要删除的文件 如果是目录则跳过 将没有过期的文件下来并且计算它们的大小（如果该大小超过最大的阀值 则得删除一些缓存）</span><br><span class="line">        NSMutableArray *urlsToDelete &#x3D; [[NSMutableArray alloc] init];</span><br><span class="line">        for (NSURL *fileURL in fileEnumerator) &#123;</span><br><span class="line">            NSDictionary *resourceValues &#x3D; [fileURL resourceValuesForKeys:resourceKeys error:NULL];</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Skip directories.</span><br><span class="line">            if ([resourceValues[NSURLIsDirectoryKey] boolValue]) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Remove files that are older than the expiration date;</span><br><span class="line">            NSDate *modificationDate &#x3D; resourceValues[NSURLContentModificationDateKey];</span><br><span class="line">            if ([[modificationDate laterDate:expirationDate] isEqualToDate:expirationDate]) &#123;</span><br><span class="line">                [urlsToDelete addObject:fileURL];</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Store a reference to this file and account for its total size.</span><br><span class="line">            NSNumber *totalAllocatedSize &#x3D; resourceValues[NSURLTotalFileAllocatedSizeKey];</span><br><span class="line">            currentCacheSize +&#x3D; [totalAllocatedSize unsignedIntegerValue];</span><br><span class="line">            [cacheFiles setObject:resourceValues forKey:fileURL];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 删掉过期的文件</span><br><span class="line">        for (NSURL *fileURL in urlsToDelete) &#123;</span><br><span class="line">            [_fileManager removeItemAtURL:fileURL error:nil];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; If our remaining disk cache exceeds a configured maximum size, perform a second</span><br><span class="line">        &#x2F;&#x2F; size-based cleanup pass.  We delete the oldest files first.</span><br><span class="line">        &#x2F;&#x2F; 如果重新需要缓存的文件大小超过已经设定的缓存大小阀值 就得按时间来删除一些文件 知道缓存的文件大小小于已设定值的一半</span><br><span class="line">        if (self.maxCacheSize &gt; 0 &amp;&amp; currentCacheSize &gt; self.maxCacheSize) &#123;</span><br><span class="line">            &#x2F;&#x2F; Target half of our maximum cache size for this cleanup pass.</span><br><span class="line">            const NSUInteger desiredCacheSize &#x3D; self.maxCacheSize &#x2F; 2;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Sort the remaining cache files by their last modification time (oldest first).</span><br><span class="line">            NSArray *sortedFiles &#x3D; [cacheFiles keysSortedByValueWithOptions:NSSortConcurrent</span><br><span class="line">                                                            usingComparator:^NSComparisonResult(id obj1, id obj2) &#123;</span><br><span class="line">                                                                return [obj1[NSURLContentModificationDateKey] compare:obj2[NSURLContentModificationDateKey]];</span><br><span class="line">                                                            &#125;];</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Delete files until we fall below our desired cache size.</span><br><span class="line">            for (NSURL *fileURL in sortedFiles) &#123;</span><br><span class="line">                if ([_fileManager removeItemAtURL:fileURL error:nil]) &#123;</span><br><span class="line">                    NSDictionary *resourceValues &#x3D; cacheFiles[fileURL];</span><br><span class="line">                    NSNumber *totalAllocatedSize &#x3D; resourceValues[NSURLTotalFileAllocatedSizeKey];</span><br><span class="line">                    currentCacheSize -&#x3D; [totalAllocatedSize unsignedIntegerValue];</span><br><span class="line"></span><br><span class="line">                    if (currentCacheSize &lt; desiredCacheSize) &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completionBlock();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  在后台清理</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)backgroundCleanDisk &#123;</span><br><span class="line">    Class UIApplicationClass &#x3D; NSClassFromString(@&quot;UIApplication&quot;);</span><br><span class="line">    if(!UIApplicationClass || ![UIApplicationClass respondsToSelector:@selector(sharedApplication)]) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    UIApplication *application &#x3D; [UIApplication performSelector:@selector(sharedApplication)];</span><br><span class="line">    __block UIBackgroundTaskIdentifier bgTask &#x3D; [application beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">        &#x2F;&#x2F; Clean up any unfinished task business by marking where you</span><br><span class="line">        &#x2F;&#x2F; stopped or ending the task outright.</span><br><span class="line">        [application endBackgroundTask:bgTask];</span><br><span class="line">        bgTask &#x3D; UIBackgroundTaskInvalid;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Start the long-running task and return immediately.</span><br><span class="line">    [self cleanDiskWithCompletionBlock:^&#123;</span><br><span class="line">        [application endBackgroundTask:bgTask];</span><br><span class="line">        bgTask &#x3D; UIBackgroundTaskInvalid;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="获取存储容量相关数据"><a href="#获取存储容量相关数据" class="headerlink" title="获取存储容量相关数据"></a>获取存储容量相关数据</h2><p>查询缓存图片的数量以及大小。理解该三个方法需要<code>NSFileManager</code>玩得比较熟练。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  得到缓存容量大小</span><br><span class="line"> *</span><br><span class="line"> *  @return return value description</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSUInteger)getSize &#123;</span><br><span class="line">    __block NSUInteger size &#x3D; 0;</span><br><span class="line">    dispatch_sync(self.ioQueue, ^&#123;</span><br><span class="line">        NSDirectoryEnumerator *fileEnumerator &#x3D; [_fileManager enumeratorAtPath:self.diskCachePath];</span><br><span class="line">        for (NSString *fileName in fileEnumerator) &#123;</span><br><span class="line">            NSString *filePath &#x3D; [self.diskCachePath stringByAppendingPathComponent:fileName];</span><br><span class="line">            NSDictionary *attrs &#x3D; [[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:nil];</span><br><span class="line">            size +&#x3D; [attrs fileSize];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  得到缓存图片的数量</span><br><span class="line"> *</span><br><span class="line"> *  @return return value description</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSUInteger)getDiskCount &#123;</span><br><span class="line">    __block NSUInteger count &#x3D; 0;</span><br><span class="line">    dispatch_sync(self.ioQueue, ^&#123;</span><br><span class="line">        NSDirectoryEnumerator *fileEnumerator &#x3D; [_fileManager enumeratorAtPath:self.diskCachePath];</span><br><span class="line">        count &#x3D; [[fileEnumerator allObjects] count];</span><br><span class="line">    &#125;);</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  获取缓存图片数量及总容量</span><br><span class="line"> *</span><br><span class="line"> *  @param completionBlock block 回调</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)calculateSizeWithCompletionBlock:(SDWebImageCalculateSizeBlock)completionBlock &#123;</span><br><span class="line">    NSURL *diskCacheURL &#x3D; [NSURL fileURLWithPath:self.diskCachePath isDirectory:YES];</span><br><span class="line"></span><br><span class="line">    dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">        NSUInteger fileCount &#x3D; 0;</span><br><span class="line">        NSUInteger totalSize &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        NSDirectoryEnumerator *fileEnumerator &#x3D; [_fileManager enumeratorAtURL:diskCacheURL</span><br><span class="line">                                                   includingPropertiesForKeys:@[NSFileSize]</span><br><span class="line">                                                                      options:NSDirectoryEnumerationSkipsHiddenFiles</span><br><span class="line">                                                                 errorHandler:NULL];</span><br><span class="line"></span><br><span class="line">        for (NSURL *fileURL in fileEnumerator) &#123;</span><br><span class="line">            NSNumber *fileSize;</span><br><span class="line">            [fileURL getResourceValue:&amp;fileSize forKey:NSURLFileSizeKey error:NULL];</span><br><span class="line">            totalSize +&#x3D; [fileSize unsignedIntegerValue];</span><br><span class="line">            fileCount +&#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completionBlock(fileCount, totalSize);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Downloader"><a href="#Downloader" class="headerlink" title="Downloader"></a>Downloader</h1><p>下载管理主要由<code>SDWebImageDownloader</code>类来完成，而主要进行下载操作的则是<code>SDWebImageDownloaderOperation </code>类。</p>
<h2 id="SDWebImageDownloader"><a href="#SDWebImageDownloader" class="headerlink" title="SDWebImageDownloader"></a>SDWebImageDownloader</h2><p><code>SDWebImageDownloader</code>是个图片下载管理类。</p>
<h3 id="下载选项"><a href="#下载选项" class="headerlink" title="下载选项"></a>下载选项</h3><p>对于下载图片，我们有各自的需求，有的需要适时获取下载的进度；有的需要在后台下载；有的需要图片下载处于一个高优先级。。。。。在这里你能够得到相关选择来完成自己的操作。ps：在tableviewcell中，我们一般使用<code>SDWebImageDownloaderLowPriority</code>低优先级，这样cell滑动的时候就不会那么卡顿。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 下载选项枚举</span><br><span class="line">typedef NS_OPTIONS(NSUInteger, SDWebImageDownloaderOptions) &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 低优先权 </span><br><span class="line">    SDWebImageDownloaderLowPriority &#x3D; 1 &lt;&lt; 0,</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 下载显示进度</span><br><span class="line">    SDWebImageDownloaderProgressiveDownload &#x3D; 1 &lt;&lt; 1,</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * By default, request prevent the of NSURLCache. With this flag, NSURLCache</span><br><span class="line">     * is used with default policies.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 默认情况下请求是不用NSURLCache的。但是如果使用该标志，默认的缓存策略就是使用NSURLCache</span><br><span class="line">    SDWebImageDownloaderUseNSURLCache &#x3D; 1 &lt;&lt; 2,</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Call completion block with nil image&#x2F;imageData if the image was read from NSURLCache</span><br><span class="line">     * (to be combined with &#96;SDWebImageDownloaderUseNSURLCache&#96;).</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 如果图片是从NSURLCache里面读取，则使用nil来作为回调block的入参(与&#96;SDWebImageDownloaderUseNSURLCache&#96;组合使用)</span><br><span class="line">    SDWebImageDownloaderIgnoreCachedResponse &#x3D; 1 &lt;&lt; 3,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * In iOS 4+, continue the download of the image if the app goes to background. This is achieved by asking the system for</span><br><span class="line">     * extra time in background to let the request finish. If the background task expires the operation will be cancelled.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 在iOS4+ 能够在程序进入后台后继续下图片，通过向系统申请额外的时间在后台来完成数据请求操作。如果后台任务终止，则该操作会被取消</span><br><span class="line">    SDWebImageDownloaderContinueInBackground &#x3D; 1 &lt;&lt; 4,</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Handles cookies stored in NSHTTPCookieStore by setting </span><br><span class="line">     * NSMutableURLRequest.HTTPShouldHandleCookies &#x3D; YES;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 通过设置 NSMutableURLRequest.HTTPShouldHandleCookies &#x3D; YES 来处理存储在 NSHTTPCookieStore 的cookies</span><br><span class="line">    SDWebImageDownloaderHandleCookies &#x3D; 1 &lt;&lt; 5,</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Enable to allow untrusted SSL certificates.</span><br><span class="line">     * Useful for testing purposes. Use with caution in production.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 允许使用不信任的SSL证书 这主要是用于测试的目的 在生产环境中得小心</span><br><span class="line">    SDWebImageDownloaderAllowInvalidSSLCertificates &#x3D; 1 &lt;&lt; 6,</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Put the image in the high priority queue.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 将图片下载置于优先级较高的队列</span><br><span class="line">    SDWebImageDownloaderHighPriority &#x3D; 1 &lt;&lt; 7,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="下载顺序"><a href="#下载顺序" class="headerlink" title="下载顺序"></a>下载顺序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 执行顺序</span><br><span class="line">执行顺序有先进先出、先进后出两种方式。</span><br><span class="line">typedef NS_ENUM(NSInteger, SDWebImageDownloaderExecutionOrder) &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Default value. All download operations will execute in queue style (first-in-first-out).</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 先进先出 默认操作顺序</span><br><span class="line">    SDWebImageDownloaderFIFOExecutionOrder,</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * All download operations will execute in stack style (last-in-first-out).</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 先进后出</span><br><span class="line">    SDWebImageDownloaderLIFOExecutionOrder</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="回调block"><a href="#回调block" class="headerlink" title="回调block"></a>回调block</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  下载进度block</span><br><span class="line"> *</span><br><span class="line"> *  @param receivedSize 已收到数据大小</span><br><span class="line"> *  @param expectedSize 应该受到数据大小</span><br><span class="line"> *&#x2F;</span><br><span class="line">typedef void(^SDWebImageDownloaderProgressBlock)(NSInteger receivedSize, NSInteger expectedSize);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  下载完成block</span><br><span class="line"> *</span><br><span class="line"> *  @param image    下载好的图片</span><br><span class="line"> *  @param data     下载的数据</span><br><span class="line"> *  @param error    错误信息</span><br><span class="line"> *  @param finished 是否完成</span><br><span class="line"> *&#x2F;</span><br><span class="line">typedef void(^SDWebImageDownloaderCompletedBlock)(UIImage *image, NSData *data, NSError *error, BOOL finished);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  过滤请求头部信息block</span><br><span class="line"> *</span><br><span class="line"> *  @param url     URL</span><br><span class="line"> *  @param headers 请求头部信息</span><br><span class="line"> *</span><br><span class="line"> *  @return return value description</span><br><span class="line"> *&#x2F;</span><br><span class="line">typedef NSDictionary *(^SDWebImageDownloaderHeadersFilterBlock)(NSURL *url, NSDictionary *headers);</span><br></pre></td></tr></table></figure>
<h3 id="SDWebImageDownloader源码分析"><a href="#SDWebImageDownloader源码分析" class="headerlink" title="SDWebImageDownloader源码分析"></a>SDWebImageDownloader源码分析</h3><p>并发请求图片，最大请求图片的并发数为6；上面提到了进度和完成block，SDWebImageDownloader 有一个字典<code>URLCallbacks</code>来根据URL来存储每一个图片请求的回调block；图片请求类默认为<code>SDWebImageDownloaderOperation</code>类（后面细说）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@interface SDWebImageDownloader ()</span><br><span class="line">&#x2F;&#x2F; 下载操作队列</span><br><span class="line">@property (strong, nonatomic) NSOperationQueue *downloadQueue;</span><br><span class="line">&#x2F;&#x2F; 最后添加的操作 先进后出顺序顺序</span><br><span class="line">@property (weak, nonatomic) NSOperation *lastAddedOperation;</span><br><span class="line">&#x2F;&#x2F; 图片下载类</span><br><span class="line">@property (assign, nonatomic) Class operationClass;</span><br><span class="line">&#x2F;&#x2F; URL回调字典 以URL为key，你装有URL下载的进度block和完成block的数组为value</span><br><span class="line">@property (strong, nonatomic) NSMutableDictionary *URLCallbacks;</span><br><span class="line">&#x2F;&#x2F; HTTP请求头</span><br><span class="line">@property (strong, nonatomic) NSMutableDictionary *HTTPHeaders;</span><br><span class="line">&#x2F;&#x2F; This queue is used to serialize the handling of the network responses of all the download operation in a single queue</span><br><span class="line">&#x2F;&#x2F; 并行的处理所有下载操作的网络响应</span><br><span class="line">@property (SDDispatchQueueSetterSementics, nonatomic) dispatch_queue_t barrierQueue;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>允许多张图片并行同时下载，为了保证<code>URLCallbacks</code>的安全，确保在同一时间只能有一个线程操作<code>URLCallbacks</code>，所以将<code>URLCallbacks</code>的相关操作（赋值、删除）放在了<code>barrierQueue</code>队列中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  下载操作</span><br><span class="line"> *</span><br><span class="line"> *  @param url            下载URL</span><br><span class="line"> *  @param options        下载操作选项</span><br><span class="line"> *  @param progressBlock  进度block</span><br><span class="line"> *  @param completedBlock 完成block</span><br><span class="line"> *</span><br><span class="line"> *  @return 遵循SDWebImageOperation协议的对象</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url options:(SDWebImageDownloaderOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageDownloaderCompletedBlock)completedBlock &#123;</span><br><span class="line">    &#x2F;&#x2F; 下载对象</span><br><span class="line">    __block SDWebImageDownloaderOperation *operation;</span><br><span class="line">    &#x2F;&#x2F; weak self</span><br><span class="line">    __weak __typeof(self)wself &#x3D; self;</span><br><span class="line">    &#x2F;&#x2F; 添加设置回调</span><br><span class="line">    [self addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^&#123;</span><br><span class="line">        &#x2F;&#x2F; 设置延时时长 为 15.0秒</span><br><span class="line">        NSTimeInterval timeoutInterval &#x3D; wself.downloadTimeout;</span><br><span class="line">        if (timeoutInterval &#x3D;&#x3D; 0.0) &#123;</span><br><span class="line">            timeoutInterval &#x3D; 15.0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 创建请求 并根据下载选项设置请求的相关属性</span><br><span class="line">        &#x2F;&#x2F; In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise</span><br><span class="line">        &#x2F;&#x2F; 为了防止潜在的重复缓存(NSURLCache + SDImageCache)，如果没有告诉我们需要缓存，我们不使用图片请求的缓存操作</span><br><span class="line">        NSMutableURLRequest *request &#x3D; [[NSMutableURLRequest alloc] initWithURL:url cachePolicy:(options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData) timeoutInterval:timeoutInterval];</span><br><span class="line">        &#x2F;&#x2F; 是否处理cookies</span><br><span class="line">        request.HTTPShouldHandleCookies &#x3D; (options &amp; SDWebImageDownloaderHandleCookies);</span><br><span class="line">        request.HTTPShouldUsePipelining &#x3D; YES;</span><br><span class="line">        if (wself.headersFilter) &#123;</span><br><span class="line">            request.allHTTPHeaderFields &#x3D; wself.headersFilter(url, [wself.HTTPHeaders copy]);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            request.allHTTPHeaderFields &#x3D; wself.HTTPHeaders;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 创建下载对象 在这里是 SDWebImageDownloaderOperation 类</span><br><span class="line">        operation &#x3D; [[wself.operationClass alloc] initWithRequest:request</span><br><span class="line">                                                          options:options</span><br><span class="line">                                                         progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123;</span><br><span class="line">                                                             &#x2F;&#x2F; strong self</span><br><span class="line">                                                             SDWebImageDownloader *sself &#x3D; wself;</span><br><span class="line">                                                             if (!sself) return;</span><br><span class="line">                                                             &#x2F;&#x2F; URL回调数组</span><br><span class="line">                                                             __block NSArray *callbacksForURL;</span><br><span class="line">                                                             dispatch_sync(sself.barrierQueue, ^&#123;</span><br><span class="line">                                                                 &#x2F;&#x2F; 根据URL获取 相关回调的数组</span><br><span class="line">                                                                 callbacksForURL &#x3D; [sself.URLCallbacks[url] copy];</span><br><span class="line">                                                             &#125;);</span><br><span class="line">                                                             &#x2F;&#x2F; 处理进度回调</span><br><span class="line">                                                             for (NSDictionary *callbacks in callbacksForURL) &#123;</span><br><span class="line">                                                                 dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                                                                     SDWebImageDownloaderProgressBlock callback &#x3D; callbacks[kProgressCallbackKey];</span><br><span class="line">                                                                     if (callback) callback(receivedSize, expectedSize);</span><br><span class="line">                                                                 &#125;);</span><br><span class="line">                                                             &#125;</span><br><span class="line">                                                         &#125;</span><br><span class="line">                                                        completed:^(UIImage *image, NSData *data, NSError *error, BOOL finished) &#123;</span><br><span class="line">                                                            SDWebImageDownloader *sself &#x3D; wself;</span><br><span class="line">                                                            if (!sself) return;</span><br><span class="line">                                                            __block NSArray *callbacksForURL;</span><br><span class="line">                                                            dispatch_barrier_sync(sself.barrierQueue, ^&#123;</span><br><span class="line">                                                                callbacksForURL &#x3D; [sself.URLCallbacks[url] copy];</span><br><span class="line">                                                                &#x2F;&#x2F; 如果下载完成 则从回调数组里面删除</span><br><span class="line">                                                                if (finished) &#123;</span><br><span class="line">                                                                    [sself.URLCallbacks removeObjectForKey:url];</span><br><span class="line">                                                                &#125;</span><br><span class="line">                                                            &#125;);</span><br><span class="line">                                                            &#x2F;&#x2F; 处理下载完成回调</span><br><span class="line">                                                            for (NSDictionary *callbacks in callbacksForURL) &#123;</span><br><span class="line">                                                                SDWebImageDownloaderCompletedBlock callback &#x3D; callbacks[kCompletedCallbackKey];</span><br><span class="line">                                                                if (callback) callback(image, data, error, finished);</span><br><span class="line">                                                            &#125;</span><br><span class="line">                                                        &#125;</span><br><span class="line">                                                        cancelled:^&#123;</span><br><span class="line">                                                            &#x2F;&#x2F; 下载被取消 从回调数组里面删除</span><br><span class="line">                                                            SDWebImageDownloader *sself &#x3D; wself;</span><br><span class="line">                                                            if (!sself) return;</span><br><span class="line">                                                            dispatch_barrier_async(sself.barrierQueue, ^&#123;</span><br><span class="line">                                                                [sself.URLCallbacks removeObjectForKey:url];</span><br><span class="line">                                                            &#125;);</span><br><span class="line">                                                        &#125;];</span><br><span class="line">        &#x2F;&#x2F; 是否解压图片</span><br><span class="line">        operation.shouldDecompressImages &#x3D; wself.shouldDecompressImages;</span><br><span class="line">        &#x2F;&#x2F; URL证书、用户名密码</span><br><span class="line">        if (wself.urlCredential) &#123;</span><br><span class="line">            operation.credential &#x3D; wself.urlCredential;</span><br><span class="line">        &#125; else if (wself.username &amp;&amp; wself.password) &#123;</span><br><span class="line">            operation.credential &#x3D; [NSURLCredential credentialWithUser:wself.username password:wself.password persistence:NSURLCredentialPersistenceForSession];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 设置队列的优先级</span><br><span class="line">        if (options &amp; SDWebImageDownloaderHighPriority) &#123;</span><br><span class="line">            operation.queuePriority &#x3D; NSOperationQueuePriorityHigh;</span><br><span class="line">        &#125; else if (options &amp; SDWebImageDownloaderLowPriority) &#123;</span><br><span class="line">            operation.queuePriority &#x3D; NSOperationQueuePriorityLow;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 将下载操作添加到下载队列中</span><br><span class="line">        [wself.downloadQueue addOperation:operation];</span><br><span class="line">        &#x2F;&#x2F; 如果是先进后出操作顺序 则将该操作置为最后一个操作</span><br><span class="line">        if (wself.executionOrder &#x3D;&#x3D; SDWebImageDownloaderLIFOExecutionOrder) &#123;</span><br><span class="line">            &#x2F;&#x2F; Emulate LIFO execution order by systematically adding new operations as last operation&#39;s dependency</span><br><span class="line">            [wself.lastAddedOperation addDependency:operation];</span><br><span class="line">            wself.lastAddedOperation &#x3D; operation;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  添加设置回调</span><br><span class="line"> *</span><br><span class="line"> *  @param progressBlock  下载进度block</span><br><span class="line"> *  @param completedBlock 下载完成block</span><br><span class="line"> *  @param url            下载URL</span><br><span class="line"> *  @param createCallback 创建回调block</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock forURL:(NSURL *)url createCallback:(SDWebImageNoParamsBlock)createCallback &#123;</span><br><span class="line">    &#x2F;&#x2F; The URL will be used as the key to the callbacks dictionary so it cannot be nil. If it is nil immediately call the completed block with no image or data.</span><br><span class="line">    &#x2F;&#x2F; URL不能为空</span><br><span class="line">    if (url &#x3D;&#x3D; nil) &#123;</span><br><span class="line">        if (completedBlock !&#x3D; nil) &#123;</span><br><span class="line">            completedBlock(nil, nil, nil, NO);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; dispatch_barrier_sync 保证同一时间只有一个线程操作 URLCallbacks</span><br><span class="line">    dispatch_barrier_sync(self.barrierQueue, ^&#123;</span><br><span class="line">        &#x2F;&#x2F; 是否第一次操作</span><br><span class="line">        BOOL first &#x3D; NO;</span><br><span class="line">        if (!self.URLCallbacks[url]) &#123;</span><br><span class="line">            self.URLCallbacks[url] &#x3D; [NSMutableArray new];</span><br><span class="line">            first &#x3D; YES;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Handle single download of simultaneous download request for the same URL</span><br><span class="line">        &#x2F;&#x2F; 处理 同一个URL的单个下载</span><br><span class="line">        NSMutableArray *callbacksForURL &#x3D; self.URLCallbacks[url];</span><br><span class="line">        NSMutableDictionary *callbacks &#x3D; [NSMutableDictionary new];</span><br><span class="line">        &#x2F;&#x2F; 将 进度block和完成block赋值</span><br><span class="line">        if (progressBlock) callbacks[kProgressCallbackKey] &#x3D; [progressBlock copy];</span><br><span class="line">        if (completedBlock) callbacks[kCompletedCallbackKey] &#x3D; [completedBlock copy];</span><br><span class="line">        [callbacksForURL addObject:callbacks];</span><br><span class="line">        &#x2F;&#x2F; 已URL为key进行赋值</span><br><span class="line">        self.URLCallbacks[url] &#x3D; callbacksForURL;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 如果是第一次下载 则回调</span><br><span class="line">        if (first) &#123;</span><br><span class="line">            createCallback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>downloadImageWithURL: options: progress: completed:</code>方法是该类的核心，它返回一个遵循<code>SDWebImageOperation </code>协议的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@protocol SDWebImageOperation &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">- (void)cancel;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>该协议只定义了一个<code>cancel</code>方法，用来取消图片下载请求。</p>
<h2 id="SDWebImageDownloaderOperation"><a href="#SDWebImageDownloaderOperation" class="headerlink" title="SDWebImageDownloaderOperation"></a>SDWebImageDownloaderOperation</h2><p><code>SDWebImageDownloaderOperation</code>是一个继承自<code>NSOperation</code>并遵循<code>SDWebImageOperation</code>协议的类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface SDWebImageDownloaderOperation : NSOperation &lt;SDWebImageOperation&gt;</span><br></pre></td></tr></table></figure>
<p><code>SDWebImageDownloaderOperation</code>主要通过<code>NSURLConnection</code>来获取数据。<br>通过 <code>NSNotificationCenter</code>来告诉其他类下载的相关进程。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 开始下载</span><br><span class="line">NSString *const SDWebImageDownloadStartNotification &#x3D; @&quot;SDWebImageDownloadStartNotification&quot;;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 开始接受到数据</span><br><span class="line">NSString *const SDWebImageDownloadReceiveResponseNotification &#x3D; @&quot;SDWebImageDownloadReceiveResponseNotification&quot;;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 停止下载</span><br><span class="line">NSString *const SDWebImageDownloadStopNotification &#x3D; @&quot;SDWebImageDownloadStopNotification&quot;;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 完成下载</span><br><span class="line">NSString *const SDWebImageDownloadFinishNotification &#x3D; @&quot;SDWebImageDownloadFinishNotification&quot;;</span><br></pre></td></tr></table></figure><br>本类中用到了<code>NSURLConnectionDataDelegate</code>和<code>NSURLConnectionDelegate</code>的几个代理方法：</p>
<h3 id="NSURLConnectionDataDelegate"><a href="#NSURLConnectionDataDelegate" class="headerlink" title="NSURLConnectionDataDelegate"></a>NSURLConnectionDataDelegate</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response;</span><br><span class="line"></span><br><span class="line">- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data;</span><br><span class="line"></span><br><span class="line">- (void)connectionDidFinishLoading:(NSURLConnection *)connection;</span><br><span class="line"></span><br><span class="line">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</span><br></pre></td></tr></table></figure>
<h3 id="NSURLConnectionDelegate"><a href="#NSURLConnectionDelegate" class="headerlink" title="NSURLConnectionDelegate"></a>NSURLConnectionDelegate</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error;</span><br><span class="line"></span><br><span class="line">- (BOOL)connectionShouldUseCredentialStorage:(NSURLConnection *)connection;</span><br><span class="line"></span><br><span class="line">- (void)connection:(NSURLConnection *)connection willSendRequestForAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge;</span><br></pre></td></tr></table></figure>
<p>我现在只分析<code>- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response;</code>和<code>- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data;</code>两个主要方法，其他相关的方法，在研究<a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a>(虽然现在已用<code>NSURLSession</code>来处理)再细看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  接受到服务端反应</span><br><span class="line"> *</span><br><span class="line"> *  @param connection connection description</span><br><span class="line"> *  @param response   response description</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#39;304 Not Modified&#39; is an exceptional one</span><br><span class="line">    &#x2F;&#x2F; &#39;304 Not Modified&#39; 特殊处理</span><br><span class="line">    if (![response respondsToSelector:@selector(statusCode)] || ([((NSHTTPURLResponse *)response) statusCode] &lt; 400 &amp;&amp; [((NSHTTPURLResponse *)response) statusCode] !&#x3D; 304)) &#123;</span><br><span class="line">        &#x2F;&#x2F; 下载图片的期望大小</span><br><span class="line">        NSInteger expected &#x3D; response.expectedContentLength &gt; 0 ? (NSInteger)response.expectedContentLength : 0;</span><br><span class="line">        self.expectedSize &#x3D; expected;</span><br><span class="line">        &#x2F;&#x2F; 进度block回调</span><br><span class="line">        if (self.progressBlock) &#123;</span><br><span class="line">            self.progressBlock(0, expected);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 创建imageData</span><br><span class="line">        self.imageData &#x3D; [[NSMutableData alloc] initWithCapacity:expected];</span><br><span class="line">        &#x2F;&#x2F; response赋值</span><br><span class="line">        self.response &#x3D; response;</span><br><span class="line">        &#x2F;&#x2F; 通知 已经接受到消息相应</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadReceiveResponseNotification object:self];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        &#x2F;&#x2F; 获取状态码</span><br><span class="line">        NSUInteger code &#x3D; [((NSHTTPURLResponse *)response) statusCode];</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;This is the case when server returns &#39;304 Not Modified&#39;. It means that remote image is not changed.</span><br><span class="line">        &#x2F;&#x2F;In case of 304 we need just cancel the operation and return cached image from the cache.</span><br><span class="line">        &#x2F;&#x2F; 如果为304 服务端图片没有修改 则取消内部相关操作</span><br><span class="line">        if (code &#x3D;&#x3D; 304) &#123;</span><br><span class="line">            [self cancelInternal];</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F; 取消网络请求图片</span><br><span class="line">            [self.connection cancel];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 通知 停止下载图片</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:self];</span><br><span class="line">        &#125;);</span><br><span class="line">        &#x2F;&#x2F; 完成block回调 下载错误</span><br><span class="line">        if (self.completedBlock) &#123;</span><br><span class="line">            self.completedBlock(nil, nil, [NSError errorWithDomain:NSURLErrorDomain code:[((NSHTTPURLResponse *)response) statusCode] userInfo:nil], YES);</span><br><span class="line">        &#125;</span><br><span class="line">        CFRunLoopStop(CFRunLoopGetCurrent());</span><br><span class="line">        [self done];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  接收到数据</span><br><span class="line"> *</span><br><span class="line"> *  @param connection &lt;#connection description#&gt;</span><br><span class="line"> *  @param data       &lt;#data description#&gt;</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data &#123;</span><br><span class="line">    &#x2F;&#x2F; 追加数据</span><br><span class="line">    [self.imageData appendData:data];</span><br><span class="line">    </span><br><span class="line">    if ((self.options &amp; SDWebImageDownloaderProgressiveDownload) &amp;&amp; self.expectedSize &gt; 0 &amp;&amp; self.completedBlock) &#123;</span><br><span class="line">        &#x2F;&#x2F; The following code is from http:&#x2F;&#x2F;www.cocoaintheshell.com&#x2F;2011&#x2F;05&#x2F;progressive-images-download-imageio&#x2F;</span><br><span class="line">        &#x2F;&#x2F; Thanks to the author @Nyx0uf</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Get the total bytes downloaded</span><br><span class="line">        &#x2F;&#x2F; 获取已下载的图片大小</span><br><span class="line">        const NSInteger totalSize &#x3D; self.imageData.length;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Update the data source, we must pass ALL the data, not just the new bytes</span><br><span class="line">        &#x2F;&#x2F; 更新数据源，我们必须传入所有的数据 并不是这次接受到的新数据</span><br><span class="line">        CGImageSourceRef imageSource &#x3D; CGImageSourceCreateWithData((__bridge CFDataRef)self.imageData, NULL);</span><br><span class="line">        &#x2F;&#x2F; 如果宽和高都为0 即第一次接受到数据</span><br><span class="line">        if (width + height &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; 获取图片的高、宽、方向等相关数据 并赋值</span><br><span class="line">            CFDictionaryRef properties &#x3D; CGImageSourceCopyPropertiesAtIndex(imageSource, 0, NULL);</span><br><span class="line">            if (properties) &#123;</span><br><span class="line">                NSInteger orientationValue &#x3D; -1;</span><br><span class="line">                CFTypeRef val &#x3D; CFDictionaryGetValue(properties, kCGImagePropertyPixelHeight);</span><br><span class="line">                if (val) CFNumberGetValue(val, kCFNumberLongType, &amp;height);</span><br><span class="line">                val &#x3D; CFDictionaryGetValue(properties, kCGImagePropertyPixelWidth);</span><br><span class="line">                if (val) CFNumberGetValue(val, kCFNumberLongType, &amp;width);</span><br><span class="line">                val &#x3D; CFDictionaryGetValue(properties, kCGImagePropertyOrientation);</span><br><span class="line">                if (val) CFNumberGetValue(val, kCFNumberNSIntegerType, &amp;orientationValue);</span><br><span class="line">                CFRelease(properties);</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; When we draw to Core Graphics, we lose orientation information,</span><br><span class="line">                &#x2F;&#x2F; which means the image below born of initWithCGIImage will be</span><br><span class="line">                &#x2F;&#x2F; oriented incorrectly sometimes. (Unlike the image born of initWithData</span><br><span class="line">                &#x2F;&#x2F; in connectionDidFinishLoading.) So save it here and pass it on later.</span><br><span class="line">                &#x2F;&#x2F; 当我们绘制 Core Graphics 时，我们将会失去图片方向的信息，这意味着有时候由initWithCGIImage方法所创建的图片的方向会不正确（不像在 connectionDidFinishLoading 代理方法里面 用 initWithData 方法创建），所以我们先在这里保存这个信息并在后面使用。</span><br><span class="line">                orientation &#x3D; [[self class] orientationFromPropertyValue:(orientationValue &#x3D;&#x3D; -1 ? 1 : orientationValue)];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 已经接受到数据 图片还没下载完成</span><br><span class="line">        if (width + height &gt; 0 &amp;&amp; totalSize &lt; self.expectedSize) &#123;</span><br><span class="line">            &#x2F;&#x2F; Create the image</span><br><span class="line">            &#x2F;&#x2F; 先去第一张 部分图片</span><br><span class="line">            CGImageRef partialImageRef &#x3D; CGImageSourceCreateImageAtIndex(imageSource, 0, NULL);</span><br><span class="line"></span><br><span class="line">#ifdef TARGET_OS_IPHONE</span><br><span class="line">            &#x2F;&#x2F; Workaround for iOS anamorphic image</span><br><span class="line">            &#x2F;&#x2F; 对iOS变形图片工作(不是很理解)</span><br><span class="line">            if (partialImageRef) &#123;</span><br><span class="line">                const size_t partialHeight &#x3D; CGImageGetHeight(partialImageRef);</span><br><span class="line">                CGColorSpaceRef colorSpace &#x3D; CGColorSpaceCreateDeviceRGB();</span><br><span class="line">                CGContextRef bmContext &#x3D; CGBitmapContextCreate(NULL, width, height, 8, width * 4, colorSpace, kCGBitmapByteOrderDefault | kCGImageAlphaPremultipliedFirst);</span><br><span class="line">                CGColorSpaceRelease(colorSpace);</span><br><span class="line">                if (bmContext) &#123;</span><br><span class="line">                    CGContextDrawImage(bmContext, (CGRect)&#123;.origin.x &#x3D; 0.0f, .origin.y &#x3D; 0.0f, .size.width &#x3D; width, .size.height &#x3D; partialHeight&#125;, partialImageRef);</span><br><span class="line">                    CGImageRelease(partialImageRef);</span><br><span class="line">                    partialImageRef &#x3D; CGBitmapContextCreateImage(bmContext);</span><br><span class="line">                    CGContextRelease(bmContext);</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    CGImageRelease(partialImageRef);</span><br><span class="line">                    partialImageRef &#x3D; nil;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">#endif</span><br><span class="line">            &#x2F;&#x2F; 存储图片</span><br><span class="line">            if (partialImageRef) &#123;</span><br><span class="line">                UIImage *image &#x3D; [UIImage imageWithCGImage:partialImageRef scale:1 orientation:orientation];</span><br><span class="line">                &#x2F;&#x2F; 获取key</span><br><span class="line">                NSString *key &#x3D; [[SDWebImageManager sharedManager] cacheKeyForURL:self.request.URL];</span><br><span class="line">                &#x2F;&#x2F; 获取缩放的图片</span><br><span class="line">                UIImage *scaledImage &#x3D; [self scaledImageForKey:key image:image];</span><br><span class="line">                &#x2F;&#x2F; 解压图片</span><br><span class="line">                if (self.shouldDecompressImages) &#123;</span><br><span class="line">                    image &#x3D; [UIImage decodedImageWithImage:scaledImage];</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    image &#x3D; scaledImage;</span><br><span class="line">                &#125;</span><br><span class="line">                CGImageRelease(partialImageRef);</span><br><span class="line">                &#x2F;&#x2F; 完成block回调</span><br><span class="line">                dispatch_main_sync_safe(^&#123;</span><br><span class="line">                    if (self.completedBlock) &#123;</span><br><span class="line">                        self.completedBlock(image, nil, nil, NO);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CFRelease(imageSource);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 进度block回调</span><br><span class="line">    if (self.progressBlock) &#123;</span><br><span class="line">        self.progressBlock(self.imageData.length, self.expectedSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对<code>- connection:didReceiveData:</code>方法里面的数据处理有点费解。</p>
<p>再来看看<code>start</code>开始请求方法，在该方法中启动了<code>runloop</code>，当然在其他代理方法，不管请求数据是否成功，都得停止。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">- (void)start &#123;</span><br><span class="line">    @synchronized (self) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果被取消了</span><br><span class="line">        if (self.isCancelled) &#123;</span><br><span class="line">            &#x2F;&#x2F; 则已经完成</span><br><span class="line">            self.finished &#x3D; YES;</span><br><span class="line">            &#x2F;&#x2F; 重置</span><br><span class="line">            [self reset];</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">#if TARGET_OS_IPHONE &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;&#x3D; __IPHONE_4_0</span><br><span class="line">        &#x2F;&#x2F; 后台处理</span><br><span class="line">        Class UIApplicationClass &#x3D; NSClassFromString(@&quot;UIApplication&quot;);</span><br><span class="line">        BOOL hasApplication &#x3D; UIApplicationClass &amp;&amp; [UIApplicationClass respondsToSelector:@selector(sharedApplication)];</span><br><span class="line">        if (hasApplication &amp;&amp; [self shouldContinueWhenAppEntersBackground]) &#123;</span><br><span class="line">            __weak __typeof__ (self) wself &#x3D; self;</span><br><span class="line">            UIApplication * app &#x3D; [UIApplicationClass performSelector:@selector(sharedApplication)];</span><br><span class="line">            self.backgroundTaskId &#x3D; [app beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">                __strong __typeof (wself) sself &#x3D; wself;</span><br><span class="line"></span><br><span class="line">                if (sself) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 取消</span><br><span class="line">                    [sself cancel];</span><br><span class="line"></span><br><span class="line">                    [app endBackgroundTask:sself.backgroundTaskId];</span><br><span class="line">                    sself.backgroundTaskId &#x3D; UIBackgroundTaskInvalid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">        &#x2F;&#x2F; 正在执行中</span><br><span class="line">        self.executing &#x3D; YES;</span><br><span class="line">        self.connection &#x3D; [[NSURLConnection alloc] initWithRequest:self.request delegate:self startImmediately:NO];</span><br><span class="line">        self.thread &#x3D; [NSThread currentThread];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 开始请求</span><br><span class="line">    [self.connection start];</span><br><span class="line"></span><br><span class="line">    if (self.connection) &#123;</span><br><span class="line">        &#x2F;&#x2F; 进度block回调</span><br><span class="line">        if (self.progressBlock) &#123;</span><br><span class="line">            self.progressBlock(0, NSURLResponseUnknownLength);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 通知 开始下载</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:self];</span><br><span class="line">        &#125;);</span><br><span class="line">        &#x2F;&#x2F; 开始运行 runloop</span><br><span class="line">        if (floor(NSFoundationVersionNumber) &lt;&#x3D; NSFoundationVersionNumber_iOS_5_1) &#123;</span><br><span class="line">            &#x2F;&#x2F; Make sure to run the runloop in our background thread so it can process downloaded data</span><br><span class="line">            &#x2F;&#x2F; Note: we use a timeout to work around an issue with NSURLConnection cancel under iOS 5</span><br><span class="line">            &#x2F;&#x2F;       not waking up the runloop, leading to dead threads (see https:&#x2F;&#x2F;github.com&#x2F;rs&#x2F;SDWebImage&#x2F;issues&#x2F;466)</span><br><span class="line">            CFRunLoopRunInMode(kCFRunLoopDefaultMode, 10, false);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            CFRunLoopRun();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;  没有完成 则取消</span><br><span class="line">        if (!self.isFinished) &#123;</span><br><span class="line">            [self.connection cancel];</span><br><span class="line">            [self connection:self.connection didFailWithError:[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorTimedOut userInfo:@&#123;NSURLErrorFailingURLErrorKey : self.request.URL&#125;]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        &#x2F;&#x2F; connection对象不存在 回调相关错误信息</span><br><span class="line">        if (self.completedBlock) &#123;</span><br><span class="line">            self.completedBlock(nil, nil, [NSError errorWithDomain:NSURLErrorDomain code:0 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Connection can&#39;t be initialized&quot;&#125;], YES);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#if TARGET_OS_IPHONE &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;&#x3D; __IPHONE_4_0</span><br><span class="line">    &#x2F;&#x2F; 后台处理</span><br><span class="line">    Class UIApplicationClass &#x3D; NSClassFromString(@&quot;UIApplication&quot;);</span><br><span class="line">    if(!UIApplicationClass || ![UIApplicationClass respondsToSelector:@selector(sharedApplication)]) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (self.backgroundTaskId !&#x3D; UIBackgroundTaskInvalid) &#123;</span><br><span class="line">        UIApplication * app &#x3D; [UIApplication performSelector:@selector(sharedApplication)];</span><br><span class="line">        [app endBackgroundTask:self.backgroundTaskId];</span><br><span class="line">        self.backgroundTaskId &#x3D; UIBackgroundTaskInvalid;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本类有两个变量来标识请求状态，在外层可以根据这两个标志能够来做相关处理。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 是否正在请求数据中</span><br><span class="line">@property (assign, nonatomic, getter &#x3D; isExecuting) BOOL executing;</span><br><span class="line">&#x2F;&#x2F; 请求是否已完成</span><br><span class="line">@property (assign, nonatomic, getter &#x3D; isFinished) BOOL finished;</span><br></pre></td></tr></table></figure></p>
<h1 id="Utils"><a href="#Utils" class="headerlink" title="Utils"></a>Utils</h1><p>该文件夹里面主要是对图片进行操作的相关工具类，<code>SDWebImageManager</code>是<code>SD</code>的核心所在，管理图片的缓存和下载，我们项目中熟悉的<code>[imagevie sd_setImageWithURL:]</code>则主要用到了该类；<code>SDWebImageDecoder</code>是强制解压图片的，该方法主要是防止图片加载时有延时，但是用这个方法会导致内存暴涨等问题；<code>SDWebImagePrefetcher</code>是预取图片类。</p>
<h2 id="SDWebImageManager"><a href="#SDWebImageManager" class="headerlink" title="SDWebImageManager"></a>SDWebImageManager</h2><p><code>SDWebImageManager</code>管理着缓存<code>SDImageCache</code>和下载<code>SDWebImageDownloader</code>类的对象。我们在这个类可以得到关于下载和缓存的相关状态。本类有12个关于管理的<code>SDWebImageOptions</code>操作类型，与<code>SDWebImageDownloader</code>的 <code>SDWebImageDownloaderOptions</code>操作类型相似。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 管理操作类型</span><br><span class="line">typedef NS_OPTIONS(NSUInteger, SDWebImageOptions) &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * By default, when a URL fail to be downloaded, the URL is blacklisted so the library won&#39;t keep trying.</span><br><span class="line">     * This flag disable this blacklisting.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 默认情况下，当一个URL下载失败后，这个URL将会加入黑名单，下次不会尝试下载。这个标志可以不让它加入黑名单</span><br><span class="line">    SDWebImageRetryFailed &#x3D; 1 &lt;&lt; 0,</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * By default, image downloads are started during UI interactions, this flags disable this feature,</span><br><span class="line">     * leading to delayed download on UIScrollView deceleration for instance.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 默认情况下，图片在UI交互的时候下载，这个标志可以取消这个特点。下载图片延时到UIScrollView减速的时候</span><br><span class="line">    SDWebImageLowPriority &#x3D; 1 &lt;&lt; 1,</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * This flag disables on-disk caching</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 只存储在内存 不存储在磁盘</span><br><span class="line">    SDWebImageCacheMemoryOnly &#x3D; 1 &lt;&lt; 2,</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * This flag enables progressive download, the image is displayed progressively during download as a browser would do.</span><br><span class="line">     * By default, the image is only displayed once completely downloaded.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 让图片逐渐的下载，在下载过程中图片像浏览器一样逐渐的显示出来。默认情况下，图片在下载完成以后才显示出来。</span><br><span class="line">    SDWebImageProgressiveDownload &#x3D; 1 &lt;&lt; 3,</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Even if the image is cached, respect the HTTP response cache control, and refresh the image from remote location if needed.</span><br><span class="line">     * The disk caching will be handled by NSURLCache instead of SDWebImage leading to slight performance degradation.</span><br><span class="line">     * This option helps deal with images changing behind the same request URL, e.g. Facebook graph api profile pics.</span><br><span class="line">     * If a cached image is refreshed, the completion block is called once with the cached image and again with the final image.</span><br><span class="line">     *</span><br><span class="line">     * Use this flag only if you can&#39;t make your URLs static with embedded cache busting parameter.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 尽管图片有缓存，但是希望能够响应缓存控制，并且在需要的情况下从服务端刷新图片。 磁盘缓存将会被NSURLCache处理，而不是SDWebImage处理，因为SDWebImage将会带来轻微的性能下降。这个操作能够在相同URL后面帮助改变图片，像Facebook的profile pics一样。如果缓存图片被刷新了，那完成block将会用被缓存的图片调用一次，并在图片下载完后再调用一次。使用该标志只有在你需要刷新缓存图片的时候</span><br><span class="line">    SDWebImageRefreshCached &#x3D; 1 &lt;&lt; 4,</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * In iOS 4+, continue the download of the image if the app goes to background. This is achieved by asking the system for</span><br><span class="line">     * extra time in background to let the request finish. If the background task expires the operation will be cancelled.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 后台请求</span><br><span class="line">    SDWebImageContinueInBackground &#x3D; 1 &lt;&lt; 5,</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Handles cookies stored in NSHTTPCookieStore by setting</span><br><span class="line">     * NSMutableURLRequest.HTTPShouldHandleCookies &#x3D; YES;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    SDWebImageHandleCookies &#x3D; 1 &lt;&lt; 6,</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Enable to allow untrusted SSL certificates.</span><br><span class="line">     * Useful for testing purposes. Use with caution in production.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    SDWebImageAllowInvalidSSLCertificates &#x3D; 1 &lt;&lt; 7,</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * By default, image are loaded in the order they were queued. This flag move them to</span><br><span class="line">     * the front of the queue and is loaded immediately instead of waiting for the current queue to be loaded (which </span><br><span class="line">     * could take a while).</span><br><span class="line">     *&#x2F;</span><br><span class="line">    SDWebImageHighPriority &#x3D; 1 &lt;&lt; 8,</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * By default, placeholder images are loaded while the image is loading. This flag will delay the loading</span><br><span class="line">     * of the placeholder image until after the image has finished loading.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 在默认情况下，占位符图片在图片下载的时候就会被加载。使用这个标志，将会延时加载占位符图片直到图片下载成功。</span><br><span class="line">    SDWebImageDelayPlaceholder &#x3D; 1 &lt;&lt; 9,</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * We usually don&#39;t call transformDownloadedImage delegate method on animated images,</span><br><span class="line">     * as most transformation code would mangle it.</span><br><span class="line">     * Use this flag to transform them anyway.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 我们平常不调用动画图片的 transformDownloadedImage 代理方法，大部分的转换代码会损坏它，使用这个标志能在任何情况下转换它们</span><br><span class="line">    SDWebImageTransformAnimatedImage &#x3D; 1 &lt;&lt; 10,</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * By default, image is added to the imageView after download. But in some cases, we want to</span><br><span class="line">     * have the hand before setting the image (apply a filter or add it with cross-fade animation for instance)</span><br><span class="line">     * Use this flag if you want to manually set the image in the completion when success</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 默认情况下，图片下载完成以后就添加到imageview上。但是在某些情况下，我们想着设置图片之前做一些操作（比如增加一些动画什么之类的）如果你想图片下载成功后在完成block里面手动设置图片，那就使用这个标志</span><br><span class="line">    SDWebImageAvoidAutoSetImage &#x3D; 1 &lt;&lt; 11</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>同时也定义了关于下载完成和获取缓存key的block回调。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  下载图片block</span><br><span class="line"> *</span><br><span class="line"> *  @param image     图片</span><br><span class="line"> *  @param error     错误信息</span><br><span class="line"> *  @param cacheType 缓存类型</span><br><span class="line"> *  @param imageURL  图片URL</span><br><span class="line"> *&#x2F;</span><br><span class="line">typedef void(^SDWebImageCompletionBlock)(UIImage *image, NSError *error, SDImageCacheType cacheType, NSURL *imageURL);</span><br><span class="line"></span><br><span class="line">typedef void(^SDWebImageCompletionWithFinishedBlock)(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  根据URL过滤获取缓存的key</span><br><span class="line"> *</span><br><span class="line"> *  @param url url description</span><br><span class="line"> *</span><br><span class="line"> *  @return return value description</span><br><span class="line"> *&#x2F;</span><br><span class="line">typedef NSString *(^SDWebImageCacheKeyFilterBlock)(NSURL *url);</span><br></pre></td></tr></table></figure><br>本来还定义了一个协议 <code>SDWebImageManagerDelegate</code>，用来设置是否下载图片以及在缓存图片之前对图片进行转换。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@protocol SDWebImageManagerDelegate &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">@optional</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Controls which image should be downloaded when the image is not found in the cache.</span><br><span class="line"> *</span><br><span class="line"> * @param imageManager The current &#96;SDWebImageManager&#96;</span><br><span class="line"> * @param imageURL     The url of the image to be downloaded</span><br><span class="line"> *</span><br><span class="line"> * @return Return NO to prevent the downloading of the image on cache misses. If not implemented, YES is implied.</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 在图片没有在缓存里的时候，控制图片是否下载。 返回NO，如果图片没有在缓存里面的时候不下载图片。如果该方法没有被实现，那就为YES。</span><br><span class="line">- (BOOL)imageManager:(SDWebImageManager *)imageManager shouldDownloadImageForURL:(NSURL *)imageURL;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Allows to transform the image immediately after it has been downloaded and just before to cache it on disk and memory.</span><br><span class="line"> * NOTE: This method is called from a global queue in order to not to block the main thread.</span><br><span class="line"> *</span><br><span class="line"> * @param imageManager The current &#96;SDWebImageManager&#96;</span><br><span class="line"> * @param image        The image to transform</span><br><span class="line"> * @param imageURL     The url of the image to transform</span><br><span class="line"> *</span><br><span class="line"> * @return The transformed image object.</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 允许马上转换图片在图片下载完成之后，并在在缓存图片之前。注意，该方法在全局队列里面完成 为了不堵塞主线程。</span><br><span class="line">- (UIImage *)imageManager:(SDWebImageManager *)imageManager transformDownloadedImage:(UIImage *)image withURL:(NSURL *)imageURL;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><br>该类除了下载对象和缓存对象，还有两个集合容器来装失败的URL以及管理图片下载的操作线程。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@interface SDWebImageManager ()</span><br><span class="line">&#x2F;&#x2F; 缓存对象</span><br><span class="line">@property (strong, nonatomic, readwrite) SDImageCache *imageCache;</span><br><span class="line">&#x2F;&#x2F; 下载对象</span><br><span class="line">@property (strong, nonatomic, readwrite) SDWebImageDownloader *imageDownloader;</span><br><span class="line">&#x2F;&#x2F; 失败的URL集合</span><br><span class="line">@property (strong, nonatomic) NSMutableSet *failedURLs;</span><br><span class="line">&#x2F;&#x2F; 操作线程数组</span><br><span class="line">@property (strong, nonatomic) NSMutableArray *runningOperations;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><br>其他准备工作已做好，来瞧瞧下载管理图片的代码吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  下载管理图片</span><br><span class="line"> *</span><br><span class="line"> *  @param url            URL</span><br><span class="line"> *  @param options        操作选项</span><br><span class="line"> *  @param progressBlock  进度block</span><br><span class="line"> *  @param completedBlock 完成block</span><br><span class="line"> *</span><br><span class="line"> *  @return &lt;#return value description#&gt;</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url</span><br><span class="line">                                         options:(SDWebImageOptions)options</span><br><span class="line">                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                       completed:(SDWebImageCompletionWithFinishedBlock)completedBlock &#123;</span><br><span class="line">    &#x2F;&#x2F; Invoking this method without a completedBlock is pointless</span><br><span class="line">    NSAssert(completedBlock !&#x3D; nil, @&quot;If you mean to prefetch the image, use -[SDWebImagePrefetcher prefetchURLs] instead&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Very common mistake is to send the URL using NSString object instead of NSURL. For some strange reason, XCode won&#39;t</span><br><span class="line">    &#x2F;&#x2F; throw any warning for this type mismatch. Here we failsafe this error by allowing URLs to be passed as NSString.</span><br><span class="line">    &#x2F;&#x2F; 一个非常普通的错误就是把NSString对象当做NSURL来使用，但是Xcode却不能提示这种类型的错误。所以这里做一下处理</span><br><span class="line">    if ([url isKindOfClass:NSString.class]) &#123;</span><br><span class="line">        url &#x3D; [NSURL URLWithString:(NSString *)url];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Prevents app crashing on argument type error like sending NSNull instead of NSURL</span><br><span class="line">    &#x2F;&#x2F; 防止URL为空时 程序崩溃</span><br><span class="line">    if (![url isKindOfClass:NSURL.class]) &#123;</span><br><span class="line">        url &#x3D; nil;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 创建对象 并弱引用</span><br><span class="line">    __block SDWebImageCombinedOperation *operation &#x3D; [SDWebImageCombinedOperation new];</span><br><span class="line">    __weak SDWebImageCombinedOperation *weakOperation &#x3D; operation;</span><br><span class="line">    &#x2F;&#x2F; 是否是失败的URL</span><br><span class="line">    BOOL isFailedUrl &#x3D; NO;</span><br><span class="line">    @synchronized (self.failedURLs) &#123;</span><br><span class="line">        isFailedUrl &#x3D; [self.failedURLs containsObject:url];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; url长度为0 获取 该url已下载失败过，并且操作类型没有禁用掉黑名单列表 那么该图片就下载失败，返回失败block</span><br><span class="line">    if (url.absoluteString.length &#x3D;&#x3D; 0 || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) &#123;</span><br><span class="line">        dispatch_main_sync_safe(^&#123;</span><br><span class="line">            NSError *error &#x3D; [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];</span><br><span class="line">            completedBlock(nil, error, SDImageCacheTypeNone, YES, url);</span><br><span class="line">        &#125;);</span><br><span class="line">        return operation;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 将该操作线程添加到数值里面</span><br><span class="line">    @synchronized (self.runningOperations) &#123;</span><br><span class="line">        [self.runningOperations addObject:operation];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 根据URL获取缓存的key</span><br><span class="line">    NSString *key &#x3D; [self cacheKeyForURL:url];</span><br><span class="line">    &#x2F;&#x2F; 根据key从缓存里面找</span><br><span class="line">    operation.cacheOperation &#x3D; [self.imageCache queryDiskCacheForKey:key done:^(UIImage *image, SDImageCacheType cacheType) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果线程被取消 则删除该操作</span><br><span class="line">        if (operation.isCancelled) &#123;</span><br><span class="line">            @synchronized (self.runningOperations) &#123;</span><br><span class="line">                [self.runningOperations removeObject:operation];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 没有图片 或者 操作类型会刷新缓存 并且 delegate允许下载图片</span><br><span class="line">        if ((!image || options &amp; SDWebImageRefreshCached) &amp;&amp; (![self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self shouldDownloadImageForURL:url])) &#123;</span><br><span class="line">            &#x2F;&#x2F; 有图片 并且操作类型为 SDWebImageRefreshCached （先用缓存图片回调block 图片下载完成后再回调block）</span><br><span class="line">            if (image &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span><br><span class="line">                dispatch_main_sync_safe(^&#123;</span><br><span class="line">                    &#x2F;&#x2F; If image was found in the cache but SDWebImageRefreshCached is provided, notify about the cached image</span><br><span class="line">                    &#x2F;&#x2F; AND try to re-download it in order to let a chance to NSURLCache to refresh it from server.</span><br><span class="line">                    completedBlock(image, nil, cacheType, YES, url);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; download if no image or requested to refresh anyway, and download allowed by delegate</span><br><span class="line">            &#x2F;&#x2F; 根据SDWebImageOptions的类型 得到SDWebImageDownloaderOptions 都是一些位运算</span><br><span class="line">            SDWebImageDownloaderOptions downloaderOptions &#x3D; 0;</span><br><span class="line">            if (options &amp; SDWebImageLowPriority) downloaderOptions |&#x3D; SDWebImageDownloaderLowPriority;</span><br><span class="line">            if (options &amp; SDWebImageProgressiveDownload) downloaderOptions |&#x3D; SDWebImageDownloaderProgressiveDownload;</span><br><span class="line">            if (options &amp; SDWebImageRefreshCached) downloaderOptions |&#x3D; SDWebImageDownloaderUseNSURLCache;</span><br><span class="line">            if (options &amp; SDWebImageContinueInBackground) downloaderOptions |&#x3D; SDWebImageDownloaderContinueInBackground;</span><br><span class="line">            if (options &amp; SDWebImageHandleCookies) downloaderOptions |&#x3D; SDWebImageDownloaderHandleCookies;</span><br><span class="line">            if (options &amp; SDWebImageAllowInvalidSSLCertificates) downloaderOptions |&#x3D; SDWebImageDownloaderAllowInvalidSSLCertificates;</span><br><span class="line">            if (options &amp; SDWebImageHighPriority) downloaderOptions |&#x3D; SDWebImageDownloaderHighPriority;</span><br><span class="line">            if (image &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span><br><span class="line">                &#x2F;&#x2F; force progressive off if image already cached but forced refreshing</span><br><span class="line">                downloaderOptions &amp;&#x3D; ~SDWebImageDownloaderProgressiveDownload;</span><br><span class="line">                &#x2F;&#x2F; ignore image read from NSURLCache if image if cached but force refreshing</span><br><span class="line">                downloaderOptions |&#x3D; SDWebImageDownloaderIgnoreCachedResponse;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 下载图片</span><br><span class="line">            id &lt;SDWebImageOperation&gt; subOperation &#x3D; [self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage *downloadedImage, NSData *data, NSError *error, BOOL finished) &#123;</span><br><span class="line">                if (weakOperation.isCancelled) &#123;</span><br><span class="line">                    &#x2F;&#x2F; Do nothing if the operation was cancelled</span><br><span class="line">                    &#x2F;&#x2F; See #699 for more details</span><br><span class="line">                    &#x2F;&#x2F; if we would call the completedBlock, there could be a race condition between this block and another completedBlock for the same object, so if this one is called second, we will overwrite the new data</span><br><span class="line">                    &#x2F;&#x2F; 操作被取消 则不做任何操作</span><br><span class="line">                &#125;</span><br><span class="line">                else if (error) &#123; &#x2F;&#x2F; 出错</span><br><span class="line">                    dispatch_main_sync_safe(^&#123;</span><br><span class="line">                        if (!weakOperation.isCancelled) &#123;</span><br><span class="line">                            completedBlock(nil, error, SDImageCacheTypeNone, finished, url);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">                    if (   error.code !&#x3D; NSURLErrorNotConnectedToInternet</span><br><span class="line">                        &amp;&amp; error.code !&#x3D; NSURLErrorCancelled</span><br><span class="line">                        &amp;&amp; error.code !&#x3D; NSURLErrorTimedOut</span><br><span class="line">                        &amp;&amp; error.code !&#x3D; NSURLErrorInternationalRoamingOff</span><br><span class="line">                        &amp;&amp; error.code !&#x3D; NSURLErrorDataNotAllowed</span><br><span class="line">                        &amp;&amp; error.code !&#x3D; NSURLErrorCannotFindHost</span><br><span class="line">                        &amp;&amp; error.code !&#x3D; NSURLErrorCannotConnectToHost) &#123;</span><br><span class="line">                        @synchronized (self.failedURLs) &#123; &#x2F;&#x2F; 添加到失败URL数组</span><br><span class="line">                            [self.failedURLs addObject:url];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123; &#x2F;&#x2F; 下载成功</span><br><span class="line">                    if ((options &amp; SDWebImageRetryFailed)) &#123; &#x2F;&#x2F; 操作类型为失败重新刷新</span><br><span class="line">                        @synchronized (self.failedURLs) &#123;</span><br><span class="line">                            [self.failedURLs removeObject:url];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F; 是否存储在磁盘</span><br><span class="line">                    BOOL cacheOnDisk &#x3D; !(options &amp; SDWebImageCacheMemoryOnly);</span><br><span class="line"></span><br><span class="line">                    if (options &amp; SDWebImageRefreshCached &amp;&amp; image &amp;&amp; !downloadedImage) &#123;</span><br><span class="line">                        &#x2F;&#x2F; Image refresh hit the NSURLCache cache, do not call the completion block</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F; 图片下载成功 并且需要转换图片</span><br><span class="line">                    else if (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)]) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 在全局队列中 异步进行操作</span><br><span class="line">                        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">                            &#x2F;&#x2F; 根据代理获取转换后的图片</span><br><span class="line">                            UIImage *transformedImage &#x3D; [self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url];</span><br><span class="line">                            &#x2F;&#x2F; 转换图片存在 并且下载图片操作已完成 则存储图片</span><br><span class="line">                            if (transformedImage &amp;&amp; finished) &#123;</span><br><span class="line">                                BOOL imageWasTransformed &#x3D; ![transformedImage isEqual:downloadedImage];</span><br><span class="line">                                [self.imageCache storeImage:transformedImage recalculateFromImage:imageWasTransformed imageData:(imageWasTransformed ? nil : data) forKey:key toDisk:cacheOnDisk];</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                                if (!weakOperation.isCancelled) &#123; &#x2F;&#x2F; block回调</span><br><span class="line">                                    completedBlock(transformedImage, nil, SDImageCacheTypeNone, finished, url);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    else &#123; &#x2F;&#x2F; 存储图片 并且 block回调</span><br><span class="line">                        if (downloadedImage &amp;&amp; finished) &#123;</span><br><span class="line">                            [self.imageCache storeImage:downloadedImage recalculateFromImage:NO imageData:data forKey:key toDisk:cacheOnDisk];</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        dispatch_main_sync_safe(^&#123;</span><br><span class="line">                            if (!weakOperation.isCancelled) &#123;</span><br><span class="line">                                completedBlock(downloadedImage, nil, SDImageCacheTypeNone, finished, url);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (finished) &#123; &#x2F;&#x2F; 如果已完成 则将该请求操作从数组中删除</span><br><span class="line">                    @synchronized (self.runningOperations) &#123;</span><br><span class="line">                        [self.runningOperations removeObject:operation];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">            &#x2F;&#x2F; 取消操作 从数组中删除该操作</span><br><span class="line">            operation.cancelBlock &#x3D; ^&#123;</span><br><span class="line">                [subOperation cancel];</span><br><span class="line">                </span><br><span class="line">                @synchronized (self.runningOperations) &#123;</span><br><span class="line">                    [self.runningOperations removeObject:weakOperation];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (image) &#123; &#x2F;&#x2F; 有图片 并且线程没有被取消 则返回有图片的block</span><br><span class="line">            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                if (!weakOperation.isCancelled) &#123;</span><br><span class="line">                    completedBlock(image, nil, cacheType, YES, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            @synchronized (self.runningOperations) &#123;</span><br><span class="line">                [self.runningOperations removeObject:operation];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; Image not in cache and download disallowed by delegate</span><br><span class="line">            &#x2F;&#x2F; 图片没有被缓存 并且没有被代理通知可以下载图片 则返回没有图片的block</span><br><span class="line">            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                if (!weakOperation.isCancelled) &#123;</span><br><span class="line">                    completedBlock(nil, nil, SDImageCacheTypeNone, YES, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            @synchronized (self.runningOperations) &#123;</span><br><span class="line">                [self.runningOperations removeObject:operation];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SDWebImageDecoder"><a href="#SDWebImageDecoder" class="headerlink" title="SDWebImageDecoder"></a>SDWebImageDecoder</h2><p><code>SDWebImageDecoder</code>主要是用来强制解压图片的。这里代码有些底层，不是很理解，后面在问题中有相关的描述。</p>
<h2 id="SDWebImagePrefetcher"><a href="#SDWebImagePrefetcher" class="headerlink" title="SDWebImagePrefetcher"></a>SDWebImagePrefetcher</h2><p><code>SDWebImagePrefetcher</code>用来预取图片的。它用<code>GCD</code>在主线程中通过<code>SDWebImageManager</code>来预取图片，并通过<code>delegate</code>和<code>block</code>回到相关状态和进度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  开始预取URL数组的第几张图片</span><br><span class="line"> *</span><br><span class="line"> *  @param index index description</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)startPrefetchingAtIndex:(NSUInteger)index &#123;</span><br><span class="line">    &#x2F;&#x2F; 判断index是否越界</span><br><span class="line">    if (index &gt;&#x3D; self.prefetchURLs.count) return;</span><br><span class="line">    &#x2F;&#x2F; 请求个数 +1</span><br><span class="line">    self.requestedCount++;</span><br><span class="line">    &#x2F;&#x2F; 用SDWebImageManager 下载图片</span><br><span class="line">    [self.manager downloadImageWithURL:self.prefetchURLs[index] options:self.options progress:nil completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123;</span><br><span class="line">        if (!finished) return;</span><br><span class="line">        &#x2F;&#x2F; 完成个数 +1</span><br><span class="line">        self.finishedCount++;</span><br><span class="line">        &#x2F;&#x2F; 有图片</span><br><span class="line">        if (image) &#123;</span><br><span class="line">            &#x2F;&#x2F; 进度block回调</span><br><span class="line">            if (self.progressBlock) &#123;</span><br><span class="line">                self.progressBlock(self.finishedCount,[self.prefetchURLs count]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; 进度block回调</span><br><span class="line">            if (self.progressBlock) &#123;</span><br><span class="line">                self.progressBlock(self.finishedCount,[self.prefetchURLs count]);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 下载完成 但是没图片 跳过个数 +1</span><br><span class="line">            &#x2F;&#x2F; Add last failed</span><br><span class="line">            self.skippedCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; delegate 回调</span><br><span class="line">        if ([self.delegate respondsToSelector:@selector(imagePrefetcher:didPrefetchURL:finishedCount:totalCount:)]) &#123;</span><br><span class="line">            [self.delegate imagePrefetcher:self</span><br><span class="line">                            didPrefetchURL:self.prefetchURLs[index]</span><br><span class="line">                             finishedCount:self.finishedCount</span><br><span class="line">                                totalCount:self.prefetchURLs.count</span><br><span class="line">             ];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 如果完成个数与请求个数相等 则下载已完成</span><br><span class="line">        else if (self.finishedCount &#x3D;&#x3D; self.requestedCount) &#123;</span><br><span class="line">            &#x2F;&#x2F; delegate报告完成状态</span><br><span class="line">            [self reportStatus];</span><br><span class="line">            &#x2F;&#x2F; 完成block回调</span><br><span class="line">            if (self.completionBlock) &#123;</span><br><span class="line">                self.completionBlock(self.finishedCount, self.skippedCount);</span><br><span class="line">                self.completionBlock &#x3D; nil;</span><br><span class="line">            &#125;</span><br><span class="line">            self.progressBlock &#x3D; nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  报告完成的状态</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)reportStatus &#123;</span><br><span class="line">    NSUInteger total &#x3D; [self.prefetchURLs count];</span><br><span class="line">    &#x2F;&#x2F; delegate回调</span><br><span class="line">    if ([self.delegate respondsToSelector:@selector(imagePrefetcher:didFinishWithTotalCount:skippedCount:)]) &#123;</span><br><span class="line">        [self.delegate imagePrefetcher:self</span><br><span class="line">               didFinishWithTotalCount:(total - self.skippedCount)</span><br><span class="line">                          skippedCount:self.skippedCount</span><br><span class="line">         ];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  开始预取URL</span><br><span class="line"> *</span><br><span class="line"> *  @param urls URL数组</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)prefetchURLs:(NSArray *)urls &#123;</span><br><span class="line">    [self prefetchURLs:urls progress:nil completed:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  预取URL</span><br><span class="line"> *</span><br><span class="line"> *  @param urls            url数组</span><br><span class="line"> *  @param progressBlock   进度block</span><br><span class="line"> *  @param completionBlock 完成block</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)prefetchURLs:(NSArray *)urls progress:(SDWebImagePrefetcherProgressBlock)progressBlock completed:(SDWebImagePrefetcherCompletionBlock)completionBlock &#123;</span><br><span class="line">    &#x2F;&#x2F; 取消预取 防止重复的操作</span><br><span class="line">    [self cancelPrefetching]; &#x2F;&#x2F; Prevent duplicate prefetch request</span><br><span class="line">    &#x2F;&#x2F; 开始时间</span><br><span class="line">    self.startedTime &#x3D; CFAbsoluteTimeGetCurrent();</span><br><span class="line">    self.prefetchURLs &#x3D; urls;</span><br><span class="line">    self.completionBlock &#x3D; completionBlock;</span><br><span class="line">    self.progressBlock &#x3D; progressBlock;</span><br><span class="line"></span><br><span class="line">    __weak SDWebImagePrefetcher *weakSelf &#x3D; self;</span><br><span class="line">    &#x2F;&#x2F; 如果URL为空</span><br><span class="line">    if (urls.count &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            completionBlock(0,0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; http:&#x2F;&#x2F;oleb.net&#x2F;blog&#x2F;2013&#x2F;07&#x2F;parallelize-for-loops-gcd-dispatch_apply&#x2F;</span><br><span class="line">        &#x2F;&#x2F; Optimize the maxConcurrentdownloads for effeciency. Since caching operations are involved that are non-trivial using</span><br><span class="line">        &#x2F;&#x2F; dispatch_apply might be helpful.</span><br><span class="line">        &#x2F;&#x2F; 用dispatch_apply 优化并发下载的性能</span><br><span class="line">        NSInteger maxNumberOfImages &#x3D; self.prefetchURLs.count;</span><br><span class="line">        </span><br><span class="line">        dispatch_apply(maxNumberOfImages&#x2F;self.maxConcurrentDownloads, self.prefetcherQueue, ^(size_t index) &#123;</span><br><span class="line">            size_t i &#x3D; index * self.maxConcurrentDownloads;</span><br><span class="line">            size_t stop &#x3D; i + self.maxConcurrentDownloads;</span><br><span class="line">            do &#123;</span><br><span class="line">                [weakSelf startPrefetchingAtIndex:i++];</span><br><span class="line">            &#125; while (i &lt; stop);</span><br><span class="line">        &#125;);</span><br><span class="line">        &#x2F;&#x2F; 现在剩余的图片</span><br><span class="line">        &#x2F;&#x2F; Download remaining images.</span><br><span class="line">        for (size_t i &#x3D; maxNumberOfImages - (maxNumberOfImages % self.maxConcurrentDownloads); i &lt; (size_t)maxNumberOfImages; i++) &#123;</span><br><span class="line">            [self startPrefetchingAtIndex:i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>看到它预取图片的代码，我就想起了我在项目中上传多张图片时的循环代码，虽然我的那段代码能够完成功能，但是还是不够高大上哈。</p>
<h1 id="Categories"><a href="#Categories" class="headerlink" title="Categories"></a>Categories</h1><p><code>Categories</code>文件夹里面全都是类别文件，可以分为两类吧：1、显示图片；2、操作Image数据。<br>本文主要分析与显示图片的<code>UIView+WebCacheOperation</code>基础文件和<code>UIImageView+WebCache</code>大众文件，因为其他关于是图片的扩张和<code>UIImageView+WebCache</code>类似。</p>
<h2 id="UIView-WebCacheOperation"><a href="#UIView-WebCacheOperation" class="headerlink" title="UIView+WebCacheOperation"></a>UIView+WebCacheOperation</h2><p><code>UIView+WebCacheOperation</code>类别主要存储下载操作，这样其他继承自View需要显示Image的视图，就可以使用这些方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  runtime获取存储操作线程的字典</span><br><span class="line"> *</span><br><span class="line"> *  @return &lt;#return value description#&gt;</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSMutableDictionary *)operationDictionary &#123;</span><br><span class="line">    NSMutableDictionary *operations &#x3D; objc_getAssociatedObject(self, &amp;loadOperationKey);</span><br><span class="line">    if (operations) &#123;</span><br><span class="line">        return operations;</span><br><span class="line">    &#125;</span><br><span class="line">    operations &#x3D; [NSMutableDictionary dictionary];</span><br><span class="line">    objc_setAssociatedObject(self, &amp;loadOperationKey, operations, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    return operations;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> *  设置下载图片的线程</span><br><span class="line"> *</span><br><span class="line"> *  @param operation 线程</span><br><span class="line"> *  @param key       key</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)sd_setImageLoadOperation:(id)operation forKey:(NSString *)key &#123;</span><br><span class="line">    &#x2F;&#x2F; 在设置之前先cancel</span><br><span class="line">    [self sd_cancelImageLoadOperationWithKey:key];</span><br><span class="line">    NSMutableDictionary *operationDictionary &#x3D; [self operationDictionary];</span><br><span class="line">    [operationDictionary setObject:operation forKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  根据key取消相关的下载操作</span><br><span class="line"> *</span><br><span class="line"> *  @param key &lt;#key description#&gt;</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)sd_cancelImageLoadOperationWithKey:(NSString *)key &#123;</span><br><span class="line">    &#x2F;&#x2F; Cancel in progress downloader from queue</span><br><span class="line">    NSMutableDictionary *operationDictionary &#x3D; [self operationDictionary];</span><br><span class="line">    id operations &#x3D; [operationDictionary objectForKey:key];</span><br><span class="line">    &#x2F;&#x2F; 操作存在</span><br><span class="line">    if (operations) &#123;</span><br><span class="line">        &#x2F;&#x2F; 数组</span><br><span class="line">        if ([operations isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">            for (id &lt;SDWebImageOperation&gt; operation in operations) &#123;</span><br><span class="line">                if (operation) &#123;</span><br><span class="line">                    [operation cancel];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if ([operations conformsToProtocol:@protocol(SDWebImageOperation)])&#123; &#x2F;&#x2F; 实现了 SDWebImageOperation 协议</span><br><span class="line">            [(id&lt;SDWebImageOperation&gt;) operations cancel];</span><br><span class="line">        &#125;</span><br><span class="line">        [operationDictionary removeObjectForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  移除下载操作 并没有取消该操作</span><br><span class="line"> *</span><br><span class="line"> *  @param key &lt;#key description#&gt;</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)sd_removeImageLoadOperationWithKey:(NSString *)key &#123;</span><br><span class="line">    NSMutableDictionary *operationDictionary &#x3D; [self operationDictionary];</span><br><span class="line">    [operationDictionary removeObjectForKey:key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="UIImageView-WebCache"><a href="#UIImageView-WebCache" class="headerlink" title="UIImageView+WebCache"></a>UIImageView+WebCache</h2><p><code>UIImageView+WebCache</code>类别是我们在项目用到最多的，谁叫项目中有那么多地方需要显示图片呢。。。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  下载Image</span><br><span class="line"> *</span><br><span class="line"> *  @param url            URL</span><br><span class="line"> *  @param placeholder    占位符图片</span><br><span class="line"> *  @param options        操作类型</span><br><span class="line"> *  @param progressBlock  进度block</span><br><span class="line"> *  @param completedBlock 完成block</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock &#123;</span><br><span class="line">    &#x2F;&#x2F; 取消正在下载的线程</span><br><span class="line">    [self sd_cancelCurrentImageLoad];</span><br><span class="line">    &#x2F;&#x2F; runtime设置 URL属性</span><br><span class="line">    objc_setAssociatedObject(self, &amp;imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    &#x2F;&#x2F; 如果不需要延时设置占位符图片 则先显示占位符图片</span><br><span class="line">    if (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">            self.image &#x3D; placeholder;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (url) &#123; &#x2F;&#x2F; URL存在</span><br><span class="line">        &#x2F;&#x2F; check if activityView is enabled or not</span><br><span class="line">        if ([self showActivityIndicatorView]) &#123; &#x2F;&#x2F; 是否在下载图片的时候显示指示器</span><br><span class="line">            [self addActivityIndicator];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        __weak __typeof(self)wself &#x3D; self;</span><br><span class="line">        &#x2F;&#x2F; 用SDWebImageManager 来下载管理图片</span><br><span class="line">        id &lt;SDWebImageOperation&gt; operation &#x3D; [SDWebImageManager.sharedManager downloadImageWithURL:url options:options progress:progressBlock completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123;</span><br><span class="line">            &#x2F;&#x2F; 下载完成 移除指示器</span><br><span class="line">            [wself removeActivityIndicator];</span><br><span class="line">            if (!wself) return;</span><br><span class="line">            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                if (!wself) return;</span><br><span class="line">                &#x2F;&#x2F; 不自动设置图片</span><br><span class="line">                if (image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage) &amp;&amp; completedBlock)</span><br><span class="line">                &#123;</span><br><span class="line">                    completedBlock(image, error, cacheType, url);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 设置图片 并Layout</span><br><span class="line">                else if (image) &#123;</span><br><span class="line">                    wself.image &#x3D; image;</span><br><span class="line">                    [wself setNeedsLayout];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    &#x2F;&#x2F; 延时设置占位符图片</span><br><span class="line">                    if ((options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">                        wself.image &#x3D; placeholder;</span><br><span class="line">                        [wself setNeedsLayout];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 下载完成并且回调</span><br><span class="line">                if (completedBlock &amp;&amp; finished) &#123;</span><br><span class="line">                    completedBlock(image, error, cacheType, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;];</span><br><span class="line">        &#x2F;&#x2F; 存储设置操作对象</span><br><span class="line">        [self sd_setImageLoadOperation:operation forKey:@&quot;UIImageViewImageLoad&quot;];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        dispatch_main_async_safe(^&#123; &#x2F;&#x2F; 移除指示器 并回调错误 block</span><br><span class="line">            [self removeActivityIndicator];</span><br><span class="line">            NSError *error &#x3D; [NSError errorWithDomain:SDWebImageErrorDomain code:-1 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Trying to load a nil url&quot;&#125;];</span><br><span class="line">            if (completedBlock) &#123;</span><br><span class="line">                completedBlock(nil, error, SDImageCacheTypeNone, url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="所遇问题"><a href="#所遇问题" class="headerlink" title="所遇问题"></a>所遇问题</h1><h2 id="SDScaledImageForKey-方法"><a href="#SDScaledImageForKey-方法" class="headerlink" title="SDScaledImageForKey 方法"></a>SDScaledImageForKey 方法</h2><p>为什么在block回调图片之前要使用<code>SDScaledImageForKey</code>方法缩放图片呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  缩放图片</span><br><span class="line"> *</span><br><span class="line"> *  @param key   key URL</span><br><span class="line"> *  @param image 图片</span><br><span class="line"> *</span><br><span class="line"> *  @return return value description</span><br><span class="line"> *&#x2F;</span><br><span class="line">inline UIImage *SDScaledImageForKey(NSString *key, UIImage *image) &#123;</span><br><span class="line">    if (!image) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; animation Image</span><br><span class="line">    if ([image.images count] &gt; 0) &#123;</span><br><span class="line">        NSMutableArray *scaledImages &#x3D; [NSMutableArray array];</span><br><span class="line">        &#x2F;&#x2F; 递归遍历</span><br><span class="line">        for (UIImage *tempImage in image.images) &#123;</span><br><span class="line">            [scaledImages addObject:SDScaledImageForKey(key, tempImage)];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 获取图片</span><br><span class="line">        return [UIImage animatedImageWithImages:scaledImages duration:image.duration];</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        &#x2F;&#x2F; 获取缩放比例</span><br><span class="line">        if ([[UIScreen mainScreen] respondsToSelector:@selector(scale)]) &#123;</span><br><span class="line">            CGFloat scale &#x3D; [UIScreen mainScreen].scale;</span><br><span class="line">            if (key.length &gt;&#x3D; 8) &#123;</span><br><span class="line">                NSRange range &#x3D; [key rangeOfString:@&quot;@2x.&quot;];</span><br><span class="line">                if (range.location !&#x3D; NSNotFound) &#123;</span><br><span class="line">                    scale &#x3D; 2.0;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                range &#x3D; [key rangeOfString:@&quot;@3x.&quot;];</span><br><span class="line">                if (range.location !&#x3D; NSNotFound) &#123;</span><br><span class="line">                    scale &#x3D; 3.0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 获取图片</span><br><span class="line">            UIImage *scaledImage &#x3D; [[UIImage alloc] initWithCGImage:image.CGImage scale:scale orientation:image.imageOrientation];</span><br><span class="line">            image &#x3D; scaledImage;</span><br><span class="line">        &#125;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举个例子吧，我们在命名图片的时候都是以<code>xxxx@2x.png</code>、<code>xxxx@3x.png</code>结尾的，但是我们在创建<code> Image</code>的时候并不需要在后面添加倍数，只需调用<code>[UIImage imageNamed:@&quot;xxxx&quot;]</code>即可，因为<code>Xcode</code>会帮我们根据当前分比率自动添加后缀倍数。如果你有一张<code>72*72</code>的二倍图片，当你以<code>[UIImage imageNamed:@&quot;xxxx@2x&quot;]</code>的方法加载图片的时候，你会发现图片被拉伸了，它的大小变为<code>144*144</code>了，这是因为Xcode自动添加二部后，以<code>xxxx@2x@2x</code>去查找图片，当它找不到的时候就把<code>xxxx@2x</code>图片当做一倍图片处理，所以图片的<code>size</code>就变大了，所以<code>SDScaledImageForKey</code>方法就是解决这件事情，以防<code>url</code>里面包含<code>@&quot;2x&quot;、@&quot;3x&quot;</code>等字符串，从而使图片<code>size</code>变大。</p>
<h2 id="decodedImageWithImage-方法"><a href="#decodedImageWithImage-方法" class="headerlink" title="decodedImageWithImage: 方法"></a>decodedImageWithImage: 方法</h2><p>为什么从磁盘里面取出图片后，block回调之前要解压图片呢？因为图片在<code>ImageView</code>上面显示的时候需要解压，而这个解压操作是在主线程里面进行的，比较耗时，这样就会产生延时效果，而用<code>decodedImageWithImage:</code>在后台解压能够解决这一问题，但是这种<code>用空间换时间</code>的方法也存在着内存暴增甚至崩溃等问题，所以自己得权衡一下。这就是为什么<code>SDImageCache、SDWebImageDownloader、SDWebImageDownloaderOperation</code>类中都有<code>shouldDecompressImages (是否解压图片)</code>值存在的原因。<br>关于图片解压的问题，可以看<a href="https://www.cocoanetics.com/2011/10/avoiding-image-decompression-sickness/">Avoiding Image Decompression Sickness</a>这篇博客。解压图片而产生的相关问题，以及解决方案的由来可以看<a href="https://github.com/rs/SDWebImage/issues/586">How to solve the memory consumption for the decodedImageWithImage</a>这个issue。</p>
<h2 id="addReadOnlyCachePath-方法"><a href="#addReadOnlyCachePath-方法" class="headerlink" title="addReadOnlyCachePath: 方法"></a>addReadOnlyCachePath: 方法</h2><p>增加一个只读的缓存的路径，从<code>diskImageDataBySearchingAllPathsForKey:</code>方法看出，当<code>SDImageCache</code>找不到缓存的时候，才会尝试到这个路径下去查找。在从缓存中查找的时候，数组<code>customPaths</code>的字符串是通过<code>addReadOnlyCachePath:</code>方法添加进去，在Demo的<code>AppDelegate</code>里面有写这段代码。但是我还没搞清楚这段代码具体作用，因为在该类中只要在磁盘查找时才有操作，而缓存图片的时候并没有暴露出设置缓存路径的方法。所以我提了个<a href="https://github.com/rs/SDWebImage/issues/1372">issue</a>.</p>
<h2 id="NS-OPTIONS-vs-NS-ENUM"><a href="#NS-OPTIONS-vs-NS-ENUM" class="headerlink" title="NS_OPTIONS vs NS_ENUM"></a>NS_OPTIONS vs NS_ENUM</h2><p>这两个都是用来定义枚举的，但是他们的区别、优缺点在哪里呢？</p>
<h2 id="清理缓存的逻辑"><a href="#清理缓存的逻辑" class="headerlink" title="清理缓存的逻辑"></a>清理缓存的逻辑</h2><p>设置最大缓存空间大小。在程序即将退出以及进入后台的时候清理缓存。首先清理缓存时间过期的资源，如果清理完成以后，所占的大小还是大于最大阀值，则按时间顺序来清理，使清理后的空间大小是最大阀值的一半。当然最重要的还是设置最大阀值。</p>
<h2 id="clear-vs-clean"><a href="#clear-vs-clean" class="headerlink" title="clear vs clean"></a>clear vs clean</h2><p>哈哈，其实这个不算是什么问题，或许是我英语差吧，总感觉这两个词的意思差不过。在看完源码以后我才知道。<code>clear</code>:清除（清除干净，除掉嘛，清除所有的缓存文件）。 <code>clean</code>:清理（就简单清理一下，清理过期的缓存文件）。</p>
<h2 id="位运算操作"><a href="#位运算操作" class="headerlink" title="位运算操作"></a>位运算操作</h2><p>依稀记得在大学学计算机网络的时候有接触过，后面就一直没有接触了，第一次看到还是有点懵的（好菜的说）。当然<code>Xcode</code>在<code>lldb</code>状态下可以进行位运算。<a href="http://joakimliu.github.io/2015/05/22/Some-Debug-Method-in-iOS/">详情请看</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">取反（NOT） ~  （数字1成为0，0成为1）</span><br><span class="line">~  0111</span><br><span class="line">&#x3D;  1000</span><br><span class="line"></span><br><span class="line">按位或 （OR）|   （两个相应的二进位中只要有一个为1，该位的结果就为1）</span><br><span class="line">   0101</span><br><span class="line">|  0011</span><br><span class="line">&#x3D; 0111</span><br><span class="line"></span><br><span class="line">按位异或 （XOR） ^ （如果某位不同则该位为1，否则该位为0）</span><br><span class="line">    0101</span><br><span class="line">^  0011</span><br><span class="line">&#x3D;  0110</span><br><span class="line"></span><br><span class="line">按位与  （AND） &amp;    （两个相应的二进位都为1，该位的结果值才为1，否则为0）</span><br><span class="line">   0101</span><br><span class="line">&amp; 0011</span><br><span class="line">&#x3D; 0001</span><br><span class="line"></span><br><span class="line">左移</span><br><span class="line">   0001</span><br><span class="line">&lt;&lt;  3    （左移3位）</span><br><span class="line">&#x3D; 1000</span><br><span class="line"></span><br><span class="line">右移</span><br><span class="line">    1010</span><br><span class="line">&gt;&gt;  2     （右移2位）</span><br><span class="line">&#x3D;   0010</span><br></pre></td></tr></table></figure>

<h1 id="技术点归纳"><a href="#技术点归纳" class="headerlink" title="技术点归纳"></a>技术点归纳</h1><p>与图片相关的，这些知识都是与图片相关的，无需一定要掌握（除非你要深度研究图片）。<br>1、<code>PNG</code>图片的判断。可以看<code>SDImageCache</code>的<code>ImageDataHasPNGPreffix</code>方法。<br>2、<code>Image Data</code>判断图片类型以及根据<code>data</code>创建图片。可以查看<code>NSData+ImageContentType</code>和<code>UIImage+MultiFormat</code>类。<br>3、图片解压（以及解压带来内存问题）。<code>SDWebImageDecoder</code>类中的<code>decodedImageWithImage:</code>方法的实现，牵扯到底层图片相关的操作。<br>4、<code>gif</code>图片的处理。虽然<code>SD</code>对<code>GIF</code>的支持比较差劲。但是老外的纯技术精神，不得不佩服。请看issue<a href="https://github.com/rs/SDWebImage/issues/945">#945</a><br>iOS开发技术，这些东西都是项目中比较常用的技术，一定要掌握。<br>1、<code>NSFileManager</code>的操作。在获取缓存大小相关内容时，需要我们熟练掌握<code>NSFileManager</code>类的相关用法。<br>2、<code>NSCache</code>类。在<code>SD</code>的<code>issue</code>上面，由<code>NSCache</code>缓存引起的问题（如内存警告等）还是有很多的，后面才得到改善。<br>3、<code>NSOperation</code>、<code>NSOperationQueue</code>、<code>NSThread</code>、<code>@synchronized</code>线程及操作队列相关类。<br>4、<code>GCD</code>。<code>dispatch_barrier_sync</code>、<code>dispatch_apply</code>等函数。<br>5、<code>NSURLRequest</code>、<code>NSURLResponse</code>、<code>NSURLConnection</code>、<code>NSURLCache</code>等网络请求相关类。<br>6、后台操作。<br>7、<code>Runloop</code>。<br>8、<code>Runtime</code>。<br>9、<code>KVO</code>。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>SD</code>的源码大概仔细的看了3次吧，然后也有看到它的一些<code>issue</code>，一个好的项目都是一点点完善的。看完以后，感触挺大的，毕竟第一次嘛。<br>1、个人位置。最近我们社区比较火的<a href="https://github.com/ibireme">YY</a>，今天上午初略看了他的代码，C基础、代码规范、编码功底都牛逼的不行，厚积薄发！一鸣惊人！感觉自己两年的iOS开发经验白搭了（当然了，其中也有个人因素，也有其他环境因素）。我个人觉得还是得去正规点的公司，至少产品经理要比较专业，因为如果一个项目都不能吸引你，那你也完全在浪费时间。还有小公司自己的好好考虑，因为我以前待过的纯互联网公司，就没有规模上过20人的，你能想象我以前的名片还是产品经理么？！现在想起来，好想笑。这里并没有贬低我以前东家的意思！！！<br>2、执行力。执行力还得大大加强，从这个月15号到25号，虽然这段时间也有加班，有在研究新的东西，但貌似搞技术最晚就昨晚吧，凌晨1点半才睡。蠢可以，但是懒就不行！<br>3、技术掌握范围。从上面归纳的技术点来看，我真的菜很菜非常菜！<br>4、学习方法。focus！focus！！focus！！！</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/SDWebImage/" rel="tag"># SDWebImage</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2015/10/14/new-skill-in-this-week-two/" rel="prev" title="这周所学新技巧（2）">
      <i class="fa fa-chevron-left"></i> 这周所学新技巧（2）
    </a></div>
      <div class="post-nav-item">
    <a href="/2016/03/04/NSDate%20Tips/" rel="next" title="NSDate读取相差31年的问题">
      NSDate读取相差31年的问题 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Cache"><span class="nav-number">1.</span> <span class="nav-text">Cache</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%9B%BE%E7%89%87"><span class="nav-number">1.1.</span> <span class="nav-text">缓存图片</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="nav-number">1.2.</span> <span class="nav-text">查询获取数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B8%85%E7%90%86%E6%95%B0%E6%8D%AE"><span class="nav-number">1.3.</span> <span class="nav-text">清理数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E9%83%A8%E6%B8%85%E7%90%86"><span class="nav-number">1.3.1.</span> <span class="nav-text">全部清理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%83%A8%E5%88%86%E6%B8%85%E7%90%86"><span class="nav-number">1.3.2.</span> <span class="nav-text">部分清理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%AD%98%E5%82%A8%E5%AE%B9%E9%87%8F%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE"><span class="nav-number">1.4.</span> <span class="nav-text">获取存储容量相关数据</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Downloader"><span class="nav-number">2.</span> <span class="nav-text">Downloader</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#SDWebImageDownloader"><span class="nav-number">2.1.</span> <span class="nav-text">SDWebImageDownloader</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8B%E8%BD%BD%E9%80%89%E9%A1%B9"><span class="nav-number">2.1.1.</span> <span class="nav-text">下载选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8B%E8%BD%BD%E9%A1%BA%E5%BA%8F"><span class="nav-number">2.1.2.</span> <span class="nav-text">下载顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E8%B0%83block"><span class="nav-number">2.1.3.</span> <span class="nav-text">回调block</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SDWebImageDownloader%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">2.1.4.</span> <span class="nav-text">SDWebImageDownloader源码分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SDWebImageDownloaderOperation"><span class="nav-number">2.2.</span> <span class="nav-text">SDWebImageDownloaderOperation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NSURLConnectionDataDelegate"><span class="nav-number">2.2.1.</span> <span class="nav-text">NSURLConnectionDataDelegate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NSURLConnectionDelegate"><span class="nav-number">2.2.2.</span> <span class="nav-text">NSURLConnectionDelegate</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Utils"><span class="nav-number">3.</span> <span class="nav-text">Utils</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#SDWebImageManager"><span class="nav-number">3.1.</span> <span class="nav-text">SDWebImageManager</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SDWebImageDecoder"><span class="nav-number">3.2.</span> <span class="nav-text">SDWebImageDecoder</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SDWebImagePrefetcher"><span class="nav-number">3.3.</span> <span class="nav-text">SDWebImagePrefetcher</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Categories"><span class="nav-number">4.</span> <span class="nav-text">Categories</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#UIView-WebCacheOperation"><span class="nav-number">4.1.</span> <span class="nav-text">UIView+WebCacheOperation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UIImageView-WebCache"><span class="nav-number">4.2.</span> <span class="nav-text">UIImageView+WebCache</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%80%E9%81%87%E9%97%AE%E9%A2%98"><span class="nav-number">5.</span> <span class="nav-text">所遇问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#SDScaledImageForKey-%E6%96%B9%E6%B3%95"><span class="nav-number">5.1.</span> <span class="nav-text">SDScaledImageForKey 方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#decodedImageWithImage-%E6%96%B9%E6%B3%95"><span class="nav-number">5.2.</span> <span class="nav-text">decodedImageWithImage: 方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#addReadOnlyCachePath-%E6%96%B9%E6%B3%95"><span class="nav-number">5.3.</span> <span class="nav-text">addReadOnlyCachePath: 方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NS-OPTIONS-vs-NS-ENUM"><span class="nav-number">5.4.</span> <span class="nav-text">NS_OPTIONS vs NS_ENUM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B8%85%E7%90%86%E7%BC%93%E5%AD%98%E7%9A%84%E9%80%BB%E8%BE%91"><span class="nav-number">5.5.</span> <span class="nav-text">清理缓存的逻辑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#clear-vs-clean"><span class="nav-number">5.6.</span> <span class="nav-text">clear vs clean</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E6%93%8D%E4%BD%9C"><span class="nav-number">5.7.</span> <span class="nav-text">位运算操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8A%80%E6%9C%AF%E7%82%B9%E5%BD%92%E7%BA%B3"><span class="nav-number">6.</span> <span class="nav-text">技术点归纳</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">7.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">joakim.liu</p>
  <div class="site-description" itemprop="description">你不解决问题，就会成为问题。iOS菜逗一枚。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">40</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/JoakimLiu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;JoakimLiu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/JoakimLiu" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;JoakimLiu" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">joakim.liu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script>
  var disqus_config = function() {
    this.page.url = "http://example.com/2015/11/15/Resolve-The-SourceCode-Of-SDWebImage/";
    this.page.identifier = "2015/11/15/Resolve-The-SourceCode-Of-SDWebImage/";
    this.page.title = "SDWebImage源码浅析";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://http-joakimliu-github-io.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
